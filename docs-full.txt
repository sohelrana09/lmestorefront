<SYSTEM>This is the full developer documentation for Adobe Commerce Storefront on Edge Delivery Services</SYSTEM>

# Adobe Commerce Storefront Documentation

> Complete documentation for Adobe Commerce Storefront
> Generated: 2025-11-02T15:02:21.251Z
> Source: https://experienceleague.adobe.com/developer/commerce/storefront

This file contains the complete documentation from https://experienceleague.adobe.com/developer/commerce/storefront/ in a single markdown file, optimized for consumption by AI language models and tools.
## Table of Contents


### Get started
- get-started/boilerplate-project
- get-started/browser-compatibility
- get-started/create-storefront
- get-started/index
- get-started/run-lighthouse
- get-started/update-boilerplate

### Setup
- setup/analytics/adobe-experience-platform
- setup/analytics/instrumentation
- setup/configuration/aem-assets-configuration
- setup/configuration/commerce-configuration
- setup/configuration/content-delivery-network
- setup/configuration/cors-setup
- setup/configuration/cors-troubleshooting
- setup/configuration/gated-content
- setup/configuration/index
- setup/configuration/multistore-setup
- setup/configuration/storefront-compatibility/install
- setup/configuration/storefront-compatibility/v247
- setup/configuration/storefront-compatibility/v248
- setup/discovery/architecture
- setup/discovery/data-export-validation
- setup/discovery/luma-bridge
- setup/index
- setup/launch/index
- setup/seo/indexing
- setup/seo/metadata

### Dropins
- dropins/all/_eventbus
- dropins/all/branding
- dropins/all/creating
- dropins/all/events
- dropins/all/extend-or-create
- dropins/all/extending
- dropins/all/installing
- dropins/all/introduction
- dropins/all/labeling
- dropins/all/layouts
- dropins/all/linking
- dropins/all/slots
- dropins/all/styling
- dropins/cart/containers/cart-summary-grid
- dropins/cart/containers/cart-summary-list
- dropins/cart/containers/cart-summary-table
- dropins/cart/containers/coupons
- dropins/cart/containers/empty-cart
- dropins/cart/containers/estimate-shipping
- dropins/cart/containers/gift-cards
- dropins/cart/containers/gift-options
- dropins/cart/containers/index
- dropins/cart/containers/minicart
- dropins/cart/containers/order-summary
- dropins/cart/containers/order-summary-line
- dropins/cart/dictionary
- dropins/cart/events
- dropins/cart/functions
- dropins/cart/index
- dropins/cart/initialization
- dropins/cart/installation
- dropins/cart/slots
- dropins/cart/styles
- dropins/cart/tutorials/add-messages-to-mini-cart
- dropins/cart/tutorials/add-product-lines-to-cart-summary
- dropins/cart/tutorials/configure-cart-summary
- dropins/cart/tutorials/enable-product-variation-updates-in-cart
- dropins/cart/tutorials/gift-options
- dropins/cart/tutorials/order-summary-lines
- dropins/checkout/containers/address-validation
- dropins/checkout/containers/bill-to-shipping-address
- dropins/checkout/containers/estimate-shipping
- dropins/checkout/containers/index
- dropins/checkout/containers/login-form
- dropins/checkout/containers/merged-cart-banner
- dropins/checkout/containers/out-of-stock
- dropins/checkout/containers/payment-methods
- dropins/checkout/containers/place-order
- dropins/checkout/containers/server-error
- dropins/checkout/containers/shipping-methods
- dropins/checkout/containers/terms-and-conditions
- dropins/checkout/dictionary
- dropins/checkout/error-handling
- dropins/checkout/event-handling
- dropins/checkout/events
- dropins/checkout/extending
- dropins/checkout/functions
- dropins/checkout/index
- dropins/checkout/initialization
- dropins/checkout/installation
- dropins/checkout/slots
- dropins/checkout/styles
- dropins/checkout/tutorials/add-payment-method
- dropins/checkout/tutorials/address-integration
- dropins/checkout/tutorials/buy-online-pickup-in-store
- dropins/checkout/tutorials/multi-step
- dropins/checkout/tutorials/validate-shipping-address
- dropins/checkout/utilities
- dropins/order/containers/_order-status
- dropins/order/containers/create-return
- dropins/order/containers/customer-details
- dropins/order/containers/index
- dropins/order/containers/order-cancel-form
- dropins/order/containers/order-cost-summary
- dropins/order/containers/order-product-list
- dropins/order/containers/order-returns
- dropins/order/containers/order-search
- dropins/order/containers/returns-list
- dropins/order/containers/shipping-status
- dropins/order/dictionary
- dropins/order/events
- dropins/order/functions
- dropins/order/index
- dropins/order/initialization
- dropins/order/slots
- dropins/order/styles
- dropins/order/tutorials/order-cancellation
- dropins/payment-services/containers/credit-card
- dropins/payment-services/containers/index
- dropins/payment-services/dictionary
- dropins/payment-services/events
- dropins/payment-services/index
- dropins/payment-services/installation
- dropins/personalization/containers/index
- dropins/personalization/containers/targeted-block
- dropins/personalization/functions
- dropins/personalization/index
- dropins/personalization/initialization
- dropins/product-details/containers/index
- dropins/product-details/containers/product-attributes
- dropins/product-details/containers/product-description
- dropins/product-details/containers/product-gallery
- dropins/product-details/containers/product-giftcard-options
- dropins/product-details/containers/product-header
- dropins/product-details/containers/product-options
- dropins/product-details/containers/product-price
- dropins/product-details/containers/product-quantity
- dropins/product-details/containers/product-short-description
- dropins/product-details/dictionary
- dropins/product-details/events
- dropins/product-details/functions
- dropins/product-details/index
- dropins/product-details/initialization
- dropins/product-details/installation
- dropins/product-details/styles
- dropins/product-discovery/containers/facets
- dropins/product-discovery/containers/index
- dropins/product-discovery/containers/pagination
- dropins/product-discovery/containers/search-results
- dropins/product-discovery/containers/sort-by
- dropins/product-discovery/dictionary
- dropins/product-discovery/events
- dropins/product-discovery/functions
- dropins/product-discovery/index
- dropins/product-discovery/installation
- dropins/product-discovery/slots
- dropins/product-discovery/styles
- dropins/recommendations/containers/index
- dropins/recommendations/containers/product-list
- dropins/recommendations/dictionary
- dropins/recommendations/events
- dropins/recommendations/functions
- dropins/recommendations/index
- dropins/recommendations/installation
- dropins/recommendations/slots
- dropins/recommendations/styles
- dropins/user-account/containers/address-form
- dropins/user-account/containers/address-validation
- dropins/user-account/containers/addresses
- dropins/user-account/containers/customer-information
- dropins/user-account/containers/index
- dropins/user-account/containers/orders-list
- dropins/user-account/dictionary
- dropins/user-account/events
- dropins/user-account/functions
- dropins/user-account/index
- dropins/user-account/initialization
- dropins/user-account/sidebar
- dropins/user-account/styles
- dropins/user-account/tutorials/customize-layout
- dropins/user-account/tutorials/validate-address
- dropins/user-auth/auth-functions
- dropins/user-auth/containers/auth-combine
- dropins/user-auth/containers/index
- dropins/user-auth/containers/reset-password
- dropins/user-auth/containers/sign-in
- dropins/user-auth/containers/sign-up
- dropins/user-auth/containers/success-notification
- dropins/user-auth/containers/update-password
- dropins/user-auth/dictionary
- dropins/user-auth/events
- dropins/user-auth/index
- dropins/user-auth/recaptcha
- dropins/user-auth/slots
- dropins/wishlist/containers/index
- dropins/wishlist/containers/wishlist
- dropins/wishlist/containers/wishlist-alert
- dropins/wishlist/containers/wishlist-item
- dropins/wishlist/containers/wishlist-toggle
- dropins/wishlist/dictionary
- dropins/wishlist/events
- dropins/wishlist/functions
- dropins/wishlist/index
- dropins/wishlist/installation
- dropins/wishlist/styles

### Dropins b2b
- dropins-b2b/company-management/events
- dropins-b2b/index
- dropins-b2b/overview

### Sdk
- sdk/components/accordion
- sdk/components/actionbutton
- sdk/components/actionbuttongroup
- sdk/components/alertbanner
- sdk/components/breadcrumbs
- sdk/components/button
- sdk/components/card
- sdk/components/cartitem
- sdk/components/cartlist
- sdk/components/checkbox
- sdk/components/colorswatch
- sdk/components/contentgrid
- sdk/components/divider
- sdk/components/field
- sdk/components/header
- sdk/components/icon
- sdk/components/illustratedmessage
- sdk/components/image
- sdk/components/imageswatch
- sdk/components/incrementer
- sdk/components/inlinealert
- sdk/components/input
- sdk/components/inputdate
- sdk/components/inputfile
- sdk/components/inputpassword
- sdk/components/modal
- sdk/components/overview
- sdk/components/pagination
- sdk/components/picker
- sdk/components/portal
- sdk/components/price
- sdk/components/pricerange
- sdk/components/productitemcard
- sdk/components/progressspinner
- sdk/components/radiobutton
- sdk/components/skeleton
- sdk/components/tag
- sdk/components/textarea
- sdk/components/textswatch
- sdk/components/togglebutton
- sdk/design/base
- sdk/design/colors
- sdk/design/grid
- sdk/design/index
- sdk/design/shapes
- sdk/design/spacing
- sdk/design/typography
- sdk/get-started/cli
- sdk/index
- sdk/reference/events
- sdk/reference/graphql
- sdk/reference/index
- sdk/reference/initializer
- sdk/reference/links
- sdk/reference/recaptcha
- sdk/reference/render
- sdk/reference/slots
- sdk/reference/VComponent
- sdk/utilities/classList
- sdk/utilities/debounce
- sdk/utilities/deepmerge
- sdk/utilities/getCookie
- sdk/utilities/getFormErrors
- sdk/utilities/getFormValues
- sdk/utilities/getPathValue
- sdk/utilities/index

### Merchants
- merchants/get-started/enrichment
- merchants/get-started/experiments
- merchants/get-started/index
- merchants/get-started/personalization
- merchants/get-started/product-recommendations
- merchants/get-started/terms-and-conditions
- merchants/multistore/content-localization
- merchants/multistore/index
- merchants/storefront-builder/commerce-blocks/index
- merchants/storefront-builder/content-commerce-blocks
- merchants/storefront-builder/create-content
- merchants/storefront-builder/document-authoring
- merchants/storefront-builder/index
- merchants/storefront-builder/visual-editor

### Videos
- videos/_customize-cart
- videos/_customize-checkout
- videos/_customize-pdp
- videos/add-product-lines-to-cart-summary
- videos/buy-online-pickup-in-store
- videos/customize-address-form-layout
- videos/customize-cart-summary
- videos/customize-order-summary-lines
- videos/index
- videos/multi-step-checkout
- videos/shopper-experience

### Playgrounds
- playgrounds/commerce-optimizer
- playgrounds/commerce-services
- playgrounds/index

### Releases
- releases/changelog
- releases/index

### Troubleshooting
- troubleshooting/faq
- troubleshooting/pagespeed-issues

### Resources
- resources/index
- resources/placeholders

### Index
- index



---

# Explore the project

The storefront project is a collection of **blocks**, drop-in components, **scripts**, and **styles** designed for amazing performance, easy customizations, and rapid content development.

## Big picture

The file structure of the storefront boilerplate is shown here. Detailed descriptions are scheduled to be added before our April release.



- blocks/ _-- Content and Commerce blocks_
  - cards/ _-- Content block_
    - cards.css _-- CSS classes_
    - cards.js _-- JavaScript decorator_
  - columns/ _-- Content block_
    - columns.css _-- CSS classes_
    - columns.js _-- JavaScript decorator_
  - commerce-account/ _-- Commerce block_
    - commerce-account.css _-- CSS classes_
    - commerce-account.js _-- JavaScript decorator_
  - commerce-account-header/ _-- Commerce block_
    - commerce-account-header.css _-- CSS classes_
    - commerce-account-header.js _-- JavaScript decorator_
  - commerce-account-sidebar/ _-- Commerce block_
    - commerce-account-sidebar.css _-- CSS classes_
    - commerce-account-sidebar.js _-- JavaScript decorator_
  - commerce-addresses/ _-- Commerce block_
    - commerce-addresses.css _-- CSS classes_
    - commerce-addresses.js _-- JavaScript decorator_
  - commerce-cart/ _-- Commerce block_
    - commerce-cart.css _-- CSS classes_
    - commerce-cart.js _-- JavaScript decorator_
  - commerce-checkout/ _-- Commerce block_
    - commerce-checkout.css _-- CSS classes_
    - commerce-checkout.js _-- JavaScript decorator_
  - commerce-confirm-account/ _-- Commerce block_
    - commerce-confirm-account.css _-- CSS classes_
    - commerce-confirm-account.js _-- JavaScript decorator_
  - commerce-create-account/ _-- Commerce block_
    - commerce-create-account.css _-- CSS classes_
    - commerce-create-account.js _-- JavaScript decorator_
  - commerce-create-password/ _-- Commerce block_
    - commerce-create-password.css _-- CSS classes_
    - commerce-create-password.js _-- JavaScript decorator_
  - commerce-create-return/ _-- Commerce block_
    - commerce-create-return.css _-- CSS classes_
    - commerce-create-return.js _-- JavaScript decorator_
  - commerce-customer-details/ _-- Commerce block_
    - commerce-customer-details.css _-- CSS classes_
    - commerce-customer-details.js _-- JavaScript decorator_
  - commerce-customer-information/ _-- Commerce block_
    - commerce-customer-information.css _-- CSS classes_
    - commerce-customer-information.js _-- JavaScript decorator_
  - commerce-forgot-password/ _-- Commerce block_
    - commerce-forgot-password.css _-- CSS classes_
    - commerce-forgot-password.js _-- JavaScript decorator_
  - commerce-gift-options/ _-- Commerce block_
    - commerce-gift-options.css _-- CSS classes_
    - commerce-gift-options.js _-- JavaScript decorator_
  - commerce-login/ _-- Commerce block_
    - commerce-login.css _-- CSS classes_
    - commerce-login.js _-- JavaScript decorator_
  - commerce-mini-cart/ _-- Commerce block_
    - commerce-mini-cart.css _-- CSS classes_
    - commerce-mini-cart.js _-- JavaScript decorator_
  - commerce-order-confirmation/ _-- Commerce block_
    - commerce-order-confirmation.css _-- CSS classes_
    - commerce-order-confirmation.js _-- JavaScript decorator_
  - commerce-order-cost-summary/ _-- Commerce block_
    - commerce-order-cost-summary.css _-- CSS classes_
    - commerce-order-cost-summary.js _-- JavaScript decorator_
  - commerce-order-header/ _-- Commerce block_
    - commerce-order-header.css _-- CSS classes_
    - commerce-order-header.js _-- JavaScript decorator_
  - commerce-order-product-list/ _-- Commerce block_
    - commerce-order-product-list.css _-- CSS classes_
    - commerce-order-product-list.js _-- JavaScript decorator_
  - commerce-order-returns/ _-- Commerce block_
    - commerce-order-returns.css _-- CSS classes_
    - commerce-order-returns.js _-- JavaScript decorator_
  - commerce-order-status/ _-- Commerce block_
    - commerce-order-status.css _-- CSS classes_
    - commerce-order-status.js _-- JavaScript decorator_
  - commerce-orders-list/ _-- Commerce block_
    - commerce-orders-list.css _-- CSS classes_
    - commerce-orders-list.js _-- JavaScript decorator_
  - commerce-return-header/ _-- Commerce block_
    - commerce-return-header.css _-- CSS classes_
    - commerce-return-header.js _-- JavaScript decorator_
  - commerce-returns-list/ _-- Commerce block_
    - commerce-returns-list.css _-- CSS classes_
    - commerce-returns-list.js _-- JavaScript decorator_
  - commerce-search-order/ _-- Commerce block_
    - commerce-search-order.css _-- CSS classes_
    - commerce-search-order.js _-- JavaScript decorator_
  - commerce-shipping-status/ _-- Commerce block_
    - commerce-shipping-status.css _-- CSS classes_
    - commerce-shipping-status.js _-- JavaScript decorator_
  - commerce-wishlist/ _-- Commerce block_
    - commerce-wishlist.css _-- CSS classes_
    - commerce-wishlist.js _-- JavaScript decorator_
  - footer/ _-- Content block_
    - footer.css _-- CSS classes_
    - footer.js _-- JavaScript decorator_
  - fragment/ _-- Content block_
    - fragment.css _-- CSS classes_
    - fragment.js _-- JavaScript decorator_
  - header/ _-- Content block_
    - header.css _-- CSS classes_
    - header.js _-- JavaScript decorator_
  - hero/ _-- Content block_
    - hero.css _-- CSS classes_
    - hero.js _-- JavaScript decorator_
  - modal/ _-- Content block_
    - modal.css _-- CSS classes_
    - modal.js _-- JavaScript decorator_
  - product-details/ _-- Commerce block_
    - product-details.css _-- CSS classes_
    - product-details.js _-- JavaScript decorator_
  - product-list-page/ _-- Commerce block_
    - product-list-page.css _-- CSS classes_
    - product-list-page.js _-- JavaScript decorator_
  - product-recommendations/ _-- Commerce block_
    - product-recommendations.css _-- CSS classes_
    - product-recommendations.js _-- JavaScript decorator_
  - targeted-block/ _-- Commerce block_
    - targeted-block.css _-- CSS classes_
    - targeted-block.js _-- JavaScript decorator_
- fonts/ _-- Default fonts_
  - roboto-bold.woff2
  - roboto-regular.woff2
- icons/ _-- SVG icons_
  - caret-down-fill.svg
  - more...
- scripts/ _-- JavaScript files that provide core site functions and connections to Commerce backend services_
  - \_\_dropins\_\_ _-- Imported drop-in components_
    - storefront-account/ _-- minified/optimized drop-in code_
    - storefront-auth/ _-- minified/optimized drop-in code_
    - storefront-cart/ _-- minified/optimized drop-in code_
    - storefront-checkout/ _-- minified/optimized drop-in code_
    - storefront-order/ _-- minified/optimized drop-in code_
    - storefront-payment-services/ _-- minified/optimized drop-in code_
    - storefront-pdp/ _-- minified/optimized drop-in code_
    - storefront-personalization/ _-- minified/optimized drop-in code_
    - storefront-product-discovery/ _-- minified/optimized drop-in code_
    - storefront-recommendations/ _-- minified/optimized drop-in code_
    - storefront-wishlist/ _-- minified/optimized drop-in code_
    - tools/ _-- Drop-in SDK tools_
  - widgets/ _-- Legacy search widgets (being phased out)_
    - search.js _-- Legacy search functionality_
    - SearchAsYouType.js _-- Live search autocomplete_
  - aem.js _-- AEM site functions_
  - commerce.js _-- Commerce Boilerplate-specific functionality including template handling and commerce utilities_
  - configs.js _-- Functions for retrieving and interacting with the site config_
  - initializers _-- Drop-in endpoints and initializers/loaders_
    - index.js _-- Global initializers applied to all pages_
    - \<drop-in\>.js _-- Drop-in specific initialization_
  - scripts.js _-- Core AEM functionality for loading blocks, fonts, and lazy-styles_
  - others...
- styles/ _-- CSS files for drop-in design tokens, fonts, deferred styles_
  - fonts.css _-- Default font styles_
  - lazy-styles.css _-- Global styles loaded post LCP_
  - styles.css _-- Global site design tokens and styles_
- tools/ _-- Commerce Picker code and Sidekick configuration file_
  - picker/ _-- Picker project code_
    - project-files... _-- Contains Catalog Services GraphQL queries for categories and products_
  - sidekick/ _-- Sidekick configuration_
    - config.json _-- Configuration settings for Commerce Picker, including Picker button title_
- default-fstab.yaml _-- Template fstab for connecting to your content source (Sharepoint, Google drive, da.live, etc)_
- default-query.yaml _-- Template query index to push to your site config_
- default-site.yaml _-- Template site config to initialize your site in the aem.live config service_
- default-sitemap.yaml _-- Template sitemap to push to your site config_
- demo-config.json _-- A starter config which can be used to get started with local development_
- head.html _-- Includes @dropin importmap, aem.js, scripts.js, and styles.css_
- helix-query.yaml _-- Defines the path and properties for your enrichment blocks_
- package.json _-- Includes aem-cli, @dropins/tools, and the currently integrated drop-in components_



## Vocabulary



### Commerce drop-in components

Full-featured shopping components that turn websites into storefronts. [Drop-in components](https://experienceleague.adobe.com/developer/commerce/storefront/setup/discovery/architecture/#drop-in-components) are not primitive components, like Carousels and Galleries. They provide the entire storefront shopping experience for a website using pages and other commerce features.

### Commerce blocks

The integration of Commerce drop-in components into the Edge Delivery Services architecture of JavaScript blocks and document-based authoring. [Commerce blocks](https://experienceleague.adobe.com/developer/commerce/storefront/setup/discovery/architecture/#commerce-blocks) are the components that provide the content and layout for commerce pages in the storefront.

### Content blocks

The Edge Delivery components that provide the content and layout for non-commerce pages in the storefront. These include Cards, Columns, Headers, Footers, and many more. Visit the Adobe Experience Manager [Block Collection](https://www.aem.live/developer/block-collection) section for the details.



## Start exploring

Run your storefront locally using the `npm start` command and explore how each **boilerplate page** has a corresponding **Commerce block**, which wraps the **drop-in** component that provides the block with its features and functions.

> **Note:** The boilerplate now includes four new drop-in components:

- [Product Discovery](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/)
- [Product Recommendations](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/recommendations/)
- [Wishlist](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/wishlist/)
- [Personalization](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/personalization/)

Additionally, legacy widgets have been replaced with drop-in components for better maintainability and consistency.

---

# Browser compatibility

This page provides information about browser and device compatibility for Adobe Commerce storefronts on Edge Delivery Services.

## Which boilerplate suite do I have?

Browser support is tied to specific boilerplate suite versions. To determine which suite you're using, check your `package.json` file for the `@dropins/tools` version:

   - **Suite 4 (October 14, 2025)**: `@dropins/tools@~1.5.0`
   - **Suite 3 (August 12, 2025)**: `@dropins/tools@1.3.0`
   - **Suite 2 (June 25, 2025)**: `@dropins/tools@0.42.0`


## Browser support by suite

### Desktop browsers



| Browser | Suite 4 (Oct 2025) | Suite 2 & 3 (Jun-Aug 2025) |
|---------|-------------------|---------------------------|
| Chrome  | 105 - 141         | 98 - 136                  |
| Edge    | 105 - 141         | 98 - 136                  |
| Safari  | 16 - 18.4         | 16 - 18.4                 |
| Firefox | 110 - 143         | 108 - 138                 |
| Opera   | 92 - 122          | 85 - 118                  |



### Mobile browsers



| Platform | Browser          | Suite 4 (Oct 2025) | Suite 2 & 3 (Jun-Aug 2025) |
|----------|------------------|-------------------|---------------------------|
| Android  | Chrome           | 141               | 136                       |
| Android  | Edge             | 141               | 136                       |
| Android  | Firefox          | 143               | 138                       |
| Android  | Samsung Internet | 28                | 26                        |
| Android  | UC Browser       | Not Supported     | Not Supported             |
| iOS 16+  | Safari           | Default supported version | Default supported version |
| iOS 16+  | Chrome           | Default supported version | Default supported version |



## Known issues

For the following browsers, the product listing page loads in a single product column and does not support responsiveness:

- Chrome: 100 - 104
- Firefox: 108 and 109
- Opera: 91 or less

## Test URL

You can test browser compatibility using the Commerce boilerplate test site: 

## Browser testing recommendations

When testing your storefront, we recommend:

- Testing on the minimum supported version of each major browser
- Testing on the latest version of each major browser
- Testing on both desktop and mobile devices
- Paying special attention to responsive behavior across different screen sizes
- Validating the product listing pages display correctly with multiple columns

---

# Create a storefront

Welcome to your Commerce Storefront journey. Our goal is to make the journey fun and informative. We start every topic with big-picture overviews and relevant vocabulary. We then walk you through the details step-by-step. And finally, we provide a sandbox for practice when possible. Let's get started.

## Big picture

The tutorial helps you quickly create a new Edge Delivery Services storefront using the [Commerce boilerplate template](https://github.com/hlxsites/aem-boilerplate-commerce). The boilerplate provides a starter storefront that uses a pre-configured Adobe Commerce environment.

After completing this tutorial, you will have a new GitHub repository with a storefront that is pre-configured with all the necessary components and services to get you started. You will also have a local development environment where you can explore the boilerplate and start customizing it to develop your own production storefront.

The following diagram shows the steps you'll take to create and configure your starter storefront:


  ![Steps to create and configure your starter storefront.](images/CreateStorefrontSteps.svg/)




1. **Create Site Repo** by generating a storefront repository from the [boilerplate template](https://github.com/hlxsites/aem-boilerplate-commerce).
1. **Link Repo to Content** using the `mountpoint` URL in the **`fstab.yaml`** in your GitHub repo. You can use [default-fstab.yaml](https://github.com/hlxsites/aem-boilerplate-commerce/blob/main/default-fstab.yaml) as a reference.
1. **Add Code Sync App** to your newly created repo. This app automatically redeploys your storefront when you push changes to the main branch. It also provides the Edge Delivery system (Helix Admin) with access to your repo so it can coordinate code changes with content changes.
1. **Link Repo to Data** using the values in the **`config.json`** in your GitHub repo.
1. **Add Content** to the Document Author environment hosted at `https://da.live/` using the [Site Creator tool](https://da.live/app/adobe-commerce/storefront-tools/tools/site-creator/site-creator).
1. **Install Sidekick** and configure it to preview, publish, and edit content on your storefront.
1. **Set up Local Environment** to enable the development of the boilerplate into your own storefront.





:::note[Import an existing EDS site]
If you have an existing Edge Delivery Service site for your Commerce project, you can skip the store creation process, and import both the code and the content into the Document Author environment using the [Site importer tool](https://da.live/docs/operations/import).
:::

## Vocabulary

Before we dive into the step-by-step guide, let's review some key Vocabulary that will help you understand the process of creating and configuring your storefront.



### Boilerplate template

The boilerplate template is a pre-configured storefront that includes all the necessary components and services to get you started. It's a great way to quickly create a new storefront with all the necessary components and services already in place.

### Code Sync app

The Code Sync app listens to changes in your code repositories (commits and merges to the `main` branch) and publishes code to the Edge Delivery code bus. It also intelligently purges CDN caches when changes have been made. This app is essential for keeping your storefront up-to-date with the latest changes.

### Content folder

The content folder is where you store all the content for your storefront. This includes images, text, and other assets that make up your site. By sharing read/write access to your content folder with Edge Delivery Services, you enable it to provide all the features of document-based authoring, such as editing, previewing, and publishing.

### Sidekick

Sidekick is an extension that makes it easy for creators to connect, edit, preview, and publish content directly from documents and spreadsheets in your content folder. It's also responsible for pushing content to the Edge Delivery content bus so it can be previewed and published.

### content mountpoint

The `content mountpoint` is a pointer to your content folder on https://da.live, Google Drive, or SharePoint. The content mountpoint can be defined either by specifying the `mountpoint` in the **`fstab.yaml`** file on the `main` branch of your remote GitHub repo.



## Example

Our CitiSignal demo site was built from the same boilerplate you will set up to develop your own storefront. You can access the full demo site here: https://main--citisignal-one--adobedevxsc.aem.live/.



## Step-by-step

The centerpiece of this **20-minute storefront** is our Commerce boilerplate template. It provides a starter storefront that is pre-configured with our Commerce components and services and pre-connected to our Commerce boilerplate backend.

### Prerequisites

Before you begin, take a moment to set up these required tools and accounts as needed.










<Task>

### Create site repo

This task requires you to have a GitHub account with access to the organization or owner where you want to create your new repo.

<Diagram caption="Create your storefront repo.">
  ![Create your storefront repo](images/create-repo.webp/)
</Diagram>

:::note[Sign into GitHub]
Make sure you are signed into your GitHub account before you start. Otherwise, you will not see the **Use this template** button.
:::

<Callouts columnCount="1">

1. Navigate to , select the **Use this template** button, then select the **Create a new repository** option to open the form.
1. Complete the form with the following details:

   - **Repository template**: `hlxsites/aem-boilerplate-commerce` (default).
   - **Include all branches**: Do not include all branches (default).
   - **Owner**: Your organization or account (required).
   - **Repository name**: A unique name for your new repo (required). Must be lowercase and can only contain letters, numbers, and hyphens (no underscores or periods).
   - **Description**: A brief description of your repo (optional).
   - **Public or Private**: We recommend public (default).

1. Select the **Create repository** button and watch GitHub create your new storefront repo.
1. After a few seconds, you should be redirected to the home page of your new repo.

</Callouts>

</Task>

<Task>

### Link repo to content

Edge Delivery Services requires site configuration details to know what to render. These include at minimum a content reference and a code reference. The simplest approach is to create those references in the `fstab.yaml` configuration file.

<Steps>

1. Rename [default-fstab.yaml](https://github.com/hlxsites/aem-boilerplate-commerce/blob/main/default-fstab.yaml) to `fstab.yaml`.
1. Replace `{org}` and `{site}` in `fstab.yaml` using the GitHub url to determine the correct values: `https://github.com/{org}/{site}`.
1. Commit and push this change to the `main` branch of your repository.

</Steps>

<Aside type="note" title="Migrate to the Storefront Configuration Service">
  After you have created your storefront, you can migrate the configuration to use the Configuration Service which supports advanced use cases like repoless configuration and overlays. For more information, see the [Configuration Service](https://www.aem.live/docs/config-service-setup) documentation.
</Aside>

</Task>

<Task>

### Add the Code Sync app

The Code Sync app redeploys your storefront site whenever you push or merge changes to the `main` branch of your repo.

<Diagram caption="Add AEM Code Sync to your repository.">
  ![Add AEM Code Sync to your repository.](images/code-sync.webp/)
</Diagram>

<Aside type="note" title="Slightly different UIs">
  A gray background on an organization or account indicates that at least one repository within it
  has the Code Sync app installed. In such cases, you are redirected to your organization's or
  account's **Code Sync configuration page**. There are no differences in the steps, but the UI
  differs slightly from the one shown in the diagram (**Install** vs **Save** buttons), which shows
  the Code Sync page for new installations.
</Aside>

<Callouts>

1. Navigate to the  and select the **Configure** button (top right) to open the repo selection page.

1. Select the **organization** or **account** for the repo you just created.

1. From the form, choose **Only select repositories**, open the **Select repositories** selector, and choose your repo from the list.

1. Select **Install** (or **Save**, see note above) to complete the Code Sync installation.

1. You should see a **success screen** if the installation completed without errors. Your repo is now connected to the Edge Delivery Services code bus.

1. (_Optional_) If you return to the , your repo's organization or account will now be gray with "Configure" added. Select your org or account again to access the **Code Sync configuration page**. This page shows when the app was added to your organization (highlighted) and allows you to connect the Code Sync app to additional repositories.

</Callouts>

</Task>

<Task>

### Link repo to commerce data

To link your storefront repo to your commerce backend, you can use the [config generator tool](https://da.live/app/adobe-commerce/storefront-tools/tools/config-generator/config-generator) to automatically generate a `config.json` file for your site based on your Commerce backendâ€”Adobe Commerce, Adobe Commerce as a Cloud Service, or Adobe Commerce Optimizer.

Update the storefront configuration for your project:

<Steps>

1. Get information about the values required for your project from the [Storefront configuration reference](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/commerce-configuration/) to get information about the values required for your project.
2. Update the `config.json` file with the values for your project.
3. Commit and push the updated file to the repo.

</Steps>

</Task>

<Task>

### Add content

Now let's create and initialize the content side of your storefront. We'll create a new folder and share it with Edge Delivery Services.
Follow these steps to create your https://da.live content folder.

<Aside type="note" title="Demo Content">
If you do not want demo content, you can create a file in https://da.live/#/{org}/{site}/ replacing `{org}` and `{site}` with your own. This reserves the org and site for you to add your own content.
</Aside>

<Callouts>
1. Open the [Site Creator tool](https://da.live/app/adobe-commerce/storefront-tools/tools/site-creator/site-creator), and select **Use existing repository**.
1. Copy the GitHub owner and site values to the input fields and click **Create site**.
1. Follow the prompts, and by the end the content will have been copied to your content folder.
1. You may have to manually preview or publish the content, depending on whether you followed the prerequisites.
</Callouts>

<Diagram caption="Initialize your storefront content">
  ![Initialize your storefront content](images/initialize-content.webp/)
</Diagram>

</Task>

<Task>

### Install and configure Sidekick

{/* <Diagram caption="Set up Sidekick.">![Set up Sidekick.](images/setup-sidekick.webp/)</Diagram> */}

<Steps>

1. Review documentation about using and installing [the AEM Sidekick](https://www.aem.live/docs/sidekick).

1. In your GitHub repository, edit the sidekick configuration file `tools/sidekick/config.json`.

   ```json
   {
     "project": "My Project",
     "editUrlLabel": "Document Authoring",
     "editUrlPattern": "https://da.live/edit#/{{org}}/{{site}}{{pathname}}"
   }
   ```

1. In the `editUrlPattern` field, replace the key values with the values for your GitHub repository.

   * Replace the `{{ORG}}` string with the organization or username for your repository.

   * Replace the `{{SITE}}` string with the repository name.

   * The `pathname` variable is populated by the system.

   +++Example of updated configuration file

   If your GitHub repository is named `aco-storefront` and your organization is `early-adopter`, the updated URL should look like this:

   ```json
   {
     "project": "My Project",
     "editUrlLabel": "Document Authoring",
     "editUrlPattern": "https://da.live/edit#/aco-storefront/early-adopter{{pathname}}"
   }
   ```

1. Save the file and commit the changes.


</Steps>

<Aside type="note" title="Detailed Sidekick information">
Visit the [Sidekick documentation](https://www.aem.live/docs/sidekick) for more information on how to use Sidekick to manage your storefront content.
</Aside>

</Task>

<Task>

### Set up local environment

<Steps>
1. Go to your GitHub repo and select the **Code** button to copy the repo's git URL for cloning (HTTPS or SSH).
1. Open a terminal on your local machine and clone your storefront repo:

    ```bash frame="none"
    git clone [HTTPS or SSH URL]
    ```

1. Navigate to the root of your local repo and install the dependencies.

   ```bash frame="none"
   npm install
   ```

1. Start the development server to view the boilerplate storefront.

   ```bash frame="none"
   npm start
   ```

   The first page of your boilerplate storefront should be visible in your browser at `http://localhost:3000`.

   

1. Open the project in your favorite code editor. You're now ready to explore the boilerplate and start customizing your storefront!

</Steps>

</Task>

<Task>

### (Optional) Secure your storefront
While your storefront is now functional, it's important to understand that **your site is not protected by default**. We recommend securing your content, repository, and site access before deploying to production or sharing with external users.



</Task>

<Aside type="tip" title="Congrats!">
  You now have a Commerce storefront project on GitHub and a local development environment to learn
  how to customize drop-in components to develop the boilerplate into a production storefront.
</Aside>

---

# Overview

Quick Start provides everything you need to begin building with Adobe Commerce Storefronts, from understanding the architecture to creating your first storefront and optimizing performance.

---

# Run Lighthouse audits

PageSpeed Insights is the most accurate way to audit your storefront's Web Vitals. It uses the same Lighthouse engine as the Chrome DevTools, but it runs the audit on a real device in a controlled environment.

<LinkCard
  noborder
  icon="rocket"
  title="PageSpeed Insights"
  description="Make sure you enter your storefront's .live production URL for accurate results. The .live production site sits on CDNs that are closest to your customers, on the edge."
  link="https://pagespeed.web.dev/"
  rightIcon="external"
  target="_blank"
  rel="noopener noreferrer"
  aria-label="Link (opens in a new tab)"
/>

Visit the Adobe Experience Manager docs topic, [Keeping it 100](https://www.aem.live/developer/keeping-it-100) ðŸ’¯, to learn more about what PageSpeed Insights measure and how to keep your storefront at 100.

## Step-by-step



1. Navigate to the PageSpeed Insights page: https://pagespeed.web.dev/.
1. Enter your `.live` storefront URL. The URLs for your preview and live sites take the following forms:

   - **Preview**: `https://main--{repo}--{owner}.hlx.page/`
   - **Live**: `https://main--{repo}--{owner}.hlx.live/`

1. Click the **Analyze** button to run the audit.
1. You should see full Web Vital reports for both mobile and desktop, with lighthouse scores at or very near 100 across Performance, Accessibility, Best Practices, and SEO. ðŸš€

---

# Update the boilerplate

Upgrade your Adobe Commerce storefront to get the latest features, security updates, and performance improvements from the Commerce Boilerplate.

## Overview

When you initially scaffold your Commerce storefront from the Commerce Boilerplate, you create a snapshot of the boilerplate at that point in time. As Adobe continues to improve the boilerplate with new features, bug fixes, and performance optimizations, your existing project won't automatically receive these updates.

> **Note:** If you created your project by forking the Commerce Boilerplate repository (rather than using the "generate from template" or site creator approach), you may have an easier upgrade path since you can leverage Git's merge capabilities to pull upstream changes.

This guide shows you how to upgrade your storefront while preserving your customizations.

## Vocabulary



### Drop-in components
NPM packages containing the core Commerce functionality such as cart, checkout, product details, and user authentication.

### Integration layer
Storefront-level files that integrate drop-ins with your site, including initialization scripts and block implementations.

### Upstream
The original Commerce Boilerplate repository from which your project was created.

### Selective updates
The process of manually choosing and merging specific changes from the upstream boilerplate into your project.

### Breaking changes
Updates that require modifications to your existing code, typically found in major version releases.

### Post-install scripts
Automated scripts that run after NPM package installation to copy updated Commerce logic to your local project.



## Understanding the upgrade landscape

Upgrading is ongoing, not a one-time task. Regular, small updates are generally safer and easier to manage than infrequent, large upgrades.

### What gets updated

Most of your storefront's critical Commerce logic is now delivered through NPM packages, making upgrades significantly easier and more reliable. Upgrades typically involve these main areas:

**Drop-in components:** NPM packages containing the core Commerce functionality, including the following:

- `@dropins/storefront-account`
- `@dropins/storefront-auth`
- `@dropins/storefront-cart`
- `@dropins/storefront-checkout`
- `@dropins/storefront-order`
- `@dropins/storefront-payment-services`
- `@dropins/storefront-pdp`
- `@dropins/storefront-personalization`
- `@dropins/storefront-product-discovery`
- `@dropins/storefront-recommendations`
- `@dropins/storefront-wishlist`
- `@dropins/tools`

{/* TODO: Update this topic by including B2B drop-ins when they are released in Jan 2026. See issue #701 for more details. */}

**Boilerplate Integration Layer:** storefront-level files that integrate drop-ins



| File | Purpose | Update Frequency | Typical Changes |
|------|---------|------------------|-----------------|
| `blocks/*` | Block integration folders | Frequent | Drop-in integration JS and CSS. Rare updates to non-drop-in block examples (cards, accordion, etc) sourced from other boilerplates |
| `scripts/aem.js` | Core AEM functionality | Very Rare | Core platform improvements |
| `scripts/commerce.js` | Commerce-specific integration and utilities | Rare | Integration improvements, new utility functions |
| `scripts/initializers/*` | Drop-in initialization scripts | Moderate | New drop-in integrations, configuration updates |
| `scripts/scripts.js` | Page loading, block decoration, and global site functionality | Very Rare | Performance optimizations, new global features |



### Why upgrades are now easier

The Commerce Boilerplate team moved most of the complex Commerce logic into NPM-distributed drop-in packages, providing key advantages:

- **Most logic is packaged**: Core Commerce functionality, business rules, and complex state management are delivered through NPM packages
- **Simplified storefront code**: Your project primarily contains integration code, styling, and configuration
- **Standard NPM upgrades**: Most updates can be applied using standard `npm install` commands
- **Reduced conflicts**: Fewer files in your project means fewer merge conflicts when updating
- **Consistent behavior**: All storefronts benefit from the same tested, optimized Commerce logic

## Upgrade strategies


<Option>

### NPM package updates

<Aside type="tip" title="Recommended for most cases">
Most Commerce logic lives in NPM packages, so this approach handles upgrades with minimal risk.
</Aside>

#### Step 1: Update drop-in components

Most of your Commerce functionality improvements come through these package updates:

Check your current versions:

```bash
npm list @dropins/storefront-*
```

Update individual components:

```bash
npm install @dropins/storefront-cart@latest
npm install @dropins/storefront-checkout@latest
# Repeat for other components as needed
```

Or update all drop-in components at once:

```bash
npm update @dropins/storefront-*
```

<Aside type="note">
The boilerplate's postinstall and postupdate scripts automatically copy updated Commerce logic from `node_modules` to `scripts/__dropins__` for Edge Delivery Services.
</Aside>

#### Step 2: Test your storefront

Since most logic changes are packaged, testing focuses on integration points:

Start your local development environment:

```bash
npm start
```

Test all Commerce functionality:

- Product detail pages
- Shopping cart operations
- Checkout flow
- User account features
- Search and navigation

Review the release notes for any integration changes that may affect your implementation.

<Aside type="caution" title="For Major Version Updates">
When upgrading drop-in packages across major versions (for example, from 1.x to 2.x), perform more thorough testing as these updates may include breaking changes. Pay particular attention to:

- Any custom integrations you've built around the drop-in components
- API interfaces you're using
- Configuration settings that may have changed
- Custom styling or event handlers you've added

Test edge cases and error scenarios in addition to the standard user flows.
</Aside>

To help automate this testing process, consider implementing end-to-end testing in your project using tools like Cypress. These tools can simulate real user interactions across your Commerce flows, automatically catching regressions that manual testing might miss. Focus your automated tests on critical user journeys like product browsing, cart management, and checkout completion.

<Aside type="note">
Most Commerce logic updates require no additional code changes to your storefront because the 
complex functionality is delivered through the NPM packages.
</Aside>

</Option>

<Option>

### Selective boilerplate updates

When you need integration layer improvements or new features that require changes to your storefront's integration code, selectively merge changes from the upstream boilerplate repository.

<Steps>

1. **Set up upstream remote**

   Add the boilerplate repository as an upstream remote:

   ```bash
   git remote add upstream https://github.com/hlxsites/aem-boilerplate-commerce.git
   git fetch upstream
   ```

2. **Review available updates**

   Compare your current branch with the latest boilerplate to understand what changes are available.

   For detailed instructions on reviewing upstream changes, see  and .

   Focus your review on key files like `scripts/commerce.js` and the `scripts/initializers/` directory where most Commerce-specific updates occur.

3. **Identify changes to include**

   Focus on these integration layer improvements:

   **Commerce Integration Layer (`scripts/commerce.js`)**
   - Enhanced drop-in initialization patterns
   - New configuration utilities
   - Performance optimizations
   - Bug fixes in integration logic

   **Initializers (`scripts/initializers/`)**
   - Updated drop-in initialization patterns
   - New feature integrations
   - Improved error handling

   **Block Integration Updates (`blocks/` directory)**
   - Enhanced drop-in integration patterns
   - Accessibility improvements
   - Bug fixes in block-level integration

   <Aside type="tip">
   Each Commerce block now includes a README file that describes the block's purpose and functionality. These README files are particularly helpful when diffing changes, as they provide a summary of what has changed in the block before you examine the code.
   </Aside>

   <Aside type="note">
   Since most complex Commerce logic is now in NPM packages, boilerplate updates typically involve integration layer improvements rather than core functionality changes.
   </Aside>

4. **Apply selected changes**

   Create a branch for your upgrade work to isolate changes and test before merging to main. Use a descriptive name indicating the upgrade with a timeframe or version (e.g., `upgrade-august-2025` or `upgrade-cart-v2.1.0`).

   Once you're on your upgrade branch, you have several options for applying changes from the upstream boilerplate:

   - **Selectively merge** individual files or directories that have updates you want to incorporate. This approach works well when you want to adopt specific improvements without bringing in changes that might conflict with your customizations.
   - **Cherry-pick** specific commits from the upstream repository if you want to apply only particular features or fixes. This gives you granular control over what changes to include and helps avoid introducing unwanted modifications.

   For each change you apply, commit it with a clear message describing what upstream improvement you're incorporating. This creates a clean history that makes it easy to understand what was updated and why, which will be valuable for future upgrades and troubleshooting.

5. **Resolve integration points and test**

   - Resolve any conflicts in integration code, preserving your customizations
   - Test thoroughly in your development environment
   - Run your test suite if available
   - Deploy to a staging environment for comprehensive testing

</Steps>

</Option>


## Special considerations for early-adopter projects

> **Note:** If you scaffolded your project before mid-2025, you may have encountered a major architectural change: Commerce logic moved from `scripts.js` to `scripts/commerce.js`. This shift affects your update scope but uses the same methods above.

### Understanding the architectural change

The major refactoring (PR #567) reorganized the boilerplate architecture with two significant improvements:

**1. Separation of AEM and Commerce logic:**

- `scripts/scripts.js` - Core AEM functionality, aligned with the upstream AEM Boilerplate
- `scripts/commerce.js` - Commerce-specific integration and utility logic

**2. Core Commerce logic migration to NPM packages:**

- Complex Commerce functionality moved to `@dropins/tools` and other drop-in packages
- Functions previously embedded in your integration code are now abstracted to reusable, versioned, and upgradable libraries
- The Commerce Boilerplate is now focused on pure integration code that you own

**Before the refactoring:** In early versions of the Commerce Boilerplate, all logic lived in `scripts/scripts.js` where Commerce business logic was mixed with integration code. Core Commerce functions were embedded directly in your project files, making it difficult to upgrade Commerce functionality without encountering code conflicts during merges.

**After the refactoring:** The architecture now separates concerns more effectively. Core Commerce logic lives in NPM packages that are easily upgradable, while the boilerplate contains minimal integration code that results in fewer merge conflicts. This creates clear boundaries between platform logic and your customizations, allowing future updates to focus on integration patterns rather than business logic.

This architectural shift means that complex Commerce operations, utility functions, and business rules that you may have seen in your early boilerplate files are now delivered through NPM packages, making them upgradable without touching your project code.

### Adapting your update approach

If you have an early-adopter project, your updates will need a broader scope to account for architectural changes.

When reviewing updates, pay attention to the main scripts file (`scripts/scripts.js`) and 
the Commerce integration layer (`scripts/commerce.js`). Both have changed significantly. Be sure to preserve your custom business logic while adopting the improved structural foundation 
that the upstream changes provide.

The migration process requires more careful consideration than typical updates since you're not just incorporating new features, but potentially restructuring how your existing customizations integrate with the boilerplate's core functionality.

During Step 4 (apply selective changes), you may need to migrate your customizations:

**Custom functions in the "old" `scripts/scripts.js`**

- Commerce-related customizations should move to `scripts/commerce.js`
- General AEM functionality should remain in `scripts/scripts.js`
- Many custom functions may now be available as utilities in `@dropins/tools`

**Block import updates**

- Update imports from `../../scripts/scripts.js` to `../../scripts/commerce.js` for Commerce utilities
- Verify that custom utilities are still available or replace with package utilities

**Integration pattern updates**

- Review if custom functions can be replaced with utilities from `@dropins/tools` package
- Update integrations to use new patterns for Commerce-specific functionality

During Step 5 (testing), pay special attention to:

- Custom blocks that import Commerce utilities
- Third-party integrations that depend on Commerce functions
- Custom analytics implementations that hook into Commerce events
- Any custom business logic that was mixed with platform code

### Benefits of architectural alignment

While early-adopter projects require more comprehensive selective updates, aligning with the new architecture provides significant long-term benefits:

- **Future updates simplified**: Once aligned, future updates will be much easier due to reduced code surface area
- **Better separation of concerns**: Clear boundaries between platform logic and your customizations
- **Reduced merge conflicts**: Commerce functionality updates through NPM packages instead of file merges
- **Access to latest features**: Full compatibility with new drop-in components and features
- **Enhanced PDP flexibility**: Container-based PDP architecture provides unprecedented customization control

## Product details page architectural evolution

> **Note:** If your project was scaffolded from early versions of the Commerce Boilerplate before November 27, 2024, the PDP drop-in itself underwent a major evolution from a single-container approach to a fully composable, multi-container architecture. Projects with the slot-based architecture should consider migrating to the container-based approach for better long-term maintainability.

### Previous architecture (slot-based customization)

Early versions of `@dropins/storefront-pdp` used a single `ProductDetails` container with predefined slots. You could customize by:

- Creating custom slot implementations for different sections of the page
- Working within the constraints of the single-container structure
- Limited ability to rearrange or completely replace sections of the PDP
- Complex styling workarounds to achieve desired layouts

### New architecture (container-based composition)

The latest version breaks down the PDP into independent containers you can compose, style, and replace:

- **ProductHeader** - Product title, SKU, and basic information
- **ProductPrice** - Pricing display and special price handling
- **ProductGallery** - Image carousel with flexible configuration
- **ProductOptions** - Product variants and configuration
- **ProductQuantity** - Quantity selector
- **ProductDescription** - Product descriptions and content
- **ProductAttributes** - Product specifications and metadata

For detailed information about the container-based architecture and implementation patterns, see the [Product Details Drop-in Documentation](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/). You can also reference the current product-details block implementation in the Commerce Boilerplate for practical examples of the container-based approach.

### Migration benefits for PDP blocks

- **Complete layout control**: Arrange containers in any order within your block structure
- **Individual container replacement**: Replace entire sections (like gallery or pricing) with custom implementations
- **Simplified styling**: Style containers independently without complex CSS overrides
- **Enhanced functionality**: Each container can be configured independently with specific features
- **Eliminated slot workarounds**: UI customizations that required appending, prepending, or replacing slot content can now be handled directly in the layout structure or by completely replacing containers
- **Direct data access**: Product data previously available through slot context is now accessible via the event bus (`pdp/data` and `pdp/values`)
- **Future-proof architecture**: New PDP features delivered as new containers rather than slot modifications

### PDP block migration process

When updating your PDP block from slot-based to container-based:

**1. Update dependencies**

```javascript
// Old: Single container with slots

// New: Multiple independent containers  
// ... other containers
```

**2. Replace slot implementations**

You can often remove custom slot implementations entirelyâ€”the new containers provide better configuration.

**3. Update block structure**

Replace the single container render with multiple container renders:

```javascript
// Old: Single render with slot configuration
await productRenderer.render(ProductDetails, {
  slots: {
    Title: (ctx) => Title(ctx, block),
    Options: (ctx) => Options(ctx, block),
    // ... other slots
  }
})(block);

// New: Multiple container renders
await pdpRendered.render(ProductHeader, {})($header);
await pdpRendered.render(ProductPrice, {})($price);  
await pdpRendered.render(ProductGallery, { controls: 'thumbnailsColumn' })($gallery);
// ... other containers
```

**4. Layout restructuring**

Create HTML structure that positions containers where you need them:

```javascript

  <div class="product-details__header">
  
  
  <!-- Full control over container placement -->
</div>
```

**5. Styling migration**

- Remove complex CSS overrides targeting internal slot structures
- Style containers directly with cleaner, more maintainable CSS
- Review any potential class name changes between architectures
- Handle breakpoints and responsive layout at the block level, as this is now the block's responsibility

## Tracking updates

### Monitor boilerplate changes

Stay informed about boilerplate updates:

- **GitHub watch**: Watch the  for releases and important changes
- **Changelog tracking**: Follow issues tagged with the changelog label
- **Release notes**: Review drop-in component release notes at the [Release Information](https://experienceleague.adobe.com/developer/commerce/storefront/releases/) page

### Version management best practices

**Document your customizations**

- Document all customizations
- Write clear commit messages
- Tag storefront releases

**Establish update cadence**

- Review updates monthly or quarterly
- Schedule major upgrades for low-traffic periods
- Test in staging

## Troubleshooting common issues

### Post-install script failures

If post-install fails:

- Check Node.js and NPM version compatibility
- Clear NPM cache: `npm cache clean --force`
- Remove and reinstall: `rm -rf node_modules package-lock.json && npm install`
- Check file permissions

### Merge conflicts

When merging updates:

- **Understand the context**: Review both versions
- **Preserve functionality**: Keep your customizations working
- **Test thoroughly**: Conflicts signal significant changes
- **Be selective**: Only merge valuable updates; avoid bringing in features you won't use

### Breaking changes

When drop-in updates introduce breaking changes:

- **Review migration guides**: Check package release notes for migration instructions
- **Update integrations**: Modify custom code that depends on changed APIs
- **Test edge cases**: Breaking changes often affect less common use cases
- **Plan rollback**: Have a rollback plan ready before applying breaking changes

## Best practices

### Development workflow

**Branch strategy**

- Create upgrade branches with descriptive names (e.g., `upgrade-cart-v2.1.0`)
- Merge upgrades through pull requests with thorough reviews

**Testing approach**

- Cover custom functionality with tests
- Automate testing where possible
- Test across devices and browsers
- Use real product data

**Deployment process**

- Use staging environments that mirror production
- Deploy during low-traffic periods
- Monitor key metrics post-deployment
- Have rollback procedures ready

### Long-term maintenance

**Stay current**

- Update regularly, don't let them pile up
- Apply security patches promptly
- Plan major upgrades ahead well in advance

**Customize thoughtfully**

- Minimize modifications to core boilerplate files
- Use configuration and theming approaches when possible
- Document the business justification for customizations

## Resources

- [Storefront Developer Tutorial](https://experienceleague.adobe.com/developer/commerce/storefront/get-started/create-storefront/): Comprehensive storefront setup guide
- [Architecture Guide](https://experienceleague.adobe.com/developer/commerce/storefront/setup/discovery/architecture/): Understanding the technical foundation
- [Drop-in Components Documentation](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/introduction/): Detailed component guides
- : Core platform documentation
- : Source code and latest updates
- [Release Notes](https://experienceleague.adobe.com/developer/commerce/storefront/releases/): Track major changes and updates
- : GitHub releases and version history

---

# Adobe Experience Platform

## Overview

Adobe Experience Platform (AEP) is a comprehensive suite of services that enables you to collect, unify, and analyze customer data from multiple touchpoints. By integrating your Adobe Commerce storefront with AEP, you can gain deeper insights into customer behavior and create more personalized experiences.


  ![Adobe Experience Platform architecture.](https://experienceleague.adobe.com/developer/commerce/storefront/aep-architecture-1024.png/)


This integration allows your storefront to send commerce events (product views, purchases, cart actions) directly to the Experience Platform Edge Network, where they can be processed, stored, and used for real-time personalization and analytics.

For more information about Adobe Experience Platform capabilities, see the .

## Prerequisites

Before configuring your integration with Adobe Experience Platform, ensure you have the following:

### Required Identifiers

* **IMS Organization ID**: Your Adobe organization identifier (format: `1234567890ABCDEF7F000101@AdobeOrg`)
* **Datastream ID**: A configured datastream for routing data (format: `12345678-1234-1234-1234-123456789012`)

### How to Find Your Identifiers

**IMS Organization ID:**
To locate your IMS Organization ID, refer to the . You can typically find this in:

- Adobe Admin Console
- Developer Console
- Any Adobe Experience Cloud application under Account Settings

**Datastream ID:**
Your datastream must be configured to route data to Adobe Experience Platform. For detailed instructions on creating and configuring a datastream, see the .

## Configuration

To enable data flow from your storefront to the Experience Platform Edge Network, you need to configure the Adobe Data Layer with your AEP credentials.



<Task>
### Locate your delayed script file

Typically `scripts/delayed.js` in your project
</Task>

<Task>
### Add the AEP configuration to your Adobe Data Layer initialization

```js
window.adobeDataLayer.push(
  {
    aepContext: {
      imsOrgId: '1234567890ABCDEF7F000101@AdobeOrg',
      datastreamId: '12345678-1234-1234-1234-123456789012'
    }
  },
  {
    eventForwardingContext: {
      aep: true
    }
  }
);
```

</Task>


### Configuration Parameters

| Parameter | Description | Required |
|-----------|-------------|----------|
| `aepContext.imsOrgId` | Your Adobe IMS Organization ID | Yes |
| `aepContext.datastreamId` | Your configured datastream ID for routing data to AEP | Yes |
| `eventForwardingContext.aep` | Enables forwarding events to Adobe Experience Platform | Yes |

### What This Configuration Does

- **`aepContext`**: Provides the necessary identifiers for routing data to your specific Adobe Experience Platform environment
- **`eventForwardingContext.aep: true`**: Instructs the Adobe Data Layer to forward commerce events to the Experience Platform Edge Network

## Storefront events

Once configured, your storefront will automatically send the following types of events to Adobe Experience Platform:

- **Shopping events**: Cart updates and views (`addToCart`, `removeFromCart`, `shoppingCartView`), page views (`pageView`, `productPageView`), checkout (`startCheckout`, `completeCheckout`) and more.
- **Customer profile events**: Customer login (`signIn`), customer logout (`signOut`), create account (`createAccount`), edit account (`editAccount`).
- **Search events**: Search query (`searchRequestSent`) and search results (`searchResponseReceived`).

> **Note:** If `LiveSearch` is not installed and configured, these search events are not sent.

For a complete list of storefront events, see the .

> **Note:** To debug events in your storefront, you can use the AEP Debugger Events view. For instructions on how to use the .

These events are processed in real-time and can be used for:
- Customer journey analysis
- Real-time personalization
- Audience segmentation
- Attribution modeling

## Validation

You can see an example of this .

### Testing Your Integration



<Task>
### Check browser console

After implementing the configuration, open your browser's developer tools and verify that:

- No JavaScript errors appear
- Adobe Data Layer events are being fired
- Network requests to Adobe Experience Platform Edge Network are successful
</Task>

<Task>
### Monitor data ingestion

Use Adobe Experience Platform's monitoring tools to confirm data is being received:

- Navigate to your AEP workspace
- Check the **Monitoring** section for incoming data
- Verify events appear in your configured datasets
</Task>



### Validate event structure

Ensure events contain the expected commerce data fields and customer identifiers

### Troubleshooting

If data is not flowing as expected:

- **Verify credentials**: Double-check your IMS Organization ID and Datastream ID
- **Check datastream configuration**: Ensure your datastream is properly configured to route to Adobe Experience Platform
- **Review browser network tab**: Look for failed requests to Adobe Experience Platform endpoints
- **Validate Adobe Data Layer**: Confirm the Adobe Data Layer is properly initialized before your AEP configuration

For detailed validation procedures, refer to the .

## Next Steps

After successful integration:


1. **Configure schemas**: Set up XDM schemas in Adobe Experience Platform to structure your commerce data  
1. **Create audiences**: Build customer segments based on commerce behavior
1. **Set up Real-Time CDP**: Use collected data for personalization and marketing activation
1. **Monitor performance**: Regularly review data quality and ingestion metrics


For a complete implementation example, see the  and .

---

# Analytics instrumentation

## Overview

Instrumentation is the process of adding code to your storefront to collect data about user interactions and behaviors. This data powers critical Adobe Commerce features and provides valuable insights into your customers' shopping journey.

### Why Instrumentation Matters

User interaction events collected through instrumentation enable:

- **Adobe Sensei features**: Intelligent merchandising and search result optimization in Live Search
- **Product recommendations**: Personalized product suggestions based on user behavior
- **Performance analytics**: Detailed dashboards showing search performance, conversion rates, and user engagement
- **Business intelligence**: Data-driven insights for inventory management and marketing strategies

> **Note:** Live Search and Product Recommendations events are not sent to AEP. For these features to function correctly, you must collect and send user interaction events to Adobe Commerce. Without proper instrumentation, these features will not work as expected.

## Adobe Client Data Layer (ACDL)

The [Adobe Client Data Layer (ACDL)](https://github.com/adobe/adobe-client-data-layer) is a standardized JavaScript framework that simplifies data collection on your storefront. It provides a unified approach to capturing, storing, and transmitting user interaction data.

### Key Capabilities

The ACDL enables your storefront to:

- **Collect interaction data**: Track user behaviors like product views, searches, cart actions, and purchases
- **Standardize data format**: Ensure consistent data structure across all events
- **Manage event timing**: Control when and how data is sent to analytics services
- **Support multiple integrations**: Work seamlessly with Adobe Experience Platform, Analytics, and other tools

### Core API Functions

| Function | Description | Use Case |
|----------|-------------|----------|
| `push()` | Add data or trigger events | Send product view, cart addition events |
| `getState()` | Retrieve current data layer state | Access user session or cart information |
| `addEventListener()` | Register event listeners | React to specific user actions |
| `getHistory()` | View event history | Debug or audit data collection |

> **Note:** The Adobe Commerce boilerplate includes ACDL by default, so you don't need to install it separately. Drop-in components automatically send events to the data layer.

## Configuration

### Store Configuration

To enable proper event collection, you need to configure your store's analytics settings. This configuration tells the instrumentation system about your store's identity and structure. The specific values depend on your Commerce environment type.

Refer to the  for complete details on how to configure your store.

### Required Configuration Parameters

The analytics configuration structure varies based on your Commerce backend type:



<TabItem label="Adobe Commerce (PaaS) / ACCS">

For Adobe Commerce PaaS and Adobe Commerce as a Cloud Service environments, use standard Commerce store and website identifiers from your Commerce Environment. You can obtain these values using a `storeConfig` query.



**Configuration Properties:**

| Parameter | Description | Example | Required |
|-----------|-------------|---------|----------|
| `base-currency-code` | The base currency code for the store | `"USD"`, `"EUR"` | Yes |
| `environment` | Environment type | `"Testing"`, `"Production"` | Yes |
| `environment-id` | Unique identifier for the Commerce environment | `"f38a0de0-764b-41fa-bd2c-5bc2f3c7b39a"` | Yes |
| `store-code` | Code identifier for the store from your Commerce environment | `"main_website_store"` | Yes |
| `store-id` | Numeric ID for the store | `1`, `2` | Yes |
| `store-name` | Display name for the store | `"Main Website Store"` | Yes |
| `store-url` | Base URL for the store | `"https://example.com"` | Yes |
| `store-view-code` | Code identifier for the store view | `"default"` | Yes |
| `store-view-id` | Numeric ID for the store view | `1`, `2` | Yes |
| `store-view-name` | Display name for the store view | `"Default Store View"` | Yes |
| `website-code` | Code identifier for the website from your Commerce environment | `"base"` | Yes |
| `website-id` | Numeric ID for the website | `1`, `2` | Yes |
| `website-name` | Display name for the website | `"Main Website"` | Yes |

</TabItem>

<TabItem label="Adobe Commerce Optimizer (ACO)">

For Adobe Commerce Optimizer environments, use a simplified analytics configuration structure:



**Configuration Properties:**

| Parameter | Description | Example | Required |
|-----------|-------------|---------|----------|
| `base-currency-code` | The base currency code for the store | `"USD"`, `"EUR"` | Yes |
| `environment` | Environment type | `"Testing"`, `"Production"` | Yes |
| `environment-id` | The tenant ID for the Adobe Commerce Optimizer instance | `"8idEEDDiVwjCEJAyB5kjfi"` | Yes |
| `locale` | Catalog source locale (language or geography) | `"en-US"` | Yes |
| `store-url` | Base URL for the store | `"https://example.com"` | Yes |
| `store-view-currency-code` | Currency code for the store view | `"USD"`, `"EUR"` | Yes |
| `storefront-template` | Storefront template type | `"Other"` | No |
| `view-id` | The unique ID assigned to the catalog view | `"0d3eebf7-b5fb-4904-9ccf-f35fcc61862b"` | Yes |

</TabItem>



> **Note:** The `environment` parameter is used to determine the type of environment your store is running in. This is important because it affects how data is collected and processed. Be sure to set this to `"Testing"` when you are developing your storefront, and `"Production"` when you are ready to deploy your storefront.

### Data Services Configuration

For the instrumentation to work with Adobe Commerce's data services, you'll need additional configuration parameters. The easiest way to obtain these is through the `magento/module-data-services-graphql` module, which exposes the necessary GraphQL endpoints.

#### Required for Data Services

- **Catalog Service credentials**: For product data synchronization
- **SaaS environment ID**: Links your storefront to Adobe Commerce SaaS services
- **API keys**: Authenticate with Adobe Commerce backend services

## Event Collection and Validation

### Automatic Event Collection

The Commerce boilerplate includes the [Storefront Events Collector](https://github.com/adobe/commerce-events/tree/main/packages/storefront-events-collector), which automatically:


1. **Listens for ACDL events**: Monitors the data layer for new events
1. **Validates event structure**: Ensures events conform to required schemas
1. **Batches and sends data**: Efficiently transmits events to Adobe Commerce
1. **Handles errors**: Manages network issues and retry logic


### Event Types Collected

Your instrumentation will automatically track:

- **Shopping events**: Cart updates and views (`addToCart`, `removeFromCart`, `shoppingCartView`), page views (`pageView`, `productPageView`), checkout (`startCheckout`, `completeCheckout`) and more.
- **Customer profile events**: Customer login (`signIn`), customer logout (`signOut`), create account (`createAccount`), edit account (`editAccount`).
- **Search events**: Search query (`searchRequestSent`) and search results (`searchResponseReceived`).

> **Note:** If `LiveSearch` is not installed and configured, these search events are not sent.

> **Note:** To debug events in your storefront, you can use the AEP Debugger Events view. For instructions on how to use the .

### Event Schema Compliance

All events must comply with the schema defined by the [Storefront Event SDK](https://github.com/adobe/commerce-events/tree/main/packages/storefront-events-sdk). This ensures compatibility with Adobe Commerce services and analytics tools.

## Validation and Testing

The following sections describe how to validate and test your event implementation.

### Automated Validation

You can validate your event implementation using the [ACDL Event Validator](https://github.com/adobe/adobe-client-data-layer/pull/156). This tool checks:

- **Event structure**: Verifies required fields are present
- **Data types**: Ensures values match expected formats
- **Schema compliance**: Confirms events follow Storefront Event SDK specifications

> **Note:** For optimal performance, Adobe recommends writing events directly to ACDL rather than using the Storefront Events SDK wrapper. Drop-in components handle this automatically, but custom implementations should follow this practice.

### Manual Testing Steps


1. **Open browser developer tools** and navigate to the Console tab
1. **Check for ACDL**: Verify `window.adobeDataLayer` exists and contains events
1. **Monitor network requests**: Look for successful data transmission to Adobe services
1. **Validate event data**: Inspect event payloads for completeness and accuracy
1. **Confirm that event data is collected**: To confirm that data is being collected from your Commerce store, use the Adobe Experience Platform debugger to examine your Commerce site.


> **Note:** The AEP Debugger provides an Events view that you can use to examine the events being sent from your Commerce site. For instructions on how to use the .

### Common Validation Issues

- **Missing configuration**: Ensure all required analytics parameters are set
- **Incorrect store IDs**: Verify store and website IDs match your Adobe Commerce setup
- **Network connectivity**: Check that your storefront can reach Adobe Commerce endpoints
- **Event timing**: Confirm events fire at the correct moments in the user journey

## Troubleshooting Configuration Issues

**Problem**: Events not being sent
**Solution**:

1. Verify your `config.json` contains all required analytics parameters
1. Check that store IDs match your Adobe Commerce backend configuration
1. Ensure the Storefront Events Collector is loading properly


**Problem**: Invalid event data
**Solution**:

1. Use the ACDL validator to check event structure
1. Verify custom events follow the Storefront Event SDK schema
1. Check for JavaScript errors that might corrupt event data


## Troubleshooting Integration Issues

**Problem**: Live Search not receiving data
**Solution**:

1. Confirm your SaaS environment ID is correctly configured
1. Verify API credentials are valid and have necessary permissions
1. Check that product catalog is properly synchronized


For additional troubleshooting, refer to the [Live Search Data Collection documentation](https://experienceleague.adobe.com/en/docs/commerce/product-recommendations/admin/workspace#data-collection).

## Best Practices

### Implementation Guidelines

- **Test thoroughly**: Validate events in development before deploying to production
- **Monitor regularly**: Set up alerts for data collection failures
- **Follow schemas**: Always comply with Storefront Event SDK specifications
- **Optimize performance**: Batch events when possible to reduce network overhead

### Data Quality

- **Validate user inputs**: Sanitize data before adding to events
- **Handle edge cases**: Account for scenarios like network failures or missing data
- **Maintain consistency**: Use standardized naming and formatting across all events
- **Respect privacy**: Ensure compliance with data protection regulations

---

# AEM Assets integration

The AEM Assets integration allows your storefront to display product images that are managed in AEM Assets instead of traditional Commerce-hosted images. This integration provides enhanced image management capabilities, including advanced optimization, cropping, and delivery through Adobe's Content Delivery Network (CDN).

## Boilerplate update required

Only one update is required: set `"commerce-assets-enabled": true` in your [Storefront configuration](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/commerce-configuration/).

```json title="config.json" ins={'+':4}
{
  "public": {
    "default": {
      "commerce-assets-enabled": true
    }
  }
}
```

The Commerce drop-ins automatically detect the `commerce-assets-enabled` configuration and adjust image handling accordingly. See the [demo configratuion](https://www.aemshop.net/config.json). 

## Expected behaviors

The following table describes what happens in different configuration scenarios. The **Image source** refers to where you store your images: either "Commerce" for traditional Commerce-hosted images or "AEM Assets" for images managed in AEM Assets. For background, see the [AEM Assets Integration documentation](https://experienceleague.adobe.com/en/docs/commerce/aem-assets-integration/overview). The **`commerce-assets-enabled setting`** column indicates whether this configuration is set to `true` or `false`.



## How it works in the boilerplate

The Commerce drop-ins automatically detect the `commerce-assets-enabled` configuration and adjust image handling accordingly. Here's how the boilerplate integrates this configuration:


<Tasks>

<Task>

### Import the AEM Assets utility

The Commerce blocks in the boilerplate import the `tryRenderAemAssetsImage` helper from the drop-ins tools package.

```javascript showLineNumbers=false 
```

</Task>

<Task>

### Render images via drop-in slots

The Commerce blocks use the `tryRenderAemAssetsImage` function inside its drop-in image slots, as shown below.

```javascript showLineNumbers=false {"Container:":4-5} {"Container Image Slot:":6-8} {"AEM Assets integration:":10-17}

export default async function decorate(block) {
  
  await dropinRenderer.render(DropinComponent, {

    slots: {
      DropinImageSlot: (ctx) => {
        const { data, defaultImageProps } = ctx;

        tryRenderAemAssetsImage(ctx, {
          imageProps: defaultImageProps,
          params: {
            width: defaultImageProps.width,
            height: defaultImageProps.height,
          },
        });
      },
    },
  })(block);
}
```
</Task>

</Tasks>


## Real-world examples from the boilerplate

Based on the  Commerce blocks in the boilerplate, AEM Assets integration uses the `tryRenderAemAssetsImage` function from `@dropins/tools/lib/aem/assets.js` as follows.

### Product List SearchResults container

```javascript showLineNumbers=false {"Container:":2-3} {"Container Image Slot:":4-6} {"AEM Assets integration:":11-20}

provider.render(SearchResults, {

  slots: {
    ProductImage: (ctx) => {
      const { product, defaultImageProps } = ctx;
      const anchorWrapper = document.createElement('a');
      anchorWrapper.href = rootLink(`/products/${product.urlKey}/${product.sku}`);


      tryRenderAemAssetsImage(ctx, {
        alias: product.sku,
        imageProps: defaultImageProps,
        wrapper: anchorWrapper,
        params: {
          width: defaultImageProps.width,
          height: defaultImageProps.height,
        },
      });
    },
  },
});
```

### Checkout OrderProductList container

```javascript showLineNumbers=false  {"Container:":2-3} {"Container Image Slot:":4-6} {"AEM Assets integration:":8-16}

OrderProvider.render(OrderProductList, {

  slots: {
    CartSummaryItemImage: (ctx) => {
      const { data, defaultImageProps } = ctx;

      tryRenderAemAssetsImage(ctx, {
        alias: data.product.sku,
        imageProps: defaultImageProps,
        params: {
          width: defaultImageProps.width,
          height: defaultImageProps.height,
        },
      });
    },
    ...
  },
})($orderProductList);
```

## Using drop-ins outside the boilerplate (optional)

If you use the boilerplate, AEM Assets works out of the box. Without the boilerplate, you need to implement the minimal config and slot usage below. See the [Commerce drop-ins overview](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/introduction/) for how slots and initializers work.

To enable AEM Assets with standalone drop-ins, you'll need to implement the configuration system that drop-ins expect. See [Storefront configuration](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/commerce-configuration/) for full configuration details.

### Minimal configuration

Set `commerce-assets-enabled: true` in a `public.default` config (JSON or config service). Align endpoints/headers to your environment as needed.

> **Note:** See the [Commerce Boilerplate](https://github.com/hlxsites/aem-boilerplate-commerce) for complete examples.

### Minimal integration steps

1. Install `@dropins/tools`.
1. Add the `assets.js` file from the boilerplate to your project.
1. Import `tryRenderAemAssetsImage` into your drop-in components.
1. In each image slot, call `tryRenderAemAssetsImage(ctx, { alias: <sku>, imageProps, params: { width, height } })`. Fallback to Commerce-hosted images is automatic from functions in `assets.js`â€”no extra code is required.
1. Use the product SKU (or your configured alias) for `alias` so the correct asset is matched in AEM.
1. When linking images, pass a `wrapper` element (for example, an anchor) in the options.
1. Set the `width`/`height` params to the slotâ€™s intended render size (e.g., from `defaultImageProps`).
1. For more details, see [Commerce drop-ins overview](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/introduction/).

**Minimal implementation results**: Uses AEM Assets when available; falls back to Commerce; applies correct CDN params automatically.

> **Note:** Outside the boilerplate, use these helpers from `@dropins/tools/lib/aem/assets.js` to detect enablement, generate optimized URLs, and render slots:
  - `isAemAssetsEnabled()`
  - `getDefaultAemAssetsOptimizationParams()`
  - `isAemAssetsUrl(url)`
  - `generateAemAssetsOptimizedUrl(assetUrl, alias, params)`
  - `tryGenerateAemAssetsOptimizedUrl(assetUrl, alias, params)`
  - `makeAemAssetsImageSlot(config)`
  - `tryRenderAemAssetsImage(ctx, config)`

## Troubleshooting

### Images not displaying

If product images are not displaying correctly:

1. **Check your configuration:** Ensure `commerce-assets-enabled` is set to `true` if you're using AEM Assets.
2. **Verify image URLs:** AEM Assets images typically include specific URL patterns that indicate they're served from AEM.
3. **Check browser console:** Look for 400 errors that might indicate incompatible optimization parameters.
4. **Test with mixed sources:** Try with both AEM Assets and Commerce-hosted images to isolate the issue.
5. **Confirm slot integration:** If not using the boilerplate, ensure each drop-in image slot calls `tryRenderAemAssetsImage` with a valid `alias` (SKU).
6. **Validate size params:** Ensure `params.width`/`params.height` match the slot's intended render size (for example, from `defaultImageProps`).

### Configuration not taking effect

1. **Clear cache:** Ensure your configuration changes are not cached.
2. **Check config location:** Verify your [storefront configuration](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/commerce-configuration/) is properly formatted.
3. **Validate JSON:** Use a JSON validator to ensure your configuration file is valid.

---

# Storefront configuration

In this section, you'll learn how Commerce blocks in your storefront connect to a Commerce backend using values from either your site's [public config](https://www.aem.live/docs/admin.html#schema/PublicConfig) or a [config.json](https://github.com/hlxsites/aem-boilerplate-commerce/blob/main/demo-config.json) file in your code repo.

The configuration is organized into several key sections:
- **Endpoints** - GraphQL endpoints for Commerce and Catalog Services
- **Headers** - HTTP headers required for API authentication and store context
- **Analytics** - Store and environment metadata for tracking and reporting
- **Plugins** - Configuration for various Edge Delivery Services plugins and features
- **Multistore** - Settings for multiple store views and internationalization

When implementing your own project, you must update the configuration values with:
- The Adobe Commerce and Catalog Service GraphQL endpoint that you configured as part of the [content delivery network (CDN) setup](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/content-delivery-network/).
- The header values specific to your Adobe Commerce Catalog Services environment.

If you [set up your storefront](https://experienceleague.adobe.com/developer/commerce/storefront/get-started/) using the boilerplate code, the template repo provides you with a `demo-config.json` file in the root folder. This file contains the environment values for a Commerce backend including GraphQl endpoints and headers.

If you set up your site using the [Site Creator Tool](https://da.live/app/adobe-commerce/storefront-tools/tools/site-creator/site-creator), the `config.json` file is created and added to the GitHub repository created for the boilerplate code. You can review and update the default values in the `config.json` file after the process completes.

:::note
**Need help configuring your Commerce backend?** Use the [Config Generator tool](https://da.live/app/adobe-commerce/storefront-tools/tools/config-generator/config-generator) to automatically generate the appropriate configuration structure for your Adobe Commerce, Adobe Commerce as a Cloud Service, or Adobe Commerce Optimizer backend. The tool will detect your backend type and generate the correct configuration, though you should validate and confirm the results.
:::

## Vocabulary


### Storefront configuration

A JSON object that maps properties and values used by the Commerce boilerplate.

The storefront configuration is a JSON object which lives in the [config-service](https://www.aem.live/docs/config-service-setup) and contains the connection settings for your Commerce blocks. The boilerplate repo also contains a `demo-config.json` file that can be renamed to `config.json` instead of using the config service, although we suggest using the config service.

At the root, there is a `public` property which should not be changed, and a nested `default` object. This `default` object is the root level configuration that is used for your storefront. The config object contains properties and values which correspond to a specific setting or usage in your Commerce backend.

If you use aem.live's config service, your config will live at `https://admin.hlx.page/config/{{ORG}}/sites/{{SITE}}/public.json` but can be overwritten with a local `/config.json` file in your code repo.

### default values

By default, the values in the `demo-config.json` file are from the boilerplate's sample backend to ensure everything works out of the box. But when it comes time to connect your own backend, you need to know what each key means so you can update it with the correct value from your own Commerce instance.

### getConfigValue function

The `getConfigValue` function is a helper function that retrieves the `value` from the `configs` file using the dot-notation path as an argument. For example, `getConfigValue('headers.cs.x-api-key')` returns the value of `[root config].headers.cs.x-api-key`.

### getHeaders function

The `getHeaders` function is a helper function which takes a storefront scope (like `cs`, `cart`, etc) and reads values from the configs file with the corresponding `header` keys and returns an object map of those rows. For example, if you have properties in config like `headers.cs.Magento-Environment-Id": "abc-123"`, then `getHeaders('cs')` will return an object like `{ "Magento-Environment-Id": "abc-123"}`.



## Configuration Caching

The storefront configuration is cached at multiple levels to optimize performance:

- **CDN Caching**: The configuration file is cached by the EDS CDN with a `max-age=7200` (2 hours) cache control header. This means configuration changes can take up to 2 hours to be reflected on the CDN after deployment.

- **Browser Caching**: When the configuration is loaded in the browser, it is stored in [session storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage), which persists until the browser session is cleared.

**For developers**: After making configuration changes, it can take up to two hours for the CDN cache to expire. Clear your browser's session storage to see updates. Verify the current cache configuration by accessing `<site.com>/config.json` directly and checking the `last-modified` header.

## Configuration Sections

The following sections detail each part of your configuration for Adobe Commerce. Each section includes placeholders (marked with `{{PLACEHOLDER}}`) that you must replace with your specific Commerce environment details.

You can find your configuration in your code repo at `/config.json` or `/demo-config.json`, or in the config service for your site. If you do not have a configuration yet, use the [Config Generator tool](https://da.live/app/adobe-commerce/storefront-tools/tools/config-generator/config-generator) to automatically generate the configuration for your backend.

### Endpoints

The endpoints properties define the GraphQL API endpoints for your Commerce backend.

```json
{
  "commerce-core-endpoint": "{{COMMERCE_CORE_ENDPOINT}}",
  "commerce-endpoint": "{{COMMERCE_ENDPOINT}}"
}
```

**Configuration Properties:**

- **`commerce-core-endpoint`** (read/write) - Core GraphQL endpoint for queries and mutations. This endpoint handles all write operations and some read operations. See [Adobe Commerce GraphQL API](https://developer.adobe.com/commerce/webapi/graphql/reference/) for details.

- **`commerce-endpoint`** (read-only) - Services GraphQL endpoint optimized for read-only operations with Catalog Service, Live Search, and Product Recommendations. It is also optimized for performance for product data retrieval. For details, see the following documentation:
   - For Adobe Commerce as a Cloud Service, see the [Catalog Service Guide](https://experienceleague.adobe.com/en/docs/commerce/catalog-service/installation#access-the-service).
   - For Adobe Commerce Optimizer, see the [Merchandising Services Developer Guide](https://developer.adobe.com/commerce/services/optimizer/merchandising-services/using-the-api/#base-url)

### Headers

The headers section defines HTTP headers required for API authentication and store context. Headers are organized by scope to apply different authentication and context settings for different request types. The specific headers required depend on your Commerce environment type.



<TabItem label="Adobe Commerce (PaaS)">

Adobe Commerce PaaS environments use standard Adboe Commerce header naming conventions and require API keys for SaaS services.

```json
{
  "headers": {
    "all": {
      "Store": "{{STORE_VIEW_CODE}}"
    },
    "cs": {
      "Magento-Store-Code": "{{STORE_CODE}}",
      "Magento-Store-View-Code": "{{STORE_VIEW_CODE}}",
      "Magento-Website-Code": "{{WEBSITE_CODE}}",
      "x-api-key": "{{API_KEY}}",
      "Magento-Environment-Id": "{{ENVIRONMENT_ID}}"
    }
  }
}
```

**Header Scopes:**

- **`all`** - Headers applied to all GraphQL requests
  - **`Store`** - Store view code for Core GraphQL requests. See [GraphQL Headers](https://developer.adobe.com/commerce/webapi/graphql/usage/headers/) for details.

- **`cs`** - Headers for Catalog Service requests
  - **`Magento-Store-Code`** - Store to connect to. See [Create stores](https://experienceleague.adobe.com/en/docs/commerce-operations/configuration-guide/multi-sites/ms-admin#step-3-create-stores) for details.
  - **`Magento-Store-View-Code`** - Store view for Catalog Service requests. See [Store views](https://experienceleague.adobe.com/en/docs/commerce-admin/stores-sales/site-store/store-views) for details.
  - **`Magento-Website-Code`** - Website to connect to. See [Create websites](https://experienceleague.adobe.com/en/docs/commerce-operations/configuration-guide/multi-sites/ms-admin#step-2-create-websites) for details.
  - **`x-api-key`** - API key for SaaS services (Catalog Service, Live Search, Product Recommendations). See [Commerce Services Connector](https://experienceleague.adobe.com/en/docs/commerce/user-guides/integration-services/saas) for details.
  - **`Magento-Environment-Id`** - Connects the storefront to the cloud instance serving it. See [Cloud Environment overview](https://experienceleague.adobe.com/en/docs/commerce-cloud-service/user-guide/project/overview#environment-overview) for details.

</TabItem>

<TabItem label="Adobe Commerce as a Cloud Service (ACCS)">

Adobe Commerce as a Cloud Service uses standard Adobe Commerce header naming conventions but does not require API keys or environment IDs in the default configuration.

```json
{
  "headers": {
    "all": {
      "Store": "{{STORE_VIEW_CODE}}"
    },
    "cs": {
      "Magento-Store-Code": "{{STORE_CODE}}",
      "Magento-Store-View-Code": "{{STORE_VIEW_CODE}}",
      "Magento-Website-Code": "{{WEBSITE_CODE}}"
    }
  }
}
```

**Header Scopes:**

- **`all`** - Headers applied to all GraphQL requests
  - **`Store`** - Store view code for Core GraphQL requests. See [GraphQL Headers](https://developer.adobe.com/commerce/webapi/graphql/usage/headers/) for details.

- **`cs`** - Headers for Catalog Service requests
  - **`Magento-Store-Code`** - Store to connect to. See [Create stores](https://experienceleague.adobe.com/en/docs/commerce-operations/configuration-guide/multi-sites/ms-admin#step-3-create-stores) for details.
  - **`Magento-Store-View-Code`** - Store view for Catalog Service requests. See [Store views](https://experienceleague.adobe.com/en/docs/commerce-admin/stores-sales/site-store/store-views) for details.
  - **`Magento-Website-Code`** - Website to connect to. See [Create websites](https://experienceleague.adobe.com/en/docs/commerce-operations/configuration-guide/multi-sites/ms-admin#step-2-create-websites) for details.

</TabItem>

<TabItem label="Adobe Commerce Optimizer (ACO)">

Adobe Commerce Optimizer uses different header naming conventions and requires Commerce Optimizer-specific headers as defined in the [Merchandising Services API documentation](https://developer.adobe.com/commerce/services/optimizer/merchandising-services/using-the-api/#headers).

```json
{
  "headers": {
    "cs": {
      "AC-View-ID": "{{CATALOG_VIEW_ID}}",
      "AC-Source-Locale": "{{LOCALE}}",
      "AC-Price-Book-ID": "{{PRICE_BOOK_ID}}",
      "AC-Policy-{{*}}": "{{ATTRIBUTE_VALUE}}"
    }
  }
}
```

**Header Scopes:**

- **`cs`** - Headers applied to all GraphQL requests
  - **`AC-View-ID`** - (Required) The unique ID assigned to the catalog view that products will be sold through. You can find this in the [Adobe Commerce Optimizer UI](https://experienceleague.adobe.com/en/docs/commerce/optimizer/setup/catalog-view).
  - **`AC-Source-Locale`** - (Required) Catalog source locale (language or geography) to filter products for display, for example `en_US`. See the [catalog view configuration](https://experienceleague.adobe.com/en/docs/commerce/optimizer/setup/catalog-view) to determine the correct value.
  - **`AC-Price-Book-ID`** - (Optional) Defines how prices are calculated for a specific catalog view. If not included, Merchandising Services provides a default price book with currency in US dollars.
  - **`AC-Policy-{{*}}`** - (Optional) Policy trigger for filtering products by attribute. The header should match the "name" of the trigger. For example, `AC-Policy-Brand:Cruz` for brand filtering using "Cruz". You can specify multiple policy headers per request.

:::note[Troubleshooting ACO Headers]
**Warning:** There is currently a bug (being resolved) that may require adding the `AC-Environment-ID` header in some ACO configurations. If you have all the requisite ACO headers configured correctly and are still experiencing problems, you may need to add this header:

```json
{
  "headers": {
    "cs": {
      "AC-Environment-Id": "{{TENANT_ID}}",
      // ... your other ACO headers
    }
  }
}
```
:::

</TabItem>



### Analytics

The analytics section contains store and environment metadata for tracking and reporting. The specific values depend on your Commerce environment type.



<TabItem label="Adobe Commerce (PaaS) / ACCS">

For Adobe Commerce PaaS and Adobe Commerce as a Cloud Service environments, use standard Commerce store and website identifiers from your Commerce Environment. You can obtain these values using a `storeConfig` query.

```json
{
  "analytics": {
    "base-currency-code": "{{CURRENCY_CODE}}",
    "environment": "{{ENVIRONMENT_TYPE}}",
    "environment-id": "{{ENVIRONMENT_ID}}",
    "store-code": "{{STORE_CODE}}",
    "store-id": {{STORE_ID}},
    "store-name": "{{STORE_NAME}}",
    "store-url": "{{STORE_URL}}",
    "store-view-code": "{{STORE_VIEW_CODE}}",
    "store-view-id": {{STORE_VIEW_ID}},
    "store-view-name": "{{STORE_VIEW_NAME}}",
    "website-code": "{{WEBSITE_CODE}}",
    "website-id": {{WEBSITE_ID}},
    "website-name": "{{WEBSITE_NAME}}"
  }
}
```

**Configuration Properties:**

- **`base-currency-code`** - The base currency code for the store (e.g., "USD", "EUR")
- **`environment`** - Environment type ("Production", "Testing")
- **`environment-id`** - Unique identifier for the Commerce environment
- **`store-url`** - Base URL for the store
- **`store-code`** - Code identifier for the store from your Commerce environment
- **`store-id`** - Numeric ID for the store
- **`store-name`** - Display name for the store
- **`store-view-code`** - Code identifier for the store view
- **`store-view-id`** - Numeric ID for the store view
- **`store-view-name`** - Display name for the store view
- **`website-code`** - Code identifier for the website from your Commerce environment
- **`website-id`** - Numeric ID for the website
- **`website-name`** - Display name for the website

</TabItem>

<TabItem label="Adobe Commerce Optimizer (ACO)">

For Adobe Commerce Optimizer environments, use a simplified analytics configuration structure:

```json
{
  "analytics": {
    "base-currency-code": "{{CURRENCY_CODE}}",
    "environment": "{{ENVIRONMENT_TYPE}}",
    "environment-id": "{{YOUR_TENANT_ID}}",
    "locale": "{{LOCALE}}",
    "store-url": "{{STORE_URL}}",
    "store-view-currency-code": "{{CURRENCY_CODE}}",
    "storefront-template": "{{TEMPLATE_TYPE}}",
    "view-id": "{{CATALOG_VIEW_ID}}"
  }
}
```

**Configuration Properties:**

- **`base-currency-code`** - The base currency code for the store (e.g., "USD", "EUR")
- **`environment`** - Environment type ("Production", "Testing")
- **`environment-id`** - The tenant ID for the Adobe Commerce Optimizer instance
- **`locale`** - Catalog source locale (language or geography) for the store view, for example `en-US`
- **`store-url`** - Base URL for the store
- **`store-view-currency-code`** - Currency code for the store view (e.g., "USD", "EUR")
- **`storefront-template`** - (Optional) Storefront template type (e.g., "Other")
- **`view-id`** - The unique ID assigned to the catalog view from the Adobe Commerce Optimizer UI

</TabItem>



### Plugins

The plugins section configures various Commerce plugins and features.

```json
{
  "plugins": {
    "picker": {
      "rootCategory": "{{ROOT_CATEGORY_ID}}"
    }
  }
}
```

**Configuration Properties:**

- **`picker.rootCategory`** - Root category ID for the product picker. This determines which category serves as the starting point when browsing products in the Commerce interface.

### Multistore

The multistore section manages configurations for multiple store views and internationalization. This allows different configurations for different locales or store views. Each non-"default" configuration will be merged with the default at runtime and used for the corresponding locale or store view. For example, the below would serve as a basis for configuration for the site at aemshop.net/fr.

```json
{
  "/fr/": {
    "headers": {
      "all": {
        "Store": "{{FRENCH_STORE_VIEW_CODE}}"
      },
      "cs": {
        "Magento-Store-Code": "{{FRENCH_STORE_CODE}}",
        "Magento-Website-Code": "{{FRENCH_WEBSITE_CODE}}",
        "Magento-Store-View-Code": "{{FRENCH_STORE_VIEW_CODE}}"
      }
    }
  }
}
```

**Configuration Properties:**

- **Path-based configuration** - Use URL paths (like `/fr/`, `/de/`, etc.) to define locale-specific or store-specific overrides
- **Header overrides** - Override default headers for specific store views
- **Store context** - Define different store, website, and store view codes for each locale


### Additional Configuration Options

Some configuration options can be set to enable or disable certain boilerplate features.

```json
{
  "commerce-assets-enabled": boolean,
  "commerce-companies-enabled": boolean,
}
```

- **`commerce-assets-enabled`** - Boolean flag to enable or disable AEM Assets within the storefront
- **`commerce-companies-enabled`** - Boolean flag to enable or disable Commerce B2B features within the storefront

## Configuration Examples

The following examples show real `config.json` files from different Adobe Commerce environments. These examples demonstrate the actual structure and values used in production environments.



<TabItem label="Adobe Commerce (PaaS)">

This example shows the configuration for an Adobe Commerce PaaS environment, which includes additional features like multistore support and asset management. This configuration is used on this site: https://www.aemshop.net/

```json title="aemshop.net config.json example" showLineNumbers
{
  "public": {
    "default": {
      "commerce-core-endpoint": "https://www.aemshop.net/graphql",
      "commerce-endpoint": "https://www.aemshop.net/cs-graphql",
      "headers": {
        "all": {
          "Store": "default"
        },
        "cs": {
          "Magento-Store-Code": "main_website_store",
          "Magento-Store-View-Code": "default",
          "Magento-Website-Code": "base",
          "x-api-key": "4dfa19c9fe6f4cccade55cc5b3da94f7",
          "Magento-Environment-Id": "f38a0de0-764b-41fa-bd2c-5bc2f3c7b39a"
        }
      },
      "analytics": {
        "base-currency-code": "USD",
        "environment": "Production",
        "environment-id": "f38a0de0-764b-41fa-bd2c-5bc2f3c7b39a",
        "store-code": "main_website_store",
        "store-id": 1,
        "store-name": "Main Website Store",
        "store-url": "https://www.aemshop.net",
        "store-view-code": "default",
        "store-view-id": 1,
        "store-view-name": "Default Store View",
        "website-code": "base",
        "website-id": 1,
        "website-name": "Main Website"
      },
      "plugins": {
        "picker": {
          "rootCategory": "2"
        }
      },
      "commerce-assets-enabled": false
    },
    "/fr/": {
      "headers": {
        "all": {
          "Store": "fr"
        },
        "cs": {
          "Magento-Store-Code": "fr_store",
          "Magento-Website-Code": "fr_website",
          "Magento-Store-View-Code": "fr"
        }
      }
    }
  }
}
```
</TabItem>

<TabItem label="Adobe Commerce as a Cloud Service (ACCS)">

This example shows the configuration for Adobe Commerce as a Cloud Service, which uses standard Adobe Commerce header naming conventions. This configuration is used on this site: https://main--boilerplate-accs--adobe-commerce.aem.live/

```json title="ACCS config.json" showLineNumbers
{
  "public": {
    "default": {
      "commerce-core-endpoint": "https://na1-sandbox.api.commerce.adobe.com/LwndYQs37CvkUQk9WEmNkz/graphql",
      "commerce-endpoint": "https://na1-sandbox.api.commerce.adobe.com/LwndYQs37CvkUQk9WEmNkz/graphql",
      "headers": {
        "all": {
          "Store": "default"
        },
        "cs": {
          "Magento-Store-Code": "main_website_store",
          "Magento-Store-View-Code": "default",
          "Magento-Website-Code": "base"
        }
      },
      "analytics": {
        "base-currency-code": "USD",
        "environment": "Testing",
        "environment-id": "LwndYQs37CvkUQk9WEmNkz",
        "store-code": "main_website_store",
        "store-id": 1,
        "store-name": "ACCS Store",
        "store-url": "https://main--boilerplate-accs--adobe-commerce.aem.live",
        "store-view-code": "default",
        "store-view-id": 1,
        "store-view-name": "Default Store View",
        "website-code": "base",
        "website-id": 1,
        "website-name": "Main Website"
      },
      "plugins": {
        "picker": {
          "rootCategory": "2"
        }
      }
    }
  }
}
```

</TabItem>

<TabItem label="Adobe Commerce Optimizer (ACO)">

This example shows the configuration for Adobe Commerce Optimizer, which uses different header naming conventions and includes Commerce Optimizer-specific settings. This configuration is used on this site: https://main--boilerplate-aco--adobe-commerce.aem.live/

```json title="ACO config.json" showLineNumbers
{
  "public": {
    "default": {
      "commerce-core-endpoint": "https://na1-sandbox.api.commerce.adobe.com/8idEEDDiVwjCEJAyB5kjfi/graphql",
      "commerce-endpoint": "https://na1-sandbox.api.commerce.adobe.com/8idEEDDiVwjCEJAyB5kjfi/graphql",
      "headers": {
        "cs": {
          "ac-view-id": "0d3eebf7-b5fb-4904-9ccf-f35fcc61862b",
          "ac-price-book-id": "west_coast_inc",
          "ac-scope-locale": "en-US"
        }
      },
      "analytics": {
        "base-currency-code": "USD",
        "environment": "Testing",
        "environment-id": "8idEEDDiVwjCEJAyB5kjfi",
        "locale": "en-US",
        "store-url": "https://main--boilerplate-aco--adobe-commerce.aem.live/",
        "store-view-currency-code": "USD",
        "storefront-template": "Other",
        "view-id": "0d3eebf7-b5fb-4904-9ccf-f35fcc61862b"
      },
      "plugins": {
        "picker": {
          "rootCategory": "2"
        }
      }
    }
  }
}
```

</TabItem>



## Step-by-step

We'll use a mock PDP / Catalog Service block to demonstrate how to utilize the config utilities and values. This example shows how to access the configuration sections detailed above.



<Task>

### Import the configuration functions.

First, import the `getConfigValue` and `getHeaders` functions from your boilerplate's `scripts/configs.js` file.

```javascript
```

</Task>

<Task>

### Access endpoint configuration.

Use the `getConfigValue` function to retrieve endpoint URLs from the configuration. This function takes a dot-notation path that matches the keys in your `config.json`.

```javascript
export default async function decorate(block) {
  // Get the catalog service endpoint from the endpoints section
  const catalogEndpoint = await getConfigValue('commerce-endpoint');
  const coreEndpoint = await getConfigValue('commerce-core-endpoint');

  console.log('Catalog Service endpoint:', catalogEndpoint);
  console.log('Core Commerce endpoint:', coreEndpoint);
}
```

</Task>

<Task>

### Access header configuration.

Use the `getHeaders` function to retrieve headers for specific scopes. This function automatically formats the headers for use in HTTP requests.

```javascript
export default async function decorate(block) {
  // Get headers for Catalog Service requests
  const csHeaders = await getHeaders('cs');

  // Get headers for all requests
  const allHeaders = await getHeaders('all');

  console.log('CS headers:', csHeaders);
  console.log('All headers:', allHeaders);
}
```

</Task>

<Task>

### Access analytics and other configuration.

Use `getConfigValue` to access any configuration value using dot notation, including analytics data and plugin settings.

```javascript
export default async function decorate(block) {
  // Get analytics configuration
  const storeUrl = await getConfigValue('analytics.store-url');
  const currency = await getConfigValue('analytics.base-currency-code');
  const environment = await getConfigValue('analytics.environment');

  // Get plugin configuration
  const rootCategory = await getConfigValue('plugins.picker.rootCategory');

  console.log('Store URL:', storeUrl, 'Currency:', currency, 'Environment:', environment);
  console.log('Root category:', rootCategory);
}
```

</Task>

<Task>

### Make API requests with configuration.

Combine the endpoint and header configuration to make authenticated API requests to your Commerce backend.

```javascript
export default async function decorate(block) {
  // Get the catalog service endpoint
  const endpoint = await getConfigValue('commerce-endpoint');

  // Get the catalog service required headers
  const headers = await getHeaders('cs');

  // Make the API request
  const response = await fetch(endpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...headers
    },
    body: JSON.stringify({
      query: `query { products { items { name } } }`
    })
  });

  const data = await response.json();
  // Process the response data
}
```

</Task>



## Summary

The Commerce configuration provides a structured approach to connecting your storefront to Adobe Commerce backends. By organizing settings into clear sections for endpoints, headers, analytics, plugins, and multistore configurations, you can easily customize your storefront for different Commerce environments. The configuration system supports Adobe Commerce (PaaS), Adobe Commerce as a Cloud Service (ACCS), and Adobe Commerce Optimizer (ACO), each with specific header requirements and authentication methods. Use the `getConfigValue` and `getHeaders` helper functions to access these settings in your Commerce blocks, ensuring consistent and maintainable integration with your Commerce backend.

---

# Content delivery network (CDN)

A CDN is a critical component of your Commerce Storefront. It is responsible for delivering content to your customers in the most efficient and secure way possible.

CDN features, usage, and provider details vary depending on your backend commerce implementation. By default, Adobe Commerce on Cloud projects use Fastly, while Adobe Commerce as a Cloud Service projects use an Adobe-managed CDN service.

If necessary, you can configure your own CDN, also known as "Bring Your Own CDN" (BYO CDN). See [BYO CDN Setup](https://www.aem.live/docs/byo-cdn-setup) for required settings and vendor-specific setup instructions.

> **Note:** Drop-in components automatically add image optimization parameters (such as width, height, and quality) to image URLs. CDN-based image optimization services rely on these parameters to optimize images. If you need to use different parameters or URL patterns for your CDN provider, you can override the defaults by using the [`setImageParamKeys`](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/initializer/#setimageparamkeysparams) method in the initializer configuration.

 For Adobe Commerce on Cloud projects, Fastly is included with your Adobe Commerce license and is the default CDN provider. The [`fastly-magento2`](https://github.com/fastly/fastly-magento2) module exposes Fastly service configurations in the Commerce Admin.

The remaining sections on this page provide instructions and guidance for configuring Adobe Commerce on Cloud projects with the Fastly module. It focuses on routing use cases, configuration, validation, and debugging.

## Routing

The main difference between the use cases described in this section is whether all paths should be routed by default to Commerce or Edge Delivery Services. If you plan to use Edge Delivery Services only for your homepage, all paths should default to Commerce. However, if you plan to migrate parts of your storefront over time, the Edge Delivery Services origins are more sensible.

Defaulting to Edge Delivery Services is generally ideal because you'll have to log in to the Commerce Admin and understand Fastly VCLs to add the path for routing in the â€œdefault to Commerceâ€ scenario when adding a new page in Edge Delivery Services. Therefore, the VCL snippets below focus on the â€œdefault to Edgeâ€ use case.

The following table provides a high-level comparison of the three routing options:

| Topic                          | Full storefront                              | Luma Bridge                                            | Homepage only                                                 |
|--------------------------------|----------------------------------------------|--------------------------------------------------------|---------------------------------------------------------------|
| **Routing logic**              | Default to Edge Delivery Services            | Default to Edge Delivery Services                      | Default to Commerce                                           |
| **Paths routed to Commerce**   | Product images, GraphQL endpoints             | Transactional pages, account page, REST endpoints, etc | All paths except those explicitly                             |
| **Paths routed to Edge**       | All other paths                              | Product catalog, content pages                         | Homepage                                                      |
| **VCL snippets focus**         | Default to Edge Delivery Services            | Default to Edge Delivery Services                      | Default to Commerce                                           |
| **Optimization tips**          | Avoid additional TLS handshake for API calls | Same as full storefront                                | Route resources (JS, CSS) to Edge Delivery Services           |
| **Common patterns**            | Use CDN as proxy for Catalog Service         | Same as full storefront                                | Move Edge code to subfolder, such as `aem`                    |

:::note
All paths for the Adobe Commerce Admin should be routed to Commerce.
:::

### Full storefront

The entire storefront experience is delivered by Edge Delivery Services. Only some paths (for example, images and API calls) are routed to Commerce.

* By default, paths are routed to Edge Delivery Services
* Product images must be routed to Commerce
* Commerce GraphQL endpoint must be routed to Commerce
* CDN must proxy requests to your Catalog Service API endpoints (https://catalog-service.adobe.io/graphql and https://catalog-service-sandbox.adobe.io/graphql).

  :::tip
  These API endpoints impact largest contentful paint (LCP), so we want to avoid an additional TLS handshake.
  :::

### Luma Bridge

The product catalog and content pages are delivered by Edge Delivery Services. Transactional pages (for example, cart, checkout, and account) are delivered by Commerce.

* [Luma Bridge](https://experienceleague.adobe.com/developer/commerce/storefront/setup/discovery/luma-bridge/) includes the same details as the full storefront option, plus the following:
  * Transactional pages (for example, cart, checkout, and account) are routed to Commerce, depending on the Luma Bridge implementation
  * Any additional endpoints (such as REST endpoints, `/customer/sections/load`) that are required by the Luma Bridge implementation are routed to Commerce

### Homepage only

Only the homepage is delivered by Edge Delivery Services. All Commerce functionality is delivered by Commerce.

* All paths are routed to Commerce by default
* The paths that are routed to Edge Delivery Services are explicitly set
* Resources (for example, JS and CSS) that are required by the Edge Delivery Servicesw pages must be routed to Edge Delivery Services

  :::note
  A common pattern is to move all Edge Delivery Services code into a subfolder called `aem`, and then route any path starting with `aem` to Edge Delivery Services.
  :::

For general information on setting up Fastly for Adobe Commerce and accessing the Adobe Commerce Admin, see [Fastly services overview](https://experienceleague.adobe.com/en/docs/commerce-cloud-service/user-guide/cdn/fastly).

## Backend configuration

The first step is to configure a backend for each origin/service that Fastly needs to route to, which includes the following:

* Edge Delivery Services
* Catalog Service GraphQL API endpoint
* Default Adobe Commerce backend

:::note
The Fastly configuration instructions on this page are based on the [`fastly-magento2`](https://github.com/fastly/fastly-magento2) module, which exposes Fastly service configurations in the Adobe Commerce Admin.
:::



1. Log in to the Adobe Commerce Admin.

1. Click **Stores** > **Settings** > **Configuration** > **Advanced** > **System** > **Full Page Cache** > **Fastly Configuration** > **Backend Settings** > **Create**.

1. Enter a name for the Edge Delivery Services backend.

   For example: `edge delivery`.

1. Enter the address for the Edge Delivery Services backend.

   For example: `main--aem-boilerplate-commerce--hlxsites.aem.live`

1. Click **Attach condition**.

1. Click **Create a new request condition**.

1. Enter a name for the condition.

   For example: `false`.

1. Enter `false` in the **Apply if** field.

1. Accept the default (`10`) in the **Priority** field

1. Click **Create**.

1. Select your new condition from the **Condition** drop-down list.

   ![Backend configuration for Commerce](@images/implementation/backend-config-example.png/)

   :::caution
   Remember to also set this condition for the default Adobe Commerce backend. Otherwise, this condition can overwrite the changes made by the VCL conditions that you configure in the custom VCL snippets. You could also lose access to the Admin, which may require an Adobe Commerce Support ticket to resolve.
   :::

1. Set Shielding to **(none)**.

   If you choose to use shielding, see the [shielding section](#shielding) for additional guidance.



Repeat these steps for the Catalog Service GraphQL API endpoints (plus any other backends that you may require):

* `https://catalog-service.adobe.io/graphql`
* `https://catalog-service-sandbox.adobe.io/graphql`

:::tip
You can also rename the Adobe Commerce backend from the generated name to simply `commerce`.
:::

## VCL configuration

Your routing set up requires the following VCL snippets:

* `recv`
* `pass`
* `miss`
* `fetch`
* `deliver`

See [Using VCL](https://www.fastly.com/documentation/guides/vcl/using/) in the Fastly documentation for more information.

The VCL snippets on this page are a starting point that you can alter or extend to fit your use cases. There are also examples of potential extended use cases listed further down the page. The main purposes of the VCL snippets are to:

* Correctly set the backend based on request path
* Set the recommended priority setting for each snippet to determine the order in which they are executed (lower numbers are executed first)
* Ensure that the requests do not receive extra caching or headers if they are going to a non-Adobe Commerce backend (achieved by returning early)
* Improve performance for non-Adobe Commerce backends by rewriting some features, like compression, that would be provided by the default Adobe Commerce VCL

:::tip
If you make a change or apply a new VCL snippet, it can take some time to propagate and apply to Fastly's system. It's a best practice to validate the latest change before continuing to other changes, otherwise you may introduce a bug and find it challenging to determine the root cause.

If you need to rename a snippet, delete it first and then recreate it with the new name to avoid this [known issue](https://github.com/fastly/fastly-magento2/issues/708).
:::

To apply these custom VCL snippets to your Adobe Commerce Fastly CDN service, see [Getting started with custom VCL](https://experienceleague.adobe.com/en/docs/commerce-cloud-service/user-guide/cdn/custom-vcl-snippets/fastly-vcl-custom-snippets) or use the [`fastly-magento2`](https://github.com/fastly/fastly-magento2) Admin module.

### recv

The following `recv` snippet does a simple redirect if `host` does not contain `www`. The snippet adds the string and then redirects to `https` using a [Fastly-specific error code](https://www.fastly.com/documentation/reference/http/http-statuses/). This is done in place of the **Auto-redirect to Base URL** setting in the Commerce Admin. The steps in the [Commerce configuration](#commerce-configuration) section instruct you to set **Auto-redirect to Base URL** to **No** based on this snippet.

**Type**: `recv`

**Priority**: `4`

```txt
if (req.http.host == "aemshop.net") {
  set req.http.host = "www.aemshop.net";
  error 801;
}
```

The following `recv` snippet has the following purpose:

* Path-based routing for Edge Delivery Services, Catalog Service, and Adobe Commerce backends
* Preparing the requests for the respective backends
* Blocking access to non-production environments (non-production environments should not be indexed by search engines)

**Type**: `recv`

**Priority**: `100`

```txt
unset req.http.x-commerce;

# Catalog Service
if (req.url.path ~ "^/cs-graphql$") {
    # Disable Commerce WAF as it can interfere with some queries
    set req.http.bypasswaf = "true";

    # Forward to Catalog Service GraphQL
    set req.backend = F_catalog_service;
    set req.http.host = "catalog-service.adobe.io";
    set req.url = regsub(req.url, "^/cs-graphql", "/graphql");

    # Remove cookies
    unset req.http.Cookie;
}
else if (req.url.path ~ "^/(graphql|rest|oauth|media|checkout|customer|admin|static)($|/)") {
    # Commerce routes, e.g. for product images, core GQL/Rest, Luma Bridge (any paths which should load Commerce origin)
    set req.backend = F_commerce;
    set req.http.x-commerce = "true";
}
else
{
    # Block access to non-prod configs
    if (req.url ~ "^/configs-(stage|dev)\.json$") {
        error 404 "Not Found";
    }

    # Everything else is considered Edge Delivery Services
    set req.backend = F_edge_delivery;
    # Restore accepted encoding
    set req.http.Accept-Encoding = req.http.Fastly-Orig-Accept-Encoding;
    if (req.url.path !~ "/media_[0-9a-f]{40,}[/a-zA-Z0-9_-]*\.[0-9a-z]+$"
        && req.url.ext !~ "(?i)^(gif|png|jpe?g|webp)$"
        && req.url.ext != "json"
        && req.url.path != "/.auth") {
        # trim the query string to improve caching
        set req.url = req.url.path;
        # replace some special characters with a dash because Edge doesn't support them
        set req.url = regsuball(req.url, "[()]", "-");

    }
}
```

### pass

In the `pass` snippet, we set the correct host URL to fetch from depending on the backend that was selected in the `recv` snippet.

If it's not a request to Adobe Commerce, we skip (return `pass` will invoke `fetch`) the rest of the default `pass` VCL.

**Type**: `pass`

**Priority**: `30`

```txt
if (req.backend == F_edge_delivery) {
    set bereq.http.Host = "main--aem-boilerplate-commerce--hlxsites.hlx.live";
    set bereq.http.X-BYO-CDN-Type = "fastly";
    set bereq.http.X-Push-Invalidation = "enabled";
}

if (!req.http.x-commerce) {
    return(pass);
}
```

:::note
Changes to the host header set here will require a Commerce Fastly cache purge due to [how and when Fastly calculates cache `HITS`](https://docs.fastly.com/en/guides/manipulating-the-cache-key#redefining-the-cache-key).
:::

### miss

Same as `pass`.

**Type**: `miss`

**Priority**: `30`

```txt
if (req.backend == F_edge_delivery) {
    set bereq.http.Host = "main--aem-boilerplate-commerce--hlxsites.hlx.live";
    set bereq.http.X-BYO-CDN-Type = "fastly";
    set bereq.http.X-Push-Invalidation = "enabled";
}

if (!req.http.x-commerce) {
    return(fetch);
}
```

:::note
Changes to the Host header set here will require a Commerce Fastly cache purge due to [how and when Fastly calculates cache `HITS`](https://docs.fastly.com/en/guides/manipulating-the-cache-key#redefining-the-cache-key).
:::

### fetch

If fetching from a backend other than Adobe Commerce, skip the rest of the [default deliver VCL](https://github.com/fastly/fastly-magento2/blob/fdd616cd0f945530e02e92e594ca00fd7990f557/etc/vcl_snippets/fetch.vcl) because this is only relevant to Adobe Commerce backends.

**Type**: `fetch`

**Priority**: `30`

```txt
if (!req.http.x-commerce) {
    unset beresp.http.Set-Cookie;
    return(deliver);
}
```

### deliver

This comes from the Edge Delivery Services [Fastly setup](https://www.aem.live/docs/byo-cdn-fastly-setup#:~:text=Finally%20create%20a%20deliver%20snippet).

**Type**: `deliver`

**Priority**: `30`

```txt
if (req.backend == F_edge_delivery) {
    unset resp.http.Age;

    if (req.url.path !~ "\.plain\.html$") {
        unset resp.http.X-Robots-Tag;
    }
}
```

## Optional configuration

The following are optional configurations that can be added to the VCL snippets to handle specific use cases.

### URL rewrites

Be aware that URLs in Edge Delivery Services may only contain a-z, 0-9, and the dash (`-`) character (see [Document naming](https://www.aem.live/docs/limits#document-naming)). You may need to create a CDN rule to rewrite/remove these characters.

As an example, consider one possible case where this applies with login referrer links. Luma may redirect to a page like `/login/referrer/<base64string>`. If the login page is implemented in Edge Delivery Services (with a Luma Bridge) and the base 64 string contains unsupported characters, this page will 404. Since the base64 part is only needed on the Edge Delivery Services client side to handle redirecting after a successful sign-in, this could be stripped for the request to the Edge Delivery Services backend.

:::note
The exact cases where this needs to be performed, and the steps required, depend on the implementation of the Luma Bridge as well as customizations of Adobe Commerce.
:::

### GeoIP

The following example redirects users to a country-specific path based on their IP address. It uses the `country_to_store` table, which is a built-in Fastly table that maps country codes to store codes. You must install the Fastly CDN [extension](https://commercemarketplace.adobe.com/fastly-magento2.html) or [module](https://github.com/fastly/fastly-magento2) to use this example.

Add the following to the `recv` snippet:

```txt
# Enable the GeoIP feature, allowing the VCL to use GeoIP data for various purposes, such as redirecting users based on their geographic location.

pragma optional_param geoip_opt_in true;

# Snippet GeoIpRedirect
 declare local var.countryCode STRING;

# Only apply redirection if the URL has no country-specific path

# This snippet performs a GeoIP-based redirection. It checks if the request is made to the
# "example.com" domain and if the URL path is either the root ("/") or empty. If these conditions are met, it
# retrieves the user's country code based on their IP address using the `client.geo.country_code` variable.
# It then looks up the corresponding store code from the `country_to_store` table. The user is redirected
# to the appropriate country-specific URL.

if ((req.http.host ~ "example.com") && ((req.url.path == "/") || (req.url.path == "")))  {
      # Retrieve the user's country based on IP address
      set var.countryCode = table.lookup(country_to_store, client.geo.country_code,"us");
      set req.http.X-Redirect-Url = "https://" + req.http.host + "/" + var.countryCode;
      if (req.url.qs != "") {
                   set req.http.X-Redirect-Url = req.http.X-Redirect-Url + "?" + req.url.qs;
      }
        error 701;
   }
# End of Snippet GeoIpRedirect

# This table maps country codes to store codes. It is used in the GeoIP redirect logic to determine
# the appropriate store URL based on the user's geographic location.

table country_to_store {
    "FR": "fr",
    "AU": "au",
    "NZ": "nz",
    "CA": "ca",
    ...
}
```

### Proxy RUM through the origin to avoid a TLS handshake

Add a new backend called `hlx_rum` that points to `rum.hlx.page`. Also, change the [Real Use Monitoring (RUM)](https://www.aem.live/docs/rum) implementation in `aem.js` to use a relative path to the origin instead of `rum.hlx.page`.

Add the following to the `recv` snippet:

```txt
if (req.url.path ~ "^/\.rum/") {
    # AEM Real User Monitoring
    set req.backend = F_hlx_rum;
    unset req.http.Cookie;
}
```

### Shielding

If you enable shielding in a backend, then conditions like `req.backend == F_commerce` may not work. For this reason, the snippets above use a header like `http.x-commerce` that is set/unset, which is then used instead of the direct backend variable.

### Compression

In `fetch`, you can add compression for non-Adobe Commerce resources by adding this snippet to the `fetch` VCL:

```txt
if (!req.http.x-commerce) {
    unset beresp.http.Set-Cookie;
    if (beresp.http.content-type ~ "(text/|/json|/javascript)") {
        if (!beresp.http.Vary ~ "Accept-Encoding") {
            set beresp.http.Vary:Accept-Encoding = "";
        }
        if (req.http.Accept-Encoding == "br") {
            set beresp.brotli = true;
        } else if (req.http.Accept-Encoding == "gzip") {
            set beresp.gzip = true;
        }
    }
    return(deliver);
}
```

Since the `deliver` VCL skips all the subsequent steps, the default compression settings are skipped. The snippet above is the same as in the default VCL, but copied again to be applied to responses that are not going to the Adobe Commerce backend.

### Failover

We can support automatic failover from Edge Delivery Services to Adobe Commerce Luma pages on a 404 in Edge Delivery Services. To do this, add the following in your custom `fetch` snippet:

```txt
if (req.backend == F_edge && http_status_matches(beresp.status, "404")) {
      # See 
      set beresp.http.Vary:restarts = ""; # Add restart to vary key
      set beresp.cacheable = true; # Errors are not cacheable by default, so enable them
      set beresp.ttl = 5s; # Set a short ttl so the unfindable object expires quickly
      set beresp.http.do_failover = "yes";
   }
```

Then, in your custom `recv` snippet:

```txt
if (req.http.try-alt-origin) {
    set req.backend = F_commerce;
    set req.http.x-commerce = "true";
    set req.http.restarts = req.restarts; # Use restart value for vary key
    set req.http.Fastly-Force-Shield = "1";
}
```

Factly-Force-Shield may be required to turn on clustering (not related to shielding despite the name).

Flow of EDS request: In `recv`, hits Edge Delivery Services case, then goes to `miss`, then goes to `fetch`, `fetch` returns 404 and sets retry (as snippet above), and `deliver` calls `restart`.

If we are using Fastly shielding, we need to have `fastly.ff.visits_this_service == 0` in the `deliver` snippet, before `restart`, otherwise it can be that ESI doesn't work.

```txt
if (fastly.ff.visits_this_service == 0 && !req.http.try-alt-origin && resp.http.do_failover == "yes") {
    set req.http.try-alt-origin = "1";
    set req.url = req.http.Magento-Original-URL;
    return (restart);
}
```

It is not recommended to handle all paths that need to be routed to Luma like this, but still hardcode those that are known, in order to reduce load of 404s on Edge Delivery Services.

### API Mesh

API Mesh has a header size limit. You must remove third-party cookies if you're using API mesh. Add this in the graphql section of `recv` snippet:

```txt
if (req.http.Cookie) {
        # Remove all 3rd-party cookies
        # API Mesh has a header size limit
        set req.http.Cookie = ";" + req.http.Cookie;
        set req.http.Cookie = regsuball(req.http.Cookie, "; +", ";");
        set req.http.Cookie = regsuball(req.http.Cookie, ";(PHPSESSID|X-Magento-Vary|form_key|private_content_version|mage-messages|persistent_shopping_cart|fastly_geo_store)=", "; \\1=");
        set req.http.Cookie = regsuball(req.http.Cookie, ";[^ ][^;]*", "");
        set req.http.Cookie = regsuball(req.http.Cookie, "^[; ]+|[; ]+$", "");
        if (req.http.cookie ~ "^\\s*$") {
            unset req.http.cookie;
        }
    }
```

### Branch names on staging

You can enable the use of Edge Delivery Services branches on a staging URL (for example, `branch1.my-staging.com`). Use regex to get the domain name with this addition to the `miss` snippet:

```txt
if (req.backend == F_edge) {
    if (req.http.Host ~ "^([^.]+)\\.([^.]+)\\.lovesac\\.com$") {
        set bereq.http.Host = re.group.1 + "--your-eds-url.aem.page";
    } else {
        set bereq.http.Host = "your-eds-url.aem.live";
    }
    set bereq.http.X-BYO-CDN-Type = "fastly";
    set bereq.http.X-Push-Invalidation = "enabled";
}
```

In the domains configuration, you must use a wildcard. Since the Commerce Admin doesn't let you do this, you must do it using the Fastly CLI (which also shows the wildcard URL in the Admin).

### Maintainance page workaround

The maintainance page can block requests to API Mesh/GraphQL. The solution is to create a VCL snippet with low priority that comes before the maintainance check in VCL and allows GraphQL requests through.

### Mulitple set-cookie headers workaround

There's a known issue with mutliple `set-cookie` headers in API Mesh. See the following snippet for a workaround

```txt
if (req.http.x-mesh == "true") {
    # There's a bug in API MESH that combines multiple set-cookie headers
    # Let's remove these cookies from the response
    declare local var.ignored BOOL;
    set var.ignored = setcookie.delete_by_name(beresp, "private_content_version");
    set var.ignored = setcookie.delete_by_name(beresp, "form_key");
    set var.ignored = setcookie.delete_by_name(beresp, "authentication_flag");
    set var.ignored = setcookie.delete_by_name(beresp, "dataservices_customer_id");
    set var.ignored = setcookie.delete_by_name(beresp, "dataservices_customer_group");
    set var.ignored = setcookie.delete_by_name(beresp, "dataservices_cart_id");
    return (pass);
}
```

:::note
`x-mesh` header is just an example. It would be added in API Mesh to use as determination in routing of VCL (for example, `x-commerce-bypass-fastly-cache`).
:::

## Commerce configuration

If you are using the VCL to do the APEX redirect (`aemshop.net` â†’ `www.aemshop.net` with 801 error), you should do two things in the Adobe Commerce backend:

1. Disable `auto-redirect`.
1. Set the `base_url` and `secure_base_url` settings to your domain, including `www`.

Follow these steps:



1. Log in to the Adobe Commerce Admin.

1. Click **Stores** > _Settings_ > **Configuration** > **General** > **Web**.

1. Expand the **URL options** section.

1. Set **Auto-redirect to Base URL** to **No**.

1. Expand the **Base URLs** section.

1. Set the **Base URL** and **Secure Base URL** to your domain, including `www`.

   For example: `https://www.aemshop.net/`

1. Expand the **Base URLs (Secure)** section.

1. Set the **Secure Base URL** to your domain, including `www`.

   For example: `https://www.aemshop.net/`

1. Click **Save Config**.



## Edge Delivery Service configuration

To obtain a purge API token for Fastly, you must contact Adobe Commerce Customer Support.

Then, follow the instructions in [Setup push invalidation for Fastly](https://www.aem.live/docs/byo-cdn-fastly-setup#setup-push-invalidation-for-fastly). The remaining configuration described on this page is already taken care of by applying the VCL snippets above.

## Validation

To validate your CDN setup, use `curl` requests to check expected responses from the paths you have configured.

### Content encoding, surrogate key, and cache

Validate that surrogate key, cache hits, and content encoding are working as expected by requesting an Edge Delivery Services-served asset from your Commerce domain. Ensure you are checking a warm cache by making the request at least twice. The following examples are to a warmed cache.

Here is an example of validation against an Adobe staging environment:

```bash
curl -sI -H 'Fastly-Debug: 1' https://www.aemshop.net/scripts/aem.js | grep 'x-cache\|surrogate-key\|cache-control'
```

```txt
content-encoding: gzip
surrogate-key: develop--aem-boilerplate-commerce--hlxsites develop--aem-boilerplate-commerce--hlxsites_code E3hjdgev7F5OyPUD
x-cache: MISS, HIT, HIT, HIT
x-cache-hits: 0, 37, 1, 0
```

* `content-encoding`: Should be `gzip` or `br` for things like JS assets and HTML files, which should be encoded from origin.
* `surrogate-key`: Should not be `text`. If the value is `text`, make sure you have correctly configured the `fetch` VCL snippet to return `deliver` for Edge Delivery Servicespaths.

   The reason for this validation step is that the [default Commerce Fastly VCL](https://github.com/fastly/fastly-magento2/blob/fdd616cd0f945530e02e92e594ca00fd7990f557/etc/vcl_snippets/fetch.vcl#L113) sets this. This overwrites the Edge Delivery Services surrogate key, which is required for cache invalidation to work correctly when a page is re-published.

* `x-cache`: Should contain `HIT` entries. The last entry should be `HIT` (`MISS`, `HIT`, `MISS`, `HIT`) is ok.

Also, make sure that you validate `gzip` encoding is applied to HTML pages:

```bash
curl -sI -H 'accept-encoding: gzip, deflate, br, zstd' https://www.aemshop.net | grep content-encoding
```

```txt
content-encoding: gzip
```

```bash
curl -sI -H 'accept-encoding: gzip, deflate, br, zstd' https://www.aemshop.net/index.plain.html | grep content-encoding
```

```txt
content-encoding: gzip
```

Validate the CDN configuration with the BYOCDN [push invalidator tool](https://tools.aem.live/). Additionally, preview and publish a document and validate that the changes are correctly reflected.

```bash
curl -Is --http2 https://www.aemshop.net | grep 'HTTP/2'
```

```txt
HTTP/2 200
```

Validate that all requests are using `HTTP/2` or `HTTP/3` connections.

```bash
curl -Is -L https://aemshop.net | grep location
```

```txt
location: https://www.aemshop.net/
```

To validate the APEX redirect, observe the location header returned by a request to the domain without `www`.

### Image optimization

Validate that images are encoded with the expected format. If you get back `image/jpeg` this indicates an issue, probably Commerce Fastly is rewriting the content type header. You'll need to validate the VCL snippets.

To validate Edge Delivery Services, ensure you check some content expected to be served from the Edge Delivery Services origin (such as the hero banner).

```bash
curl -sI -H "Accept: image/webp" 'https://www.aemshop.net/media_1b6ab8fa5166c1d9ab57a109f4f97b8e950a3ed84.png?width=2000&format=webply&optimize=medium' | grep 'content-type'
```

```txt
content-type: image/webp
```

To validate Commerce, ensure you check some content expected to be served from the Adobe Commerce origin (such as a product image).

```bash
curl -sI  -H "Accept: image/webp" 'https://www.aemshop.net/media/catalog/product/adobestoredata/ADB150.jpg?auto=webp&quality=80&crop=false&fit=cover&width=960&height=1191' | grep 'content-type'
```

```txt
content-type: image/webp
```

### Commerce cache

Ensure that GraphQL `GET` requests result in cache HITs.

```bash
curl -sI 'https://www.aemshop.net/graphql?query=query+STORE_CONFIG_QUERY+%7B+storeConfig+%7B+minicart_display%7D+%7D' | grep x-cache
```

```txt
x-cache: HIT
x-cache-hits: 1
```

### Commerce base URL

Ensure that the base URL change is propagated to Catalog Service. You can do this with a query against your Catalog Service API to verify that the URLs for product images contain the APEX domain, including `www`. This is to prevent a redirect and subsequent load for images not including the APEX domain.

![Commerce base URL](@images/implementation/commerce-base-url.png/)

## Troubleshooting

> **Note:** Fastly VCL and CDN configuration can be a bit overwhelming at first. Here's a collection of troubleshooting steps that might help you if you have problems.

### Fastly API quick reference

With your Fastly API Token you can make requests against the Fastly API for information or data that may be otherwise inaccessible. You can find your API Token in your Commerce Admin view under **Stores** > **Settings** > **Configuration** > **Advanced** > **System** > **Full Page Cache** > **Fastly Configuration**.

Here's a quick reference of things you can do with your API Token. See [Fastly's API documentation](https://www.fastly.com/documentation/reference/api/) for more details.

```bash
# retrieve active version
curl -H "Fastly-Key: API_TOKEN" "https://api.fastly.com/service/SERVICE_ID/version"

# retrieve full, generated VCL
curl -H "Fastly-Key: API_TOKEN" "https://api.fastly.com/service/SERVICE_ID/version/VERSION/generated_vcl"

# retrieve all snippets
curl -H "Fastly-Key: API_TOKEN" "https://api.fastly.com/service/SERVICE_ID/version/VERSION/snippet"
```

### Missing snippets

Fastly maintains a "version" of your snippets remotely on their servers. These versions are never pulled "down" to your Commerce environment, but can be "pushed" from your environment to Fastly. Unintentional local changes can cause things to become out of sync.

For example, renaming a snippet actually creates a new snippet with the new name, and does not delete the old one. You should not rename snippets unless you must. See [this issue](https://github.com/fastly/fastly-magento2/issues/708) for more information.

Your environment stores custom VCL snippets in the `var/vcl_snippets_custom/` directory. If you delete that directory or its contents, you will not be able to view, edit, or modify the snippets, even though they remain active in Fastly."

To resolve this, you should use the Fastly API to "pull" all snippets and then place them back in that folder (with permission **775**). The following table details how to construct the file correctly:

| `var` directory filename | Admin Panel Field | Fastly Fields |
|--------------------------------|----------------------------------------------|--------------------------------------------------------|
| _recv_100_snippetrecv.vcl_ | Type: _recv_  Priority: _100_  Name: _snippetrecv_ | Type: _recv_  Priority: _100_  Name: _magentomodule_snippetrecv_ |

---

# CORS Setup

Cross-Origin Resource Sharing (CORS) is a browser security feature that restricts web pages from making requests to a different domain than the one serving the page. CORS is required when your storefront runs on a different domain or port than your Adobe Commerce backend.

 

> **Note:** CORS should be a last resort for production. Prefer same-origin delivery of the storefront and API (for example, via Fastly VCL) to avoid CORS entirely.

But during development, it's a common scenario for storefronts to run on a different domain or port than the Adobe Commerce backend, so CORS is required. Without CORS, browsers will block cross-origin requests and you'll see errors like the following in the browser console:

```txt
Access to fetch at 'https://commerce.example.com/graphql' from origin 'http://localhost:3000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present
```

## Quick test: Is CORS working?

Adobe Commerce uses `/graphql` as the GraphQL endpoint, and this is the primary endpoint that requires CORS configuration. If you already have CORS configured, test it by replacing `YOUR_STOREFRONT_URL` with your actual frontend URL:

```bash
curl -I -X OPTIONS https://your-commerce-backend.com/graphql \
  -H "Origin: YOUR_STOREFRONT_URL" \
  -H "Access-Control-Request-Method: POST"
```

Look for these headers in the response:
- `Access-Control-Allow-Origin: YOUR_STOREFRONT_URL` (or `*` if using a wildcard)
- `Access-Control-Allow-Methods: GET, POST, OPTIONS`

If you see these headers with your storefront URL, CORS is configured correctly. If not, follow the setup steps below.

## Quick steps



<Task>

### Add CORS support

To add CORS headers to your Adobe Commerce GraphQL endpoints, you have several options:

- **Server configuration**: Configure CORS headers at the web server level ([Nginx](https://enable-cors.org/server_nginx.html), [Apache](https://enable-cors.org/server_apache.html))
- **Third-party module**: Use a community module such as [graycore/magento2-cors](https://github.com/graycoreio/magento2-cors)
- **Custom module**: Implement a custom Adobe Commerce module to add CORS headers

Refer to your chosen implementation's documentation for specific configuration steps.

</Task>

<Task>

### Configure CORS settings

Configure your CORS implementation to allow requests from your storefront domain(s) to your Adobe Commerce GraphQL endpoint.

At minimum, you'll need to configure:
- **Allowed origins**: Your storefront domain(s) (for example, `http://localhost:3000`, `https://your-storefront.com`)
- **Allowed methods**: `GET`, `POST`, `OPTIONS`
- **Allowed headers**: `Content-Type`, `Authorization`, `X-Requested-With`

Refer to your chosen implementation's documentation for specific configuration steps.

</Task>

<Task>

### Test your CORS configuration

Open your storefront in a browser and check the Network tab in DevTools:
- Look for preflight `OPTIONS` requests to your GraphQL endpoint
- Verify the response includes headers like:
  - `Access-Control-Allow-Origin: <your-storefront-url>` (or `*` if using a wildcard)
  - `Access-Control-Allow-Methods: GET, POST, OPTIONS`
  - `Access-Control-Allow-Headers: Content-Type, Authorization`

If configured correctly, your GraphQL requests should succeed without CORS errors.

</Task>



## Common pitfalls

> **Note:** **Forgetting to clear cache:** After changing CORS settings, always run `bin/magento cache:flush`. A stale cache is the primary cause of "it's not working" reports.

**Using `*` with credentials:** You cannot use a wildcard `*` origin when `Allow Credentials` is enabled. Browsers will block the request.

**Missing the `OPTIONS` method:** All CORS requests start with an OPTIONS preflight request. If you forget to include `OPTIONS` in **Allowed Methods**, all CORS requests will fail.

## Next steps

If you encounter issues or need detailed configuration guidance, see [CORS Troubleshooting](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/cors-troubleshooting/)

## References

-  - MDN Web Docs on Cross-Origin Resource Sharing
-  - MDN documentation on common CORS error messages

---

# CORS Troubleshooting

This guide helps you diagnose and resolve CORS issues with Adobe Commerce GraphQL endpoints.



> **Note:** If you need to set up CORS for the first time, see [CORS Setup](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/cors-setup/).

## Common CORS errors

The following are standard CORS errors enforced by browser security policies. These error messages appear in the browser console (DevTools).



<Option>

### No 'Access-Control-Allow-Origin' header

```txt
Access to fetch at 'https://commerce.example.com/graphql' from origin 'http://localhost:3000' 
has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the 
requested resource.
```

#### Cause

CORS headers are not being sent by your Commerce backend. This could mean:
- CORS support is not configured
- The origin is not in the allowed list
- The configuration cache needs to be cleared

#### Solution

- Verify CORS is configured. See [CORS Setup](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/cors-setup/) if not configured yet.
- Add your storefront origin to the allowed origins list
- Clear the cache: `bin/magento cache:flush`

</Option>

<Option>

### Origin not allowed

```txt
Access to fetch at 'https://commerce.example.com/graphql' from origin 'http://localhost:3000' 
has been blocked by CORS policy: The 'Access-Control-Allow-Origin' header has a value 
'https://storefront.example.com' that is not equal to the supplied origin.
```

#### Cause

The requesting origin is not in the allowed origins list.

#### Solution

Add the exact origin (including protocol and port) to the Allowed Origins configuration.

</Option>

<Option>

### Credentials flag issue

```txt
Access to fetch at 'https://commerce.example.com/graphql' from origin 'http://localhost:3000' 
has been blocked by CORS policy: The value of the 'Access-Control-Allow-Origin' header in the 
response must not be the wildcard '*' when the request's credentials mode is 'include'.
```

#### Cause

You have `Allow Credentials` enabled but are using `*` for allowed origins.

#### Solution

Replace `*` with specific origins when credentials are required.

</Option>



### Common issues

If you encounter CORS errors after installing `adobe-commerce/storefront-compatibility`, verify that your CORS implementation is compatible with Adobe Commerce Storefronts. If using the graycore module, ensure v2.x or later is installed.

## Debug checklist



<Option>

### Verify CORS is configured

If using a CORS module, check that it's installed and enabled:

```bash
# List all enabled modules
bin/magento module:status | grep -i cors
```

If using a custom CORS implementation, verify your code is deployed and active.

</Option>

<Option>

### Verify CORS configuration

Check your CORS configuration and confirm:
- Your storefront origin is in the Allowed Origins list
- Origins match exactly (including protocol and port)
- No trailing slashes in origins
- Allowed Methods includes `OPTIONS`
- Allowed Headers includes all headers your storefront sends

See [CORS Setup](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/cors-setup/) for configuration details.

</Option>

<Option>

### Inspect browser network traffic

Open DevTools > Network tab and look for:

#### Preflight OPTIONS request

```txt
Request URL: https://commerce.example.com/graphql
Request Method: OPTIONS
```

Expected response headers:
```txt
Access-Control-Allow-Origin: http://localhost:3000
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Max-Age: 86400
```

#### Actual GraphQL POST request

```txt
Request URL: https://commerce.example.com/graphql
Request Method: POST
```

Expected response headers:
```txt
Access-Control-Allow-Origin: http://localhost:3000
Access-Control-Allow-Credentials: true
```

</Option>

<Option>

### Check server logs

If CORS headers are present but requests still fail:

```bash
tail -f var/log/system.log
tail -f var/log/exception.log
```

Look for PHP errors, GraphQL exceptions, or module conflicts.

</Option>

<Option>

### Clear all caches

After any configuration changes:

```bash
bin/magento cache:flush
bin/magento cache:clean
```

Some CORS configurations may also be cached in Varnish/Fastly if applicable.

</Option>



## Distinguishing CORS errors from server-side errors

When debugging, it's important to distinguish CORS policy failures from server-side GraphQL exceptions. Here's an example of a server-side error that might be mistaken for a CORS issue: 

```txt
{
  "message": "Internal server error",
  "extensions": {
    "debugMessage": "Magento\\InventoryConfiguration\\Model\\IsSourceItemManagementAllowedForProductType\\Interceptor::execute(): Argument #1 ($productType) must be of type string, null given"
  }
}
```

This indicates a PHP/GraphQL issue (inventory configuration or compatibility) and not a missing Access-Control-Allow-Origin header.

## Edge cases and special scenarios

### Docker and containerized environments

When running Commerce in Docker, you may need to add multiple origin variations:

```txt
http://localhost:3000
http://127.0.0.1:3000
http://host.docker.internal:3000
```

> **Note:** Docker networking can cause your browser to use different hostnames for the same service, so you need to add all variations.

### Multiple storefronts

For multiple storefronts accessing the same Commerce backend, add each origin separately:

```txt
https://storefront-us.example.com
https://storefront-eu.example.com
https://storefront-asia.example.com
```

Each storefront is treated as a separate origin and must be explicitly allowed.

## Production best practices

The recommended production approach is to avoid CORS entirely by serving both the storefront and the backend from the same domain using a CDN proxy.

### Same-origin architecture (recommended)

Serve both your storefront and Commerce backend from the same domain:

- Storefront: `https://example.com` â†’ CDN serves static assets
- GraphQL API: `https://example.com/graphql` â†’ CDN proxies to Commerce backend

This requires configuring your CDN to proxy `/graphql` requests to your Commerce backend.

**Benefits:**
- No CORS complexity
- Better performance (fewer preflight requests)
- Simpler security model
- Better caching control

**Implementation approaches:**



1. **Fastly VCL routing:**
   Configure Fastly to route GraphQL requests to your Commerce backend using VCL (Varnish Configuration Language). The VCL detects requests to `/graphql` and proxies them to your backend origin while serving other requests from your storefront origin.

2. **Cloudflare Workers / CDN Edge Functions:**
   Use edge functions to route API requests to your backend dynamically.

3. **Reverse proxy (Nginx/Apache):**
   Configure your web server to proxy `/graphql` requests to the backend.



**Note:** This approach requires CDN/infrastructure expertise. If you don't have these resources, use CORS configuration instead.

### CORS configuration

If you must use different domains (for example, `storefront.example.com` â†’ `commerce.example.com`), use CORS configuration. Use specific allowed origins for single production domains, or a wildcard `*` when you have multiple dynamic preview URLs (such as Edge Delivery Services branch previews).

## References

### CORS standards and specifications

-  - MDN Web Docs on Cross-Origin Resource Sharing
-  - MDN documentation on common CORS error messages
-  - Complete list of CORS-related HTTP headers
-  - How browsers use OPTIONS requests for CORS

### Adobe Commerce

-  - Official documentation for Magento CLI commands used in this guide
-  - GraphQL API documentation

### Additional tools and platforms

-  - PHP dependency manager used for module installation
-  - Understanding Docker hostname resolution for CORS origins
-  - For implementing same-origin architecture with Fastly CDN routing

---

# Gated content

If your site is not managed by Adobe Commerce, you might want to restrict access to certain content, such as videos, images, or pages on your site. This content resides on the edge and cannot be controlled using customer segments or other Commerce functionality. You can restrict access to these non-Commerce assets using gated content.

## Big picture

There are several things to know to implement this feature.

* Gated content is displayed only if the customer is logged in and their authentication token is valid. Anonymous users cannot access gated content.

* You must define the gated content. In most cases, you define the path to the gated content in the `header` document. This file contains a list of URLs that are gated and defines a key/value pair for your custom code to evaluate. (You can also hardcode URLs in your custom code, but this information is easier to maintain in the spreadsheet.) The spreadsheet contains three columns:

  * `url` - The path to the gated content. Wildcards are supported.
  * `key` - Any key that you want to use to evaluate whether the content is gated.
  * `value` - `True` or other value to be evaluated.

* You must create custom code that evaluates whether the content wants access is gated. CDNs typically do not provide the ability to evaluate whether a user is authenticated. As a result, you must implement an auxiliary service, such as Fastly Compute, Amazon Lambda, or Cloudflare workers to perform the evaluation. This code must be able to send an authentication request to Adobe Commerce and process the result. The request is typically a simple GraphQL query, such as the `customer` query, but you can use any query or mutation that checks if the customer is authenticated.

## Workflow

The following diagram illustrates the workflow when gated content is enabled.


![Gated content workflow](@images/gated-content.svg/)


The shopper requests a page on the storefront. The request is sent to the CDN (Fastly in this case), which then routes it to Edge Delivery Services. Edge Delivery Services returns the requested document with headers defined in the `header` document. Fastly Compute checks whether the requested page is considered gated content based on the headers returned by Edge Delivery Services or by comparing it with a hardcoded list of gated content. If the header defined in the `header` document is not present, or if the requested URL is not in the hardcoded gated content list, the request is processed normally.

If the requested page is gated, the Fastly Compute code uses the customer token to construct an authorization request to Adobe Commerce. If the customer is authenticated, the request is allowed to pass through. If the customer is not authenticated, the request is redirected to a fallback page, such as a login page.

## Example implementation

You can [download a sample solution](https://experienceleague.adobe.com/developer/commerce/storefront/samples/fastly-compute-sample.zip/) that provides an outline of how to implement gated content using Fastly Compute. This sample is based on Fastly's [Default starter kit for JavaScript](https://www.fastly.com/documentation/solutions/starters/compute-starter-kit-javascript-default/).

> **Note:** Adobe does not support this example implementation. It is provided as a reference only.

The README provides an overview of the solution and how to install the starter kit. The `index.js` file contains a Fastly Compute@Edge script that handles incoming HTTP requests and performs user authentication for specific protected URLs.

---

# Overview

Setting up an Adobe Commerce storefront project is similar to other Edge Delivery Services projects. The main difference is that you need to connect your storefront to your Adobe Commerce backend.

## Big picture

Launching a headless Adobe Commerce storefront on Edge Delivery Services requires some basic setup before you do any custom development. Adobe recommends starting with the [Commerce boilerplate](https://github.com/hlxsites/aem-boilerplate-commerce) to simplify the process. The Commerce boilerplate GitHub repsitory is a fork of the [Edge Delivery Services boilerplate](https://github.com/adobe/aem-boilerplate). It includes additional code specifically for Commerce use cases.

:::note[Note]
All implementation guidance in this documentation is based on the Commerce boilerplate.
:::

The [Create your storefront tutorial](https://experienceleague.adobe.com/developer/commerce/storefront/get-started/) provides all the information that you need to quickly set up a starter project that uses a pre-configured sample Adobe Commerce backend. After you complete the tutorial, you can [connect](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/commerce-configuration/) your own Adobe Commerce backend to the project.

Here's an overview of the process:


  ![Project setup process.](@images/implementation/setup-overview-v2.svg/)




1. **Storefront configuration**: Connect your Edge Delivery Services storefront to your Adobe Commerce backend.
1. **CDN configuration**: Set up the content delivery network (CDN) to deliver your project.
1. **Storefront compatibility package**: Install the Storefront Compatibility Package to enable drop-in component functionality.

---

# Multi-store implementation walkthrough

This tutorial provides a comprehensive walkthrough of setting up multi-store functionality for an Adobe Commerce storefront using Edge Delivery Services. It demonstrates the complete process from initial planning to final validation, using a real-world scenario where the Acme brand expands from the United States to the Canadian market.

## Overview

In this walkthrough, we'll demonstrate how to:
- Set up the necessary file structures for multi-store views
- Configure store views in Adobe Commerce Admin
- Update storefront configuration files
- Preview and publish localized content
- Configure the store switcher for proper store view display

## Scenario

The Acme brand is expanding its international presence and wants to target the Canadian market with two new locales:
- **Canadian English** (en-ca)
- **Canadian French** (fr-ca)

## Prerequisites

Before beginning this implementation, ensure:
- Your storefront repository is linked to Document Authoring environment (da.live) via Edge Delivery Services
- You have access to Adobe Commerce Admin for [store view configuration](https://experienceleague.adobe.com/en/docs/commerce-admin/stores-sales/site-store/store-views)
- Your `fstab.yaml` file is properly configured
- Your `config.json` file is linked to the Adobe Commerce instance

## Implementation Steps



<Task>
### Verify Environment Setup

Before implementing multi-store functionality, confirm your environment is properly configured.

<Steps>
1. **Check the `fstab.yaml` file** in your repository to ensure it's linked to the Document Authoring environment at da.live, as described in 

2. **Verify the `config.json` file** is connected to your Adobe Commerce instance to enable content preview, publishing, and editing as described in 

</Steps>

<Aside type="caution" title="Environment setup">
This verification step is crucial as it ensures you can properly preview and publish content for your new store views.
</Aside>

</Task>

<Task>
### Create Content Folder Structure

Set up the folder structure in your Document Authoring environment to support the new store views.

<Steps>
1. **Navigate to the connected content folder** in da.live.

2. **Create the Canadian English folder**:
   - Select "New folder"
   - Name it `en-ca`

3. **Create the French folder**:
   - Select "New folder"  
   - Name it `fr-ca`

4. **Copy content from the main root folder** into each new store view folder:
   - Select all content from the main root folder
   - Copy the content
   - Navigate to the `en-ca` folder and paste
   - Repeat for the `fr-ca` folder
</Steps>

<Aside type="note" title="Copying content">
Exclude the newly created store view folders when copying content to avoid nested duplicates.
</Aside>

</Task>

<Task>
### Configure Adobe Commerce Store Views

Create the corresponding store views in Adobe Commerce Admin to match your content folder structure.

<Steps>
1. **Access Adobe Commerce Admin** and navigate to Stores > Settings > All Stores.

2. **Create the Canadian English store view**:
   - Follow the store view creation process
   - Configure as: one website, one store, one store view
   - Set the store view code to match your folder name (`en-ca`)

3. **Create the Canadian French store view**:
   - Repeat the process for the French locale
   - Set the store view code to match your folder name (`fr-ca`)
</Steps>

<Aside type="note" title="Store view codes">
The store view codes in Adobe Commerce Admin must exactly match the folder names created in da.live for proper integration.
</Aside>

</Task>

<Task>
### Update Storefront Configuration

Modify your project's configuration files to support the new store views.

<Steps>
1. **Update the `fstab.yaml` file** to include new folder mappings:

    ```yaml
    mountpoints:
    /: https://example.mountpoint.com/:f:/r/sites/myproject

    folders:
    /en-ca/products/: /en-ca/products/default
    /fr-ca/products/: /fr-ca/products/default
    ```

2. **Update the `config.json` file** to include new entries under the public object:

    ```json
    {
      "public": {
        "default": {
        // default configuration
        },
        "/en-ca/": {
            "headers": {
               "all": {
                  "Store": "en-ca"
               },
               "cs": {
                  "Magento-Store-Code": "ca-store",
                  "Magento-Website-Code": "base",
                  "Magento-Store-View-Code": "fr-ca"
               }
            }
         },
          "/ca-en/": {
            "headers": {
               "all": {
                  "Store": "ca-en"
               },
               "cs": {
                  "Magento-Store-Code": "ca-store",
                  "Magento-Website-Code": "base",
                  "Magento-Store-View-Code": "en-ca"
               }
            }
         }
      }
    }
    ```

3. **Ensure header values match** what was created in Adobe Commerce Admin store settings to properly connect store views to file structures.
</Steps>

</Task>

<Task>
### Preview and Validate Content

Test your new store views to ensure proper functionality before publishing.

<Steps>
1. **Push configuration changes** to your storefront repository.

2. **Return to the content files** in both `en-ca` and `fr-ca` folders in da.live.

3. **Preview content files**:
   - Navigate to the `en-ca` folder
   - Open the `index` file
   - Click "Preview" to test the store view

4. **Verify configuration in browser**:
   - Check the URL structure includes the store view path
   - Open browser Developer Tools
   - Navigate to Application > Session Storage
   - Verify the config shows the correct headers you added:
     - `magento-store-code`
     - `magento-website-code` 
     - `magento-store-view-code`
</Steps>

<Aside type="note" title="Session storage verification">
The session storage verification confirms that your configuration is properly loaded and the store view is correctly identified.
</Aside>

</Task>

<Task>
### Configure Store Switcher

Update the store switcher to properly reflect the current store view for customers.

<Steps>
1. **Navigate to the store switcher file** in the `en-ca` content folder.

2. **Update the store switcher structure** to prioritize the current store view:
   - Move "Canada English" to the top of the list
   - Ensure proper formatting and links
   - Example structure:
   ```
   - Canada (CAD)
     - [Canada (EN)](https://your-site.com/en-ca/)
     - [Canada (FR)](https://your-site.com/fr-ca/)
   - United States (USD)
     - [United States (USD)](https://your-site.com/en/)
   ```

3. **Publish the updated store switcher**:
   - Click "Publish" on the store switcher file
   - This updates the footer display for customers

4. **Verify the store switcher display**:
   - Return to your preview of the Canadian English store
   - Check that the store switcher now correctly shows the customer is on the Canadian English store view
   - Confirm customers can see and select other available stores
</Steps>

</Task>

<Task>
### Final Validation and Handoff

Complete the implementation with thorough testing and team coordination.

<Steps>
1. **Test all store views** to ensure:
   - Proper URL structure
   - Correct content loading
   - Functional store switcher
   - Accurate header configuration

2. **Prepare for localization**:
   - Inform the marketing team that content folders are ready for translation
   - Provide directory structure documentation
   - Share access to the `fr-ca` folder for French translations

3. **Document the implementation** for future reference and team knowledge sharing.
</Steps>

<Aside type="tip" title="Success!">
Your multi-store infrastructure is now ready to support multiple locales with proper content management and customer experience.
</Aside>

</Task>



## Key Configuration Details

### Headers Configuration

The headers section in your `config.json` is critical for proper store view functionality:

- **`magento-store-code`**: Must match the store code from Adobe Commerce Admin
- **`magento-website-code`**: Typically "base" for single-website setups
- **`magento-store-view-code`**: Must match the store view code from Adobe Commerce Admin

### Folder Structure Best Practices

- Use clear, consistent naming conventions (e.g., `en-ca`, `fr-ca`)
- Ensure folder names can be used in web URLs
- Match folder names exactly with Adobe Commerce store view codes
- Maintain the same content structure across all store views

### Store Switcher Configuration

- Each store view should have its own `store-switcher` file
- Prioritize the current store view in the display order
- Ensure all links point to the correct store view URLs
- Test the switcher functionality across all store views

## Next Steps

After completing this implementation:

1. **Marketing Team Handoff**: Share the content folders with your marketing team for localization and translation work
2. **Content Translation**: Begin translating content in the `fr-ca` folder for the French Canadian market
3. **Testing**: Conduct thorough testing across all store views and customer scenarios
4. **Launch Planning**: Coordinate the launch of new store views with marketing and business teams

This multi-store setup provides a solid foundation for international expansion while maintaining a unified codebase and streamlined content management process.

---

# Storefront Compatibility Package Installation

The Storefront Compatibility Package contains changes to the Adobe Commerce codebase that enable drop-in component functionality. On [Adobe Commerce as a Cloud Service](https://experienceleague.adobe.com/en/docs/commerce/cloud-service/overview), it is installed and updated automatically.



## Installation

:::note[Note]
You must have Adobe Commerce 2.4.7 or 2.4.8 installed. Magento Open Source is not supported.
:::


  <TabItem label="Cloud infrastructure">

Use this method to install the Storefront Compatibility Package using the Cloud infrastructure.

    1. On your local workstation, change to the project directory for your Adobe Commerce on cloud infrastructure project.

    1. Check out the environment branch to update using the Adobe Commerce Cloud CLI.

       ```bash
       magento-cloud environment:checkout <environment-id>
       ```

    1. Add the Storefront Compatibility module.

       Use the appropriate package version based on your Adobe Commerce version:

       For Adobe Commerce 2.4.7, run:

       ```bash
       composer require adobe-commerce/storefront-compatibility:4.7.10
       ```

       For Adobe Commerce 2.4.8, run:

       ```bash
       composer require adobe-commerce/storefront-compatibility:4.8.8
       ```

       To check the latest version of the Storefront Compatibility Package, go to the [changelog](https://experienceleague.adobe.com/developer/commerce/storefront/releases/changelog/).

    1. Update package dependencies.

       ```bash
       composer update "adobe-commerce/storefront-compatibility"
       ```

    1. Commit and push code changes for the `composer.json` and `composer.lock` files.

    1. Add, commit, and push the code changes for the `composer.json` and `composer.lock` files to the cloud environment

       ```bash
       git add -A
       git commit -m "Add module"
       git push origin <branch-name>
       ```

       Pushing the updates to the cloud environment initiates the [Commerce cloud deployment process](https://experienceleague.adobe.com/en/docs/commerce-cloud-service/user-guide/develop/deploy/process) to apply the changes. Check the deployment status from the [deploy log](https://experienceleague.adobe.com/en/docs/commerce-cloud-service/user-guide/develop/test/log-locations#deploy-log).

  </TabItem>
  
  <TabItem label="On premises">

Use this method to install the Storefront Compatibility Package for an on-premises instance.

1. Use Composer to add the package module to your project:

   Use the appropriate package version based on your Adobe Commerce version:

   For Adobe Commerce 2.4.7, run:

   ```bash
   composer require adobe-commerce/storefront-compatibility:4.7.10
   ```

   For Adobe Commerce 2.4.8, run:

   ```bash
   composer require adobe-commerce/storefront-compatibility:4.8.8
   ```

   To check the latest version of the Storefront Compatibility Package, go to the [changelog](https://experienceleague.adobe.com/developer/commerce/storefront/releases/changelog/).

1. Upgrade Adobe Commerce:

   ```bash
   bin/magento setup:upgrade
   ```

  </TabItem>



## Update the package

Use the following procedure to update patch versions of the Storefront Compatibility Package.

1. Run the following command to update the package:

   ```bash
   composer update adobe-commerce/storefront-compatibility
   ```

1. Run the following commands to upgrade Adobe Commerce and clear the cache.

   ```bash
   bin/magento setup:upgrade && bin/magento cache:clean
   ```

---

# Storefront Compatibility Package for Adobe Commerce 2.4.7

The Storefront Compatibility Package contains changes to the Adobe Commerce 2.4.7 codebase that enable drop-in component functionality.

Most of these changes enhance the Adobe Commerce GraphQL schema. However, miscellaneous bugfixes are also included. The drop-in components require this package.

:::note[Note]
This Storefront Compatibility Package can be installed on Adobe Commerce 2.4.7 only. Fixes in this package are already included in Adobe Commerce 2.4.8. Lower versions of Adobe Commerce are not supported. Magento Open Source is not supported.
:::

## Major features

The Storefront Compatibility Package defines the following queries and mutations:

- [`clearWishlist`](https://developer.adobe.com/commerce/webapi/graphql/schema/wishlist/mutations/clear/) mutation - Allows all items to be removed from a wishlist in a single action.

- [`confirmCancelOrder`](https://developer.adobe.com/commerce/webapi/graphql/schema/orders/mutations/confirm-cancel-order/) mutation - Cancels the specified order for a guest.

- [`confirmReturn`](https://developer.adobe.com/commerce/webapi/graphql/schema/orders/mutations/confirm-return/) mutation - Confirms a guest or customer return request.

- [`customerGroup`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/customer-group/) query - Retrieves information about specified customer group.

- [`customerSegments`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/customer-segments/) query - Retrieves information about specified customer segment.

- [`exchangeExternalCustomerToken`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/exchange-external-customer-token/) mutation - Authenticates users using an integration token and returns both the customer token and associated customer data

- [`estimateTotals`](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/estimate-totals/) mutation - Estimates totals for cart based on the address.

- [`generateCustomerToken`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/generate-token/) mutation - Creates a new customer token.

- [`guestOrder` query](https://developer.adobe.com/commerce/webapi/graphql/schema/orders/queries/guest-order/) - Retrieves information about a guest order using an order number, email, and billing last name as input.

- [`guestOrderByToken` query](https://developer.adobe.com/commerce/webapi/graphql/schema/orders/queries/guest-order-by-token/) - Retrieves information about a guest order based on an order token.

- [`recaptchaFormConfig`](https://developer.adobe.com/commerce/webapi/graphql/schema/store/queries/recaptcha-form-config/) query - Returns information about the reCaptcha configuration for the specified form type.

- [`requestGuestOrderCancel`](https://developer.adobe.com/commerce/webapi/graphql/schema/orders/mutations/request-guest-order-cancel/) mutation - Cancels the specified guest order.

- [`requestGuestReturn`](https://developer.adobe.com/commerce/webapi/graphql/schema/orders/mutations/request-guest-return/) mutation - Requests a return for a specified order on behalf of a guest.

- [`resendConfirmationEmail`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/resend-confirmation-email/) mutation - Resends a confirmation email to the specified customer upon request.

## Release information

To see release notes for each version of the Storefront Compatibility Package, go to the [changelog](https://experienceleague.adobe.com/developer/commerce/storefront/releases/changelog/).

---

# Storefront Compatibility Package for Adobe Commerce 2.4.8

The Storefront Compatibility Package contains changes to the Adobe Commerce 2.4.8 codebase that enable drop-in component functionality.

Most of these changes enhance the Adobe Commerce GraphQL schema. However, miscellaneous bugfixes are also included. The drop-in components require this package.

:::note[Note]
This Storefront Compatibility Package can be installed on Adobe Commerce 2.4.8 only. Fixes in this package will be included automatically in Adobe Commerce 2.4.9. Lower versions of Adobe Commerce are not supported. Magento Open Source is not supported.
:::

## Major features

The Storefront Compatibility Package defines the following queries and mutations:

- [`clearWishlist`](https://developer.adobe.com/commerce/webapi/graphql/schema/wishlist/mutations/clear/) mutation - Allows all items to be removed from a wishlist in a single action.

- [`customerGroup`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/customer-group/) query - Retrieves information about specified customer group.

- [`customerSegments`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/customer-segments/) query - Retrieves information about specified customer segment.

- `deleteCustomerAddressV2` mutation - Deletes a billing or shipping address of a customer using customer UID as input.

- [`exchangeExternalCustomerToken`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/exchange-external-customer-token/) mutation - Authenticates users via an integration token and returns both the customer token and associated customer data

- `updateCustomerAddressV2` mutation - Updates a billing or shipping address of a customer using customer UID as input.

## Release information

To see release notes for each version of the Storefront Compatibility Package, go to the [changelog](https://experienceleague.adobe.com/developer/commerce/storefront/releases/changelog/).

---

# Learn the Storefront architecture

This overview guides you to the right resources for building headless Adobe Commerce storefronts with [Edge Delivery Services](https://www.aem.live/).

## Big picture

Headless Adobe Commerce storefronts on Edge Delivery Services are built using a composable architecture with domain-driven commerce components called [drop-in components](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/introduction/). This architecture allows you to build and deploy a storefront that is composed of multiple Adobe services, each with its own responsibility. Drop-in components are connected through APIs and can be developed, tested, and deployed independently for faster development cycles.

Drop-in components use [Adobe Commerce](https://experienceleague.adobe.com/en/docs/commerce/catalog-service/installation#access-the-service) APIs to provide data and functionality. These components are reusable across projects and integrate out-of-the-box with Edge Delivery Services through the [Commerce boilerplate](https://github.com/hlxsites/aem-boilerplate-commerce). Adobe Commerce storefronts on Edge Delivery Services support doc-based authoring, enabling business users to manage content without developer help.

The following diagram illustrates the composable architecture of a headless Adobe Commerce storefront on Edge Delivery Services:


  ![Composable architecture of a headless Adobe Commerce storefront on Edge Delivery
  Services.](@images/implementation/Architecture.svg/)


:::note
Although not represented in this diagram, [API Mesh for Adobe Developer App Builder](https://developer.adobe.com/graphql-mesh-gateway/) is an option for integrating multiple APIs into a single API endpoint. It can be used to aggregate data from multiple APIs and provide a single endpoint for the storefront to consume.
:::

## Storefront

The storefront is the front-end layer of your Adobe Commerce site. It is responsible for rendering the user interface and providing a seamless shopping experience for customers. The storefront is built using a combination of drop-in components and front-end blocks that are connected to Adobe Commerce and other services through APIs and hosted on Edge Delivery Services.

The Commerce boilerplate provides an integrated set of drop-in components that you can use to build a headless Adobe Commerce storefront on Edge Delivery Services. See the [Quick Start overview](https://experienceleague.adobe.com/developer/commerce/storefront/get-started/) for more information.

> **Note:** You can reuse parts of an existing storefront with an Edge Delivery Services storefront by
  connecting them with [Luma Bridge](https://experienceleague.adobe.com/developer/commerce/storefront/setup/discovery/luma-bridge/).

## Drop-in components

[Drop-in components](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/introduction/) are domain-driven commerce components that provide specific functionality for your storefront. They are designed to be reusable and can be shared across multiple projects. Drop-in components are connected to Adobe Commerce and other services through APIs and can be developed, tested, and deployed independently for faster development cycles.

You can find the integration patterns for drop-in components as pull requests in the [Commerce boilerplate repository](https://github.com/hlxsites/aem-boilerplate-commerce).
The source code of drop-in components is private. You can add them to your project as NPM packages:

- `@dropins/storefront-account`
- `@dropins/storefront-auth`
- `@dropins/storefront-cart`
- `@dropins/storefront-checkout`
- `@dropins/storefront-order`
- `@dropins/storefront-payment-services`
- `@dropins/storefront-pdp`
- `@dropins/storefront-recommendations`
- `@dropins/storefront-wishlist`
- `@dropins/storefront-personalization`
- `@dropins/storefront-product-discovery`

:::note
Adobe recommends using the documented [extension](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/extending/) patterns for drop-in components.
:::

## Front-end blocks

Blocks are the fundamental parts of a page delivered by Edge Delivery Services. A block encapsulates styling and code that drives the logical components of pages.

Edge Delivery Services comes with a comprehensive library of predefined "content" and "commerce" blocks, which can be customized to meet your project needs. Code for Edge Delivery Services projects is managed in GitHub. The code is then deployed to the Edge Delivery Services platform, where it is hosted and served to end users.

### Content blocks

The Edge Delivery Services components that provide the content and layout for non-commerce pages on the storefront. These include Cards, Columns, Headers, Footers, and many more. See [block collection](https://www.aem.live/developer/block-collection) for more information.

### Commerce blocks

Compared to content blocks, commerce blocks enable Adobe Commerce functionality (such as cart, checkout, and account) and can become quite complex. They are built using the same principles as content blocks but are more tightly integrated with Adobe Commerce APIs.

Using a frontend framework can help manage the complexity. In the Commerce boilerplate, you can find examples of blocks that use a buildless version of [Preact](https://preactjs.com/) and [HTM](https://github.com/developit/htm). You should only use it for blocks that require complex state management with different render states. Otherwise, stick with plain JavaScript.

Use the [existing blocks](https://experienceleague.adobe.com/developer/commerce/storefront/get-started/boilerplate-project/) in the Commerce boilerplate as a reference (for example, teaser and product recommendations). If you want to use React, it's possible, but not recommended. React is usually too heavy (size + execution) to achieve perfect Lighthouse scores.

## Adobe Commerce

Adobe Commerce is the backend system that powers your Commerce storefront. You must use version 2.4.7 or later with the storefront compatibility package installed.

Before starting the project, ensure that your Adobe Commerce backend meets the following requirements:

- **Product license**: Cloud or on-premises (Magento Open Source is not supported)
- **Version**: v2.4.7 or later
- **PHP**: 8.3/8.2 for Adobe Commerce 2.4.7
- **Storefront services**: Ensure that the latest version of following services are installed and configured:
  - Data Connection service
  - Services Connector
  - Catalog Service
  - Live Search
  - Product Recommendations

:::note
The following links provide the requirements and installation procedures for your Adobe Commerce backend:

- [System requirements for cloud infrastructure](https://experienceleague.adobe.com/en/docs/commerce-operations/installation-guide/system-requirements)
- [Setup for Commerce on cloud infrastructure](https://experienceleague.adobe.com/en/docs/commerce-cloud-service/user-guide/overview)
  :::

## Storefront Compatibility package

The [Storefront Compatibility package](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/storefront-compatibility/v248/) extends the GraphQL schema provided with Adobe Commerce. It provides new mutations and adds missing fields that are needed to implement low-funnel drop-in components, such as the cart, checkout, user account, and order drop-in components.

## Storefront services

When connecting your storefront drop-in components to your own instance of Adobe Commerce, you must ensure that your Commmerce backend is configured with the services described here. These services are required for Commerce drop-in components to function properly.

:::note[Adobe Commerce Services Guides]
For a complete list of merchandising services available for your Adobe Commerce storefront, refer to the [Adobe Commerce Services Guides](https://experienceleague.adobe.com/en/docs/commerce/user-guides/home). Direct links to the required services are provided below.
:::

Storefront services are a set of multi-tenant services (shared app, many users, separate data) that provide access to storefront data via GraphQL APIs. These services are very fast and are not tied to scaling constraints of a Commerce environment. They provide read-only access to catalog data, which can drive product detail and list pages, search, navigation, and product recommendations. [Synchronized data](https://experienceleague.adobe.com/en/docs/commerce/user-guides/integration-services/saas) is stored in a "SaaS data space" available through Adobe IMS.

Availability and setup of these services are a hard requirement for building a storefront on Edge Delivery Services because only these APIs provide the performance to build sites with a 100 Lighthouse score. The storefront services APIs are available in addition to the core Adobe Commerce [GraphQL APIs](https://developer.adobe.com/commerce/webapi/graphql/).

This page provides an overview of the services required for your Adobe Commerce storefront.



<Task>

### Data Connection service

The Data Connection extension connects your Adobe Commerce storefront to the Adobe Experience Platform and the Edge Network so that you can enrich and personalize the shopping experience for your customers. Refer to the [Data Connection Guide](https://experienceleague.adobe.com/en/docs/commerce/data-connection/overview) for details and installation instructions.

</Task>

<Task>

### Services Connector

The Services Connector connects your Commerce storefront to the Commerce backend services listed below. Refer to the [Commerce Services Connector Guide](https://experienceleague.adobe.com/en/docs/commerce/user-guides/integration-services/saas) for details and installation instructions.

</Task>

<Task>
### Catalog Service

The Catalog Service module provides fast read-only access to Commerce catalog data. The product details drop-in component requires this service to render product data in the storefront. Refer to the [Catalog Service Guide](https://experienceleague.adobe.com/en/docs/commerce/catalog-service/guide-overview) for details and installation instructions.

</Task>

<Task>
### Live Search

The [Live Search](https://experienceleague.adobe.com/en/docs/commerce/live-search/overview) service replaces the default Commerce catalog search. This service powers the [Product Discovery](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/) drop-in component, which provides a variety of customizable controls to showcase your products and build interactive experiences that engage customers.

Live Search uses events to power search algorithms such as "Most Viewed" and "Viewed This, Viewed That". For headless implementations, learn how to [set up eventing](https://experienceleague.adobe.com/en/docs/commerce/live-search/events) for your storefront.

:::caution[Multiple stores in a single Adobe Commerce environment]
When using a single Adobe Commerce environment for multiple stores and only a single store should be migrated to Edge Delivery Services, you may need to contact Adobe Commerce Support to ensure that Live Search is activated without disabling Elasticsearch, which should continue to drive the search of the other stores.
:::

</Task>

<Task>
### Product Recommendations

Product Recommendations uses artificial intelligence and machine-learning algorithms ([Adobe Sensei](https://business.adobe.com/products/sensei/adobe-sensei.html)) to create personalized storefront experiences. While not a strict requirement, we recommended it for Commerce storefronts. Refer to the [Product Recommendations setup](https://experienceleague.adobe.com/developer/commerce/storefront/merchants/get-started/product-recommendations/) for details.

It provides data for product recommendations for the current shopper context and surfaces "units" such as "Customers who viewed this product also viewed" and can be placed in several areas of the site. You can configure the behavior of the service in Adobe Commerce Admin.

Similar to Live Search, Product Recommendations uses events for collecting data to power recommendations. Learn how to [implement eventing](https://experienceleague.adobe.com/en/docs/commerce/product-recommendations/developer/events) for your storefront.

</Task>


## Edge Delivery Services

Edge Delivery Services is a cloud-based content delivery network (CDN) that provides a scalable, secure, and high-performance platform for delivering your Adobe Commerce storefront to customers around the world. It is designed to deliver dynamic content at the edge, close to the end user, to reduce latency and improve performance.

## Commerce Boilerplate Architecture

The Commerce Boilerplate follows a modular architecture that separates core AEM functionality from commerce-specific features. This separation ensures maintainability and alignment with the upstream AEM Boilerplate while providing robust commerce capabilities.

### From Core Scripts to Commerce Blocks

The [Commerce Boilerplate](https://github.com/hlxsites/aem-boilerplate-commerce) is organized into four main layers that build on each other to deliver a modular, maintainable storefront architecture:

1. **scripts.js** â€“ The foundation. Handles core AEM page loading, block decoration, font loading, and orchestration of eager, lazy, and delayed loading. This file aligns closely with the upstream [AEM Boilerplate](https://github.com/adobe/aem-boilerplate) and is designed for global, site-wide functionality. It also supports extensibility for developers who want to introduce global DOM decorators, integrate third-party plugins such as experimentation tools, or run eager code on page load.

2. **commerce.js** â€“ The commerce engine. Contains all Commerce Boilerplate-specific logic and tooling, including backend connections, template handling, page type detection, Adobe Data Layer initialization, and commerce utilities. This layer centralizes all commerce features and keeps them distinct from core AEM logic.

3. **Initializers** â€“ A directory of scripts that initialize commerce drop-in components (such as account, cart, order, personalization, etc.). Each script is responsible for bootstrapping its respective feature, wiring it to the storefront, and ensuring it integrates with the rest of the application.

4. **Blocks**
   - **AEM Blocks**: Authored in **DA.live**, Google Docs, or Microsoft Word using tables. Rendered server-side as basic HTML `<divs>` and decorated client-side. Developers can enrich these blocks with semantic HTML, accessibility attributes, and dynamic DOM transformations.
   - **Commerce Blocks**: Extend the AEM Blocks with Commerce drop-in components. They use the same authoring model but dynamically render the client-side UI based on the configuration provided in the authored tables.

For a detailed breakdown of the file structure and where to find specific files, see the [Explore the Boilerplate](https://experienceleague.adobe.com/developer/commerce/storefront/get-started/boilerplate-project/) page.

---

# Data export validation

Data export synchronizes data between an Adobe Commerce instance and connected [storefront services](https://experienceleague.adobe.com/developer/commerce/storefront/setup/discovery/architecture/#storefront-services). Storefront services are required for drop-in components to work correctly.

Validating the data export is crucial to ensure that the data is correctly synchronized and available for the storefront. You can use the [Data Management Dashboard](https://experienceleague.adobe.com/en/docs/commerce-admin/systems/data-transfer/data-dashboard) to monitor the data sync progress for each service.

:::tip[Self-service data export validation]
See the [_SaaS Data Export Guide_](https://experienceleague.adobe.com/en/docs/commerce/saas-data-export/overview) for details and troubleshooting.
:::

Use GraphQL to validate that all products were synchronized and product lookup and search are working. See [GraphQL queries](https://developer.adobe.com/commerce/webapi/graphql/schema/catalog-service/queries/products/) and [Postman sample collection](https://github.com/magento/adobe-commerce-catalog-service) for queries.

For more complex catalogs, reach out to the Adobe team on [Discord](https://discord.com/channels/1131492224371277874/1220042081209421945) to validate that the exported data is correct. This might require you to provide a database dump or direct access. Please also reach out to the Adobe team if you encounter any currently un-supported use cases, so that they can be enabled in the future.

---

# Luma Bridge

This section provides guidance on how to implement the Luma Bridge for your Adobe Commerce on Edge Delivery Services project. 



> **Note:** Luma Bridge is intended for Adobe Commerce Platform as a Service (PaaS) instances with complex cart, checkout, and account page implementations that need to be migrated progressively to Edge Delivery Services. It is only supported for the following configuration: **Edge Delivery Services (EDS) + Adobe Commerce Optimizer (ACO) + PaaS**.

If you need access to the Luma Bridge package, please reach out to us at `commerce-storefront-luma-bridge@adobe.com`.

## What is Luma Bridge?

Luma Bridge is a session management mechanism between two storefronts:

- The main storefront (headless storefront) that is built using the [Commerce boilerplate template](https://github.com/hlxsites/aem-boilerplate-commerce) on Edge Delivery Services
- The default, theme-based PHP storefront that is built using Adobe Commerce (Luma theme or another base theme)

It allows you to reuse complex parts of your storefront (for example, cart, checkout, and account pages). This approach provides a path for Adobe customers currently using default, theme-based storefronts to migrate to a highly performant shopping experience in a phased manner. Using Luma Bridge, you can progressively migrate your theme-based storefront to Edge Delivery Services.

:::note
If you already have a headless storefront implementation (for example, [PWA Studio](https://github.com/magento/pwa-studio) or [Vue Storefront](https://vuestorefront.io/)), Luma Bridge is not a suitable solution to share session and other context between Edge Delivery Services and your storefront.
:::

## Demo site

The following demo site was built with Luma Bridge. You can access the full demo site at https://mcprod.eds.ecg.magento.com/.



## Requirements for implementation

You must meet the following requirements to implement Luma Bridge:

- Both the Edge Delivery Services storefront and the theme-based Adobe Commerce storefront must operate on the same top-level domain.
- You must use the user authentication and cart drop-in components to manage your storefront authentication and cart context. This ensures that Luma Bridge works with the correct set of cookies.

## How does session management work?

Luma Bridge relies on cookies generated by the [user authentication](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/) and [cart](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/) drop-in components. These components are part of your Commerce boilerplate template-based storefront on Edge Delivery Services.

Luma Bridge is a PHP module installed in Adobe Commerce, as noted above. When you enable the Luma Bridge module, Adobe Commerce can recognize and create the same cookies that your storefront drop-in components generate. This enables both applications to share the same session cookies, whether the user has a guest session or a logged-in session.

The cookies include:

- A JWT token that represents the customer session when the user is logged in, generated as a response to the `generateCustomerToken` GraphQL mutation.
- A cart ID that represents a masked quote ID, generated as a response to the `createGuestCart` GraphQL mutation.

No changes are required on your Edge Delivery Services storefront when you use the user authentication and cart drop-in components.

## Implementation considerations

Before starting an implementation, clarify the following information:

- Architecture of cart, checkout, and account pages
- Complexity of implementation
- Customization requirements

This information will help you decide whether to use Luma Bridge or a headless implementation for the cart, checkout, and account pages.

:::tip
When implementing Luma Bridge, ensure that you have engineers on the project with backend PHP knowledge on Adobe Commerce.
:::

## Installation

To install the Luma Bridge, use the following steps:


1. Fetch the package via Composer:

   ```bash
   composer require adobe-commerce/luma-bridge
   ```

1. Enable the module and complete the standard CLI procedure:

   ```bash
   bin/magento module:enable Magento_LumaBridge
   bin/magento setup:upgrade
   bin/magento setup:di:compile
   bin/magento cache:flush
   ```


After completing the installation, Luma Bridge will automatically recognize and share session cookies between your Edge Delivery Services storefront and Adobe Commerce. Test that user authentication and cart state persist correctly as customers navigate between both storefronts.

---

# Setup overview

Before starting any Adobe Commerce on Edge Delivery Services project, you must conduct a setup phase to scope the project and ensure that there are no major roadblocks or risks.

## Big picture

In the [create your storefront](https://experienceleague.adobe.com/developer/commerce/storefront/get-started/) tutorial, you learned how to quickly create a new project based on the [Commerce boilerplate template](https://github.com/hlxsites/aem-boilerplate-commerce). The boilerplate provides a starter storefront that uses a pre-configured Adobe Commerce environment.

The next step is to plan, build, optimize, and launch a production-ready storefront connected to your own Adobe Commerce instance and storefront services. Here's an overview of the process:


  ![Storefront project planning and delivery
  process.](@images/implementation/implementation-overview-v2.svg/)




1. **Discovery**: Understand the requirements and goals of the project.
1. **Setup**: Configure the project environment and tools.
1. **Analytics**: Instrument the storefront to collect user interaction events.
1. **SEO**: Optimize the storefront for search engines and marketing campaigns.
1. **Drop-in components**: Develop and integrate drop-in components to enhance the storefront experience.
1. **Launch**: Deploy the storefront to a production environment.



## Project scope

The discovery phase is important because Adobe Commerce is a highly customizable platform with a large thid-party extension ecosystem. Migrating an Adobe Commerce storefront to Edge Delivery Services is similar to migrating to a headless storefront (like [PWA Studio](https://developer.adobe.com/commerce/pwa-studio)).

:::note[Important]
The key requirement for a headless storefront implementation is that all required data is provided by APIs.
:::

Successfully building a storefront requires a well-defined plan and a phased approach. Here are some key steps to consider:



<Task>

### Phased launch

Fast return on investment (ROI) and learnings:

- Break down project scope into small milestones
- Small milestones result in faster time-to-value (TTV), learnings, and higher quality
- Define a rollout _and_ rollback strategy for each milestone (for example, split traffic)

Adobe recommends the following launch phases:

- Homepage and content pages with high-acquisition traffic that benefit from SEO improvement
- Catalog pages (PDP and PLP) with high-conversion traffic that benefit from performance improvements
- Checkout and account pages with high-retention traffic that benefit from personalization

:::tip
Instead of launching all features at once, start with a fresh Commerce project, launch with the minimum viable feature set, and add additional features as needed.

Avoid introducing any potentially breaking changes to the existing project. For example, if you uninstall an extension required for an existing storefront when migrating to Edge Delivery Services, this could be a breaking change that prevents you from rolling back to the existing storefront if necessary.
:::

</Task>

<Task>

### Metrics

Define what success should look like in each phase:

- Define measureable business and technical metrics that are impacted by launch
- Establish a baseline for each metric before launch
- Create a realistic forecast of what to expect over time

</Task>

<Task>

### Validation

Validate the impact of changes:

- Validate launch impact using your baseline and forecast
- Prioritize fixing issues you and your team can be resolve quickly
- Rollback if issues are unclear or if a fix will take too long
- Improve and test code before the next launch

</Task>



An iterative approach to launching your storefront will help you quickly identify and resolve issues, and improve the overall quality of your project. The following diagram illustrates the iterative approach:


  ![Iterative rollout process.](@images/implementation/iterative-rollout-v1.svg/)


### Use cases and requirements

Document your use cases and requirements and create a plan for how you will implement them. Adobe offers pre-built components that accelerates development (drop-in components).

Drop-in components are re-useable components that define the storefront shopping experience. They are framework agnostic and can be used in any context (Edge Delivery Services, AEM, Luma). However, this documentation focuses on the use of drop-in components in Edge Delivery Services projects using the [boilerplate template](https://github.com/hlxsites/aem-boilerplate-commerce). The drop-in component development roadmap is synchronised with Adobe Commerce APIs, so new API features are automatically available in drop-in components.

:::note
See the [drop-in components overview](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/introduction/) for a list of all available drop-in components.
:::

If you see gaps in what the drop-in components support, Adobe can help with a plan to achieve your scenarios. For example:

- Identify if drop-in components can solve your use cases and requirements
- Identify what use cases are already supported, what is a gap, and what needs to be implemented differently from what is available out-of-the-box
- Reach out to the Adobe team early to share your use cases and get the recommendations about how to fulfill them: [commerce-storefront-compatibility@adobe.com](mailto:commerce-storefront-compatibility@adobe.com/)

The Live Search Popover and PLP has two integration paths:

- Using the out-of-the-box hosted option where Adobe hosts the JavaScript file

  - Automatic updates for fixes and small features
  - Small upgrades available for major or breaking features
  - Can change some styling

- Using the customized option where Adobe provides a reference implementation for the components

  - Full control of customization and look and feel
  - You host the library and own the total cost of ownership

### Extensions

Before starting the project, use the following list to create an inventory of the Adobe Commerce extensions that are actively being used. This will help you understand which extensions can be replaced by out-of-the-box Adobe Commerce functionality.

- What extensions are currently in use?

- What type of data do the extensions provide (for example, reviews)?

- Is the data required on the frontend?
- How do the extensions expose the data (for example, GraphQL, REST API)?

- Do the extensions expose an API to access data (for example, [Amasty Labels](https://amasty.com/docs/doku.php?id=magento_2:product_labels))? If not, create an action item to expose the required data through an API. Options include:

  - Customize the Adobe Commerce Catalog Service exporter to export additional custom data to Catalog Service
  - Create a custom Adobe Commerce GraphQL query
  - Use [API Mesh for Adobe Developer App Builder](https://developer.adobe.com/graphql-mesh-gateway/)

- Are any of the extensions for delivery options (for example, shipping/BOPIS), payments, or tax providers? If you use third-party solutions, clarify if they expose APIs on the frontend and if they provide their own set of drop-in components for the frontend integration.

## Existing storefronts

There are a couple of options for modernizing your existing storefront with Edge Delivery Services:

- **Progressive implementation**: Rebuild selected parts of the commerce funnel on Edge Delivery Services and the reuse the rest from your existing storefront.
- **Full implementation**: Rebuild your entire storefront on Edge Delivery Services retire your existing storefront.

A progressive implementation enables you to unlock business value with Edge Delivery Services sooner, minimizing the risks associated with migration. You can start by implementing the home page only and reusing the rest of your existing storefront. The next step could be implementing catalog with product listing, search, and product details and reusing cart, checkout, and account from your existing storefront.

This approach comes with the cost of maintaining two storefronts in parallel, so before you choose, assess which approach is right for you. These are the key factors to consider:

- **Business metrics to improve**:

  - What areas of your existing storefront drive business performance?
  - What are the challenges based on the site analytics that you see?

- **Level of storefront customization**:

  - How many experiences are built with custom code on your storefront?
  - Do these eexperiences rely on custom business logic?

- **Third-party extensions**:

  - How many third-party extensions are you using on your existing storefront?
  - Do you need to connect to third-party services?

- **B2B**:
  - Are there any Adobe Commerce B2B modules enabled on your existing storefront?

Adobe recommends the progressive implementation if any of the following are true:

- The main business metrics are brand visibility in search engines, customer acquisition cost, and customer engagement.
- The existing storefront is heavily customized in the areas of checkout and user account.
- There are many third-party integrations in the existing storefront that affect transactional flow.
- The existing storefront supports B2B use cases with Adobe Commerce modules.

The full implementation is a better option if any of the following are true:

- Your business objectives include improving customer conversion and re-engagement.
- The current checkout flow only relies on a few thid-party integrations (for example, payments, shipping, taxes).
- No Adobe Commerce B2B modules are enabled on the existing storefront.

| Criteria                        | Progressive Implementation                                                                                                | Full Implementation                                                                                |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| **Description**                 | Rebuild selected parts of the commerce funnel on Edge Delivery Services and reuse the rest from your existing storefront. | Rebuild your entire storefront on Edge Delivery Services and retire your existing storefront.      |
| **Business Metrics to Improve** | Brand visibility in search engines, customer acquisition cost, customer engagement.                                       | Customer conversion, customer re-engagement.                                                       |
| **Level of Customization**      | Heavily customized in areas like checkout and user account.                                                               | Minimal customization, relies on a few third-party integrations (e.g., payments, shipping, taxes). |
| **Third-Party Integrations**    | Many third-party integrations affecting transactional flow.                                                               | Few third-party integrations.                                                                      |
| **B2B Modules**                 | Supports B2B use cases with Adobe Commerce modules.                                                                       | No Adobe Commerce B2B modules enabled.                                                             |
| **Project Scope**               | Identify use cases for new and existing storefronts (e.g., catalog, product detail, cart, checkout, customer account).    | Verify use cases are available through Adobe Commerce GraphQL APIs.                                |
| **Third-Party Extensions**      | Identify necessary extensions and their reliance on third-party services.                                                 | Identify necessary extensions and their reliance on third-party services.                          |
| **Storefront Bridge Options**   | Plan to connect existing storefront with the new one (e.g., using Luma Bridge).                                           | Not applicable.                                                                                    |

### Progressive implementation

For the progressive implementation, you'll need to look into the following:

- **Project scope**: Identify which use cases the new storefront will handle and which ones the existing storefront will continue to manage, such as catalog, product detail, cart, checkout, and customer account.
- **Third-party extensions**: Identify the list of extensions you will need on your new storefront and determine if they rely on integrating third-party services.
- **Storefront bridge options**: Plan to connect the existing storefront with the new one. If you are using Adobe Commerce native storefront with Luma, you can use the Luma Bridge.

### Full implementation

For the full implementation, the list of considerations is similar to the progressive implementation:

- **Project scope**: Identify which use cases the new storefront will handle and verify that they are available through Adobe Commerce GraphQL APIs.
- **Third-party extensions**: Identify the list of extensions you will need on your new storefront and determine if they rely on integrating third-party services.

---

# Launch checklist

Adobe's launch resources are designed specifically to help ensure a smooth and successful lauch of your Adobe Commerce on Edge Delivery Services storefront project.

Adobe Commerce projects usually require much more than a simple content delivery network (CDN) switch to launch. You must ensure that the launch activities are well defined and planned. You should also prepare a rollback plan in case you encounter any issues during the launch.

## Documentation

For complete documentation on launching your storefront, visit the [Launch section](https://www.aem.live/docs/#launch) on the Adobe Experience Manager site or select the direct links below. You should also review the Commerce-specific [launch checklist](#launch-checklist).



1. [Go-Live Checklist](https://www.aem.live/docs/go-live-checklist): The go-live checklist is a summary of best practices to consider when launching a website.
1. [Push Invalidation](https://www.aem.live/docs/setup-byo-cdn-push-invalidation): Automatically purge content on your production CDN, whenever an author publishes content changes.
1. [Cloudflare Worker Setup](https://www.aem.live/docs/byo-cdn-cloudflare-worker-setup): Learn how to configure Cloudflare to deliver content.
1. [Akamai Setup](https://www.aem.live/docs/byo-cdn-akamai-setup): Discover how to use the Akamai Property Manager to configure a property to deliver content.
1. [Fastly Setup](https://www.aem.live/docs/byo-cdn-fastly-setup): This guide illustrates how to configure Fastly to deliver content.
1. [CloudFront Setup](https://www.aem.live/docs/byo-cdn-cloudfront-setup): Set up Amazon Web Services Cloudfront to deliver your AEM site with push invalidation.
1. [Bring your own DNS](https://www.aem.live/docs/byo-dns): A custom domain without having to set up a content delivery network.
1. [Redirects](https://www.aem.live/docs/redirects): You can manage redirects as a spreadsheet from the `redirects` document in the root of your project folder.



## Launch checklist

The launch of a new storefront can be an overwhelming and stressful process. If you don't have a checklist, you're likely to forget something. Tracking all tasks that need to be completed before the launch of your Adobe Commerce on Edge Delivery Services storefront project is a best practice. This checklist will help you ensure that you have everything in place before you launch.

During the development phase of your project, you'll encounter tasks around migrating implementations that were done on a development or staging environment to production. It is essential to keep track of these changes and make them reproducible on the production environment as part of the launch activities.

:::caution
Avoid scheduling a launch shortly before a weekend. The Adobe engineering team might have limited availability to fix critical issues if they occur.
:::

{/* Start your checklist with the [Go-Live Checklist](https://www.aem.live/docs/go-live-checklist). For Commerce sites, you should prioritize SEO tasks. Additionally, make sure that you have completed the following items. */}


### Catalog service

* [ ] Switch to the Catalog Service production endpoint (`https://catalog-service.adobe.io/graphql`).
* [ ] Ensure a production environment is configured in the Service Connector (will result in a new `environmentId`).
* [ ] Sync the production catalog to the new production environment.
* [ ] Create a new Commerce production API key-pair and use the public key as the `x-api-key` value.
* [ ] Double check category IDs and make sure all category pages have a reference to the correct category.
* [ ] Update `environmentId` and `x-api-key` values in the `config.json` code file.
* [ ] Let the Catalog Service team know about the new production environment and launch date.



### CDN and caching

* [ ] Update your CDN configuration with your production GraphQL endpoint `yourproject.com/graphql`. Make sure to also use this for all the Sidekick extensions and scripts (for example, sitemap generation, image importer).
{/* TODO: How do we update CDN purge token for config service or da.live, non-config site */}
* [ ] When using Adobe Commerce Fastly, request a new CDN purge token for Commerce production
      environment. Update in Sharepoint in the `.helix/config.xlsx` file (`authToken` and
      `serviceId`).
* [ ] Validate your [CDN configuration](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/content-delivery-network/) and ensure that caching
      and cache invalidation work as expected.
* [ ] For [multi-store setups](https://experienceleague.adobe.com/developer/commerce/storefront/setup/seo/indexing/#multi-store-setups), add a store-specific cache buster (for example, a query parameter or proxy through CDN configuration) to Catalog Service and Live Search requests.



### Security and access

* [ ] Verify/update password reset links. Match the Edge Delivery Services implementation in the Adobe Commerce Admin. See the [FAQ](https://experienceleague.adobe.com/developer/commerce/storefront/troubleshooting/faq#what-should-i-do-if-my-email-template-links-are-broken-after-migrating-to-edge-delivery-services-or-helix) for details.
* [ ] Provide and configure production keys for integrations and payment providers.
* [ ] Verify that the new domains/subdomains are `allowlisted` and potential backend webhooks are working.



### SEO and indexing

* [ ] Add a `robots.txt` file to your project, which allows your site to be indexed by search
      engines. Ensure that your sitemaps are referenced and that you add rules to block indexing
      of any content that you do not want to be indexed (for example, the `/drafts` folder).
* [ ] Add one or multiple [redirect](https://www.aem.live/docs/redirects) files to ensure that
      URLs that were changed as part of the migration still work (for example, when you remove the
      `.html` file extension).
* [ ] Generate a sitemap for your site and catalog. To speed up the indexing process, Adobe
      recommends adding the sitemap to Google Search Console.
* [ ] Ensure that your product detail pages have [metadata and structured data](https://experienceleague.adobe.com/developer/commerce/storefront/setup/seo/metadata/)
      (for example, LD-JSON data is configured).



### Performance and monitoring

* [ ] Validate your [storefront
      events](https://github.com/adobe/commerce-events/tree/main/examples/events/snowplow-debugger)
      implementation and ensure that data is displayed in your Live Search and Product
      Recommendation dashboards in the Adobe Commerce Admin.
* [ ] Ensure that the `environment` analytics config parameter is set appropriately in your [Commerce configuration](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/commerce-configuration/). It should be set to `"Testing"` when you are developing your storefront, and `"Production"` when you are ready to deploy your storefront. See the [Instrumentation](https://experienceleague.adobe.com/developer/commerce/storefront/setup/analytics/instrumentation/) documentation for more information.
* [ ] Ensure that the site's Lighthouse score is green; targeting `100` on every page (taking into
      account previous considerations mentioned on this document).



### Project management and updates

* [ ] Notify Adobe early about your planned launch date to ensure that the Adobe Commerce team is
      available to support you during the launch.
* [ ] Check for the latest boilerplate changes and update your project accordingly.

---

# SEO indexing

Optimizing Adobe Commerce storefronts on Edge Delivery Services for search engines requires guidance. The general recommendations provided here are inspired by customers and partners who have built storefront projects on Edge Delivery Services.

The following best practices are designed to help you ensure that your site is indexed correctly by search engines.

### Canonical URLs

- When product detail pages (PDPs) have multiple URLs, set a consistent canonical URL for each product.
- Make sure that canonical URLs do not point to redirects (301).

### Configurable products

For configurable products, ensure that the canonical URL is set to the parent product URL. This is important because Google might index the child product URLs, which can lead to duplicate content issues.

### Folder mapping

When using [folder mapping](https://www.aem.live/developer/folder-mapping) for Commerce pages (PDP, PLP) ensure that the server-side rendered response contains metadata that allows Google to differentiate pages.

Folder-mapped pages (without using [bulk metadata](https://www.aem.live/docs/bulk-metadata)) all look the same and Google might classify them as duplicate and not index them, despite different canonical URLs as Google considers canonical URLs a hint and not an absolute value.

#### URL format of catalog pages

By default, the boilerplate uses [folder mapping](https://www.aem.live/developer/folder-mapping) for product detail pages (PDP) and dedicated pages for product list pages (PLP). If your catalog has a large amount of PLPs, it might make sense to also use folder mapping for PLPs. A low number of PDPs or PLPs could justify creating dedicated pages for each.

The URL format for folder mapped PDPs looks like this:

```plaintext
/products/{urlKey}/{sku}
```

This is to include the SEO relevant `urlKey` parameter and the `SKU` which is needed to perform Catalog Service queries. Feel free to customize the format as needed. You might need to do advanced customization on the CDN.

:::note
The Commerce boilerplate enforces lowercase SKUs in all product URLs to ensure canonical consistency and comply with Edge Delivery Services [document naming restrictions](https://www.aem.live/docs/limits#document-naming-restrictions); SKUs must contain only `a-z`, `0-9`, `-`, and `.` (whitespace and other characters are not supported).

- All product URLs now use lowercase SKUs by default
- A centralized `getProductLink(urlKey, sku)` function ensures consistent URL generation
- Sites with uppercase SKUs must either publish metadata or modify the URL generation function
- See the [metadata documentation](https://experienceleague.adobe.com/developer/commerce/storefront/setup/seo/metadata/) for implementation details
:::

### Multi-store setups

For [multi-store setups](https://experienceleague.adobe.com/developer/commerce/storefront/merchants/multistore/) or stores supporting multiple locales:

- Verify a [correct hreflang setup](https://www.aem.live/developer/sitemap#specifying-the-primary-language-manually). You can validate using the [hreflang Tags Testing Tool](https://technicalseo.com/tools/hreflang/)

- Verify that the `Magento-Store-Code` header value defined in your [storefront configuration](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/commerce-configuration/) is part of the URL for every Catalog Service or Live Search request.

  :::note
  This is required because Google caches responses without considering headers. Not adding the store code to the URL might lead to Google indexing the wrong data. You can ensure this by adding a cache-busting query parameter.
  :::

### Cache-busting Query Parameter

The [Commerce boilerplate template](https://github.com/hlxsites/aem-boilerplate-commerce/tree/main) includes a built-in way to prevent stale data from being served. It does this by adding a dynamic cache-busting parameter to Catalog Service requests.

When your configuration headers change, the browser fetches fresh data instead of using cached responses. This helps keep your storefront content up to date.

Hereâ€™s how the boilerplate handles it:

1. It collects headers from your [storefront configuration](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/commerce-configuration/)â€”`public.headers.all.*` and `public.headers.cs.*`
1. It creates a short hash (5 characters by default) based on those headers.
1. It adds the hash to the Catalog Service URL using the format `?cb=<hash>`.
1. When the headers change, it generates a new hash automatically.

This ensures that any changeâ€”like a new store code or view codeâ€”triggers a fresh fetch and bypasses CDN-cached GET requests to the Catalog Service.

You donâ€™t need to enable or configure anything. The Commerce boilerplate handles everything automatically when:

- The PDP drop-in component initializes.
- Any component sends a request to the Catalog Service.
- Your configuration headers update.

The boilerplate always manages the `cb` parameter for you.

### Redirects

Ensure proper redirects are set up using the redirects sheet or through your [CDN](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/content-delivery-network/).

- Fallbacks for any potential URL changes (for example, product URLs or missing .html suffixes)
- Redirects that are set up in Adobe Commerce

### Sitemaps

- Submit new sitemaps through Google Search Console (Google takes a while to detect new sitemaps).
- If your site is using more than one sitemap, reference all sitemaps in your site's `robots.txt` file.
- Ensure that all sitemaps are valid using the [hreflang Tags Testing Tool](https://technicalseo.com/tools/hreflang/).

:::note
See [sitemaps](https://www.aem.live/developer/sitemap) in the Edge Delivery Services documentation for more information on how to generate sitemaps.
:::

### Other

- You can validate indexing using Google Search Console by inspecting the markup of the crawl to see if all important information were tracked.
- Transactional pages (for example, cart, checkout, and account) should not be indexed.
- Staging or any non-production environments must not be indexed. Once indexed, URLs from a staging environment can reduce traffic to the production environment. It might take a significant amount of time to remove staging URLs from the Google index.

---

# SEO metadata

Adobe recommends uploading product metadata into Edge Delivery Services so that it can be rendered server-side on product detail pages. This is important so that Google Merchant Center can reliably verify entries from your product sheet. Also, social media sites, which don't usually parse JavaScript, can leverage this metadata to display rich previews of your product page links.

> **Note:** For consistency and canonicalization, mixed-case URLs are not supported. The boilerplate automatically lowercases SKUs in product URLs to comply with Edge Delivery Services, which requires lowercase paths.

Extra attention should be given to sites that use uppercase SKUs. See below for more information.

Verify that all pages, especially catalog pages (PDP and PLP), contain the following metadata:

| Type                      | Properties                                                                                                                                                              |
| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Document title            | `title`                                                                                                                                                                 |
| Meta tags                 | `description`, `keywords`, `og:type`, `og:title`, `og:description`, `og:url`, `og:image`, `og:image:secure_url`, `og:product:price:amount`, `og:product:price:currency` |
| Schema.org data (JSON-LD) | `WebSite`, `Product`, `AggregateRating`, `Rating`, `BreadcrumbList`                                                                                                     |

:::note
Metadata should contain a `SKU` field for each product.
:::

:::note
When importing pages, ensure that when a metadata block is present on a page, it does not contain any empty fields. This might lead to pages with missing titles, which Google penalizes.
:::

## Schema.org data (JSON-LD)

JavaScript Object Notation for Linked Data (JSON-LD) is a structured data format that helps search engines understand the content of your web pages more explicitly. It is typically added as a script tag in the `<head>` of your HTML document.

Adobe Commerce storefronts on Edge Delivery Services should include [schema.org](https://schema.org/) annotations to expose product data to search engines. This data should be included on all Commerce pages, especially PDPs and PLPs.

You should compare the data available on the site before migrating to Edge Delivery Services to ensure that SKUs for all product variants are included. Use the [Rich Results Test](https://search.google.com/test/rich-results) to validate the schema.org annotations. The PDP drop-in component in the boilerplate contains an example for JSON-LD data.

:::note
If you are using Google Shopping features (for example, products available on `shopping.google.com`), consider schema.org annotations with critical priority. If a single JSON-LD annotation on the page is invalid, Google considers all annotations invalid.
:::

## Generate metadata

You can use the [PDP Metadata Generator](https://github.com/hlxsites/aem-boilerplate-commerce/tree/main/tools/pdp-metadata) tool to automate the process of generating all recommended metadata. The tool fetches product data from the Catalog Service, processes it, and generates a metadata spreadsheet in `.xslx` format. The spreadsheet can be used for the [bulk metadata](https://www.aem.live/docs/bulk-metadata) feature in Edge Delivery Services.

> **Note:** * Node.js installed on your machine
  * Access to the Catalog Service with the necessary API keys and configuration
  * Commerce boilerplate repository cloned to your local machine

To generate metadata using the PDP Metadata Generator tool:



1. Navigate to the `tools/pdp-metadata/` directory in your local project.
1. Install dependencies.

   ```bash
   npm install
   ```

   :::note
   Before running the tool, you must ensure that the `configFile` variable in the `pdp-metadata.js` file points to the correct configuration JSON file URL. This file contains the required parameters to access the Catalog Service API and should have been setup as part of your [project onboarding](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/commerce-configuration/).
   :::

1. Run the tool and generate a `metadata` files in the project directory.

   ```bash
   npm start
   ```



The resulting `metadata.xlsx` and `metadata.json` files contain all recommended metadata for all of your products based on your site's [commerce configuration](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/commerce-configuration/).

See the [bulk metadata](https://www.aem.live/docs/bulk-metadata) documentation for instructions on how to upload the generated metadata file to Edge Delivery Services.

## SKU Casing

Due to a requirement in Edge Delivery Services, all product URLs must use lowercase SKUs. The boilerplate will enforce this by default.

**Product Link Generation**: A centralized `getProductLink(urlKey, sku)` function has been implemented to ensure consistent URL generation across all commerce components. This function is used to generate product page links at runtime in the correct casing.

**Metadata Generation**: Metadata applied through [bulk metadata](https://www.aem.live/docs/bulk-metadata) only applies metadata for lowercase urls. The PDP Metadata Generation tool has been updated to produce output in the correct format.

### Implementation Requirements

For sites with SKUs containing uppercase letters, you have two options:

**Option A: Publish Metadata (Recommended)**
Upload a `metadata.json` file to Edge Delivery Services that maps your product paths to the correct metadata. This approach ensures optimal SEO performance. See [the tool's README](https://github.com/hlxsites/aem-boilerplate-commerce/blob/main/tools/pdp-metadata/README.md) for more information.

**Option B: Remove Lowercase Enforcement**
If you prefer to maintain uppercase SKUs in URLs, you can modify the `getProductLink` function in your boilerplate to remove the `.toLowerCase()` call, but **metadata will not be applied**.

```javascript
// In scripts/commerce.js
export function getProductLink(urlKey, sku) {
  return `/products/${urlKey}/${sku}`; // Remove .toLowerCase()
}
```

> **Note:** Removing lowercase enforcement may impact SEO performance. Adobe recommends using Option A for optimal results.

### Migration Guide

If you're upgrading from a previous version of the boilerplate:

1. **Review Your SKUs**: Identify any products with uppercase SKUs
2. **Choose Implementation Strategy**: Decide between metadata publishing or removing lowercase enforcement
3. **Update Product Links**: Ensure all commerce components use the centralized `getProductLink` function
4. **Test Thoroughly**: Validate metadata generation and URL consistency
5. **Monitor Performance**: Track SEO metrics and page load times

> **Note:** For new implementations, always use lowercase SKUs from the start to avoid migration complexity and ensure optimal SEO performance.

---

# Event bus



---

# Branding drop-in components

Branding with design tokens is the quickest way to customize your storefront. The goal of branding is to replace the storefront design token values with the values of your brand's colors, typography, spacing, and shapes. Let's dive in.

## Big picture

The following diagram shows a small branding change. When we override the default value of a single shape token, we override the default border-radius of the `Button` library component, which changes the look and feel of drop-in components that use it.


  ![Diagram for how to brand drop-in components](@images/brand/howtobrand.svg/)


## Vocabulary



### design tokens

CSS variables with default values. Our design tokens provide a standard set of CSS properties and default values for colors, typography, spacing, shapes, and layout grids. We use them in all of our component CSS classes to avoid hard-coded values that cannot be easily changed. With this strategy, you can restyle our drop-in components to match your brand simply by changing the default token values.



### library components

Basic components (like `Button`, `Checkbox`, and `Carousel`) used to build drop-in components. Design tokens are embedded in the CSS classes of these components to ensure fast, flexible styling to match your brand.

### Adobe Commerce design system

The collection of design tokens, library components, and conventions we use to style our drop-in components.

### brand

To override the built-in design token default values to match your brand's colors, typography, spacing, shapes, and grids.

### style

To change existing drop-in component CSS classes or add new CSS classes to the drop-in component elements. Styling provides a deeper level of customization than branding.



## Examples

This example shows six design tokens with new values for three color and three shape tokens from the boilerplate's `styles/styles.css` file.



## Step-by-step

The following steps show how to override the default design token values to match your brand colors, typography, spacing, shapes, and layouts (grids).

:::tip[TIP]
Work on one category at a time.
:::
For example, start with **typography**, then move on to **spacing**, **shapes**, **grids**, and finally **colors** (because they are typically the hardest to map to design tokens). Using this process ensures each brand category is completed and reviewed before moving on to the next.
:::



[1]: Work on one category at a time

<Task>

### Open the `styles/styles.css` file.

From the root of your project, open the `styles/styles.css` file.

<FileTree>

- scripts/
- **styles/** _CSS files for drop-in component design tokens, fonts, deferred styles_
  - fonts.css _-- Default font styles_
  - lazy-styles.css _-- Global styles loaded after LCP_
  - **styles.css** _-- Global design tokens and CSS classes for site_
- tools/

</FileTree>

</Task>

<Task>
### Override typography tokens.

We suggest starting with typography overrides. Mapping a brand's typography to the available design tokens is typically straightforward. For example, [NASA's Brand Guidelines for typography](https://www.nasa.gov/nasa-brand-center/brand-guidelines/#Typography) specifies three font families:

- **Inter** for large display and heading text
- **Public Sans** for interfaces and body text
- **DM Mono** for numbers and small labels

:::tip[Tip: Download the fonts]
For better performance, we recommend downloading your brand fonts and adding them to the `fonts/` directory. Then, update the `styles/fonts.css` file to import them for use in the design tokens. Use the default Roboto font as an example for adding your brand's fonts.
:::

After installing the fonts, you can map them to the storefront design tokens. The following example shows how you might override the default typography design tokens to match NASA's brand guidelines.

```css
:root,
.dropin-design {
  --type-body-font-family: 'Public Sans', sans-serif;
  --type-display-font-family: 'Inter', sans-serif;
  --type-details-font-family: 'DM Mono', monospace;

  --type-display-1-font: normal normal 300 60px/72px var(--type-display-font-family); /* Hero title */
  --type-display-1-letter-spacing: 0.04em;
  --type-display-2-font: normal normal 300 48px/56px var(--type-display-font-family); /* Banner title */
  --type-display-2-letter-spacing: 0.04em;
  --type-display-3-font: normal normal 300 34px/40px var(--type-display-font-family); /* Desktop & tablet section title */
  --type-display-3-letter-spacing: 0.04em;

  --type-headline-1-font: normal normal 400 24px/32px var(--type-display-font-family); /* Desktop & tablet page title */
  --type-headline-1-letter-spacing: 0.04em;
  --type-headline-2-default-font: normal normal 300 20px/24px var(--type-display-font-family); /* Rail title */
  --type-headline-2-default-letter-spacing: 0.04em;
  --type-headline-2-strong-font: normal normal 400 20px/24px var(--type-display-font-family); /* Mobile page and section title */
  --type-headline-2-strong-letter-spacing: 0.04em;

  --type-body-1-default-font: normal normal 300 16px/24px var(--type-body-font-family); /* Normal text paragraph */
  --type-body-1-default-letter-spacing: 0.04em;
  --type-body-1-strong-font: normal normal 400 16px/24px var(--type-body-font-family);
  --type-body-1-strong-letter-spacing: 0.04em;
  --type-body-1-emphasized-font: normal normal 700 16px/24px var(--type-body-font-family);
  --type-body-1-emphasized-letter-spacing: 0.04em;
  --type-body-2-default-font: normal normal 300 14px/20px var(--type-body-font-family);
  --type-body-2-default-letter-spacing: 0.04em;
  --type-body-2-strong-font: normal normal 400 14px/20px var(--type-body-font-family);
  --type-body-2-strong-letter-spacing: 0.04em;
  --type-body-2-emphasized-font: normal normal 700 14px/20px var(--type-body-font-family);
  --type-body-2-emphasized-letter-spacing: 0.04em;

  --type-button-1-font: normal normal 400 20px/26px var(--type-body-font-family); /* Primary button text */
  --type-button-1-letter-spacing: 0.08em;
  --type-button-2-font: normal normal 400 16px/24px var(--type-body-font-family); /* Small buttons */
  --type-button-2-letter-spacing: 0.08em;

  --type-details-caption-1-font: normal normal 400 12px/16px var(--type-details-font-family);
  --type-details-caption-1-letter-spacing: 0.08em;
  --type-details-caption-2-font: normal normal 300 12px/16px var(--type-details-font-family);
  --type-details-caption-2-letter-spacing: 0.08em;
  --type-details-overline-font: normal normal 700 12px/20px var(--type-details-font-family);
  --type-details-overline-letter-spacing: 0.16em;
}
```

</Task>
<Task>
### Continue with spacing, shapes, layouts, and colors.

Use the same process for overriding the spacing, shapes, grids, and color token values. With a company's brand guidelines, you can start discovering how to map brand categories to the design-token values you need to override. But it's not always straightforward. Mapping brand colors to the color token options can be challenging. This is when you will need to work closely with the design team to make decisions about which design tokens to override and how to map your brand colors to the available options.

</Task>


## Summary

The process of branding drop-in components is typically fast and easy. Focus on one brand category at a time and work with your designers to solve the less obvious brand-to-token overrides.

---

# Creating drop-in components

This topic describes how to use the `drop-template` repository to create drop-in components for Adobe Commerce Storefronts.

## What are drop-in component templates?
Drop-in templates are GitHub Templates that allow you to quickly create drop-in components with the same structure, branches, files, and best practices built in. The `dropin-template` repository provides the starting point for creating new drop-ins quickly and consistently.

For more information on GitHub Templates, you can refer to the following resource: [How to Use GitHub Repository Templates](https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template)

## How to use the Adobe Commerce drop-in template
:::note
Supported Node versions are: Maintenance (v20) and Active (v22).
:::

To create a new drop-in component using the Adobe Commerce drop-in template, follow these steps:


1. **Navigate to the Template Repository**: Go to https://github.com/adobe-commerce/dropin-template.
1. **Create a New Repository**: Click on the **Use this template** button to create a new repository based on the template. This will generate a new repository with the same directory structure and files as the template.
1. **Clone Your New Repository**: You can now clone the newly created repository to your local machine using `git clone`.
1. **Getting Started**: Follow the instructions below to install the dependencies, generate a configuration file, update your Mesh endpoint, generate your source files, and launch your development environment.


**Troubleshooting:**  
- If you don't see the **Use this template** button, make sure you are logged into GitHub.
- If you get a "Permission denied" error, check your SSH keys or use HTTPS.

## Getting started

<Task>

### Install dependencies
Before you begin, make sure you have all the necessary dependencies installed. Run the following command to install all required packages:
```bash
npm install
```
**Troubleshooting:**  
If you see errors about missing Node.js, install it from <ExternalLink href="https://nodejs.org/">nodejs.org</ExternalLink>.
</Task>

<Task>
### Generate new config
Before you can start developing, you need to generate the `.elsie.js` config file. The Elsie CLI uses this file to generate new components, containers, and API functions in specified directories within your project.
To create a new configuration file, run the following command. Replace `<DropInName>` with the name of your new drop-in.

```bash
npx elsie generate config --name <DropInName>
```

After generating the `.elsie.js` config, open it and take a look. Below is an annotated version describing the main properties:

```javascript
module.exports = {
  name: 'Login', // The name of your frontend. This name can be changed at any time.
  api: {
    root: './src/api', // Directory where the CLI will add all your generated API functions.
    importAliasRoot: '@/login/api',
  },
  components: [
    {
      id: 'Components',
      root: './src/components', // Directory where the CLI will add all your generated components.
      importAliasRoot: '@/login/components',
      cssPrefix: 'elsie',
      default: true,
    },
  ],
  containers: {
    root: './src/containers', // Directory where the CLI will add all your generated containers.
    importAliasRoot: '@/login/containers',
  },
};
```

**Troubleshooting:**  
If `npx` is not found, ensure Node.js and npm are installed.

:::tip[More Info]
For more details on _Elsie CLI_ commands and their usage, visit this documentation page: [Elsie CLI](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/get-started/cli/).
:::
</Task>

<Task>
### Explore the project structure
Understand where to find and place your code.

<FileTree>
  - .storybook/ *-- Best-practice Storybook configurations right out of the box*
  - examples/
    - html-host/ *-- Preconfigured HTML UI for testing your drop-in components*
      - example.css
      - favicon.ico
      - index.html
      - styles.css
  - src/
    - api/  *-- By default, the Elsie CLI adds your API functions here*
    - data/ *-- Contains data models and type definitions*
    - docs/ *-- Provides an MDX template to document your frontend*
    - i18n/ *-- Internationalization setup with starter en_US.json file*
    - render/ *-- Contains rendering utilities and provider functions*
    - types/ *-- TypeScript type definitions and interfaces*
  - tests/ *-- Unit tests and testing utilities*
  - elsie.js *-- Configuration file for creating components, containers and functions*
  - .env.sample *-- Preconfigured settings for a development-only mesh endpoint*
  - .eslintrc.js *-- Preconfigured linting*
  - .gitignore
  - .jest.config.js *-- Preconfigured unit testing*
  - LICENSE *-- Adobe Drop-in Template License*
  - package.json *-- Preconfigured dependencies*
  - prettier.config.js *-- Preconfigured formatting*
  - README.md *-- Quick instructional overview of frontend development tasks*
  - storybook-stories.js *-- Additional storybook settings*
  - tsconfig.js *-- Preconfigured for TypeScript*
</FileTree>

</Task>

<Task>

### Update mesh/backend endpoint (for development only)
For development purposes, you will need to rename your `.env.sample` file to `.env` and update the new `.env` file with the correct mesh/backend endpoint. This file is used to store environment-specific configurations.
```sh
ENDPOINT="your-endpoint"
```
**Troubleshooting:**  
If you see network errors when running the dev server, check your endpoint URL.
</Task>

<Task>

### Start the development server
```bash
npm run dev
```
Congratulations! You just launched your frontend development environment. It's a preconfigured HTML page (`examples > html-host > index.html`) that loads your frontend components for testing during development:

<Diagram caption="Frontend development environment">
  ![Frontend Development Environment](src/content/docs/sdk/images/frontend.png/)
</Diagram>

Now you're ready to start building a composable frontend. Stop the server with `Ctrl + C` and let's get started.

</Task>

<Task>
### Generate a new UI component
UI components in this codebase are primarily responsible for rendering the UI, handling presentation, and managing styling. To generate a new UI component, use the following command. Replace `<MyUIComponent>` with the name of your component.

```bash
npx elsie generate component --pathname <MyUIComponent>
```
**Make sure to use Pascal casing for the component name.**

For a login form, you might choose:

```bash
npx elsie generate component --pathname LoginForm
```

Let's take a quick look at the files that are generated for you:

```console
~/composable-login [main] Â» npx elsie generate component --pathname LoginForm
ðŸ†• src/components/LoginForm/LoginForm.css created
ðŸ†• src/components/LoginForm/LoginForm.stories.tsx created
ðŸ†• src/components/LoginForm/LoginForm.test.tsx created
ðŸ†• src/components/LoginForm/LoginForm.tsx created
ðŸ†• src/components/LoginForm/index.ts created
ðŸ†• src/components/index.ts created
~/composable-login [main] Â»
```

These files were not only generated with the appropriate names, but they are completely preconfigured to work together as a unit. For example, the `LoginForm` component was automatically imported into `src/components/index.ts` to let you start referencing the component throughout your project.

And if you run `npm run dev` again, you'll see your new component in the Storybook UI, configured with an example and best practices to help you get started with Storybook.

</Task>

<Task>
### Generate a new frontend container
Containers handle business logic, state management, API calls, and data fetching using the components. They do not contain CSS or styling logic.
To create a new frontend container, use this command. Replace `<MyContainer>` with the desired name of your frontend container. 

**Make sure to use Pascal casing for the container name.**

```bash
npx elsie generate container --pathname <MyContainer>
```
For a login form, you might choose:

```bash
npx elsie generate container --pathname LoginContainer
```
</Task>

<Task>
### Generate a new API function
The API layer provides core functionalities like fetching, handling events, and GraphQL operations. This API is primarily consumed by a container.

If you need to add a new API function, run the following command. Replace `<myApiFunction>` with the desired name for your API function. 

**Make sure to use camel casing for the API name.**

```bash
npx elsie generate api --pathname <myApiFunction>
```

For a login form, you might want to add `login` and `logout` functions as follows:

```bash
npx elsie generate api --pathname login
```

```bash
npx elsie generate api --pathname logout
```
</Task>

**Location:** 

Generated files will be placed in `src/components/`, `src/containers/`, and `src/api/` respectively



## Adding a shared component to your project
After creating your drop-in component, let's add a shared component from the Storefront SDK. These components are designed to be reusable and customizable, making it easier to build consistent and high-quality user interfaces. Follow the steps below to add a shared component to your drop-in component project.


<Task>

### Install the `@adobe-commerce/elsie` package
Run the following command to install the Storefront SDK package:

```bash
npm install @adobe-commerce/elsie
```
</Task>

<Task>

### Use a shared component from the SDK
In your generated UI component, import a shared component from the Storefront SDK package and render it. For example, you can add the `Button` component as follows:

   ```javascript
   import { Button } from '@adobe-commerce/elsie';
   
   function MyUiComponent() {
     return (
       <div>
         
       </div>
     );
   }
   ```

</Task>



## Development and testing
These development tools help you preview components during your development process and ensure that your code is properly tested.

### I. Run unit tests
The commands to generate a component, container or an API, also create a `.test.tsx` file in their respective directories. These files are useful for unit testing.

To ensure your code is working as expected, you should run these unit tests to catch any issues early in the development process:

```bash
npm run test
```

This project is set up to use the Jest testing framework. Here are some useful resources:

- [Jest Getting Started (official docs)](https://jestjs.io/docs/getting-started)
- [Preact Testing Library Intro](https://testing-library.com/docs/preact-testing-library/intro)

### II. Build production bundles
Once you're ready to prepare your app for production, run the following command to build the production bundles:

```bash
npm run build
```
A dist/ directory with production-ready assets will be created.

### III. Storybook
Storybook is a tool used for developing and testing UI components in isolation. Once a container/component is created using one of the commands above, a `.stories.tsx` file is also created in the same directory as the component/container to preview the component/container.

Use `npm run storybook` to spin up the Storybook environment at `http://localhost:6006/`.

[Here](https://storybook.js.org/docs) is the official Storybook documentation.

### IV. Sandbox environment
The Sandbox is an HTML file with minimal application setup to deploy your drop-in. It is useful for testing and integration between different pieces of your project.

To render your container in the sandbox, update the `examples/html-host/index.html` file.
Use `npm run serve` to spin up the Sandbox environment at `http://127.0.0.1:3000`.

## Understanding the drop-in sandbox environment
The following steps will help you navigate previewing your drop-in in the Sandbox Environment, `examples/html-host/index.html`.

<Task>

### Import map configuration
```html
<script type="importmap">
  {
    "imports": {
      "@dropins/tools/": "https://cdn.jsdelivr.net/npm/@dropins/tools/",
      "my-pkg/": "http://localhost:3002/"
    }
  }
</script>
```

This tells the browser:

- **Adobe Commerce tools**: `@dropins/tools/` (served from `https://cdn.jsdelivr.net/npm/@dropins/tools/`)
- **Your drop-in code**: `my-pkg/` (served from `http://localhost:3002/`)

> **Tip:** Replace `my-pkg/` with your drop-in's npm name, for example, `@dropins/cart/`.  
> Add and edit other imports for your drop-in as needed.

</Task>

<Task>
### Core imports
```javascript
// Import API functions to use with action buttons
// Replace `my-pkg` with `@dropins/YourDropin`
// or more specifically:
```
```javascript
// The event bus is a core communication tool for all drop-ins. 
// They subscribe and publish to events to talk to each other without direct coupling.
```
*For Mesh-based Drop-ins (for example, Cart):*
```javascript

// GraphQL Client - For data fetching

// Initialize GraphQL Client (Mesh)
// Replace with your actual endpoint
mesh.setEndpoint('your-endpoint');
```

*For Direct API-based drop-ins (for example, Recommendations):*

```javascript
// Configure API
// Replace with your actual endpoint
pkg.setEndpoint('your-endpoint');
```

*Initializers*

The initializer is a lifecycle management system that handles the setup, configuration, and coordination of components in the application.

```javascript
```
</Task>

<Task>

### Drop-in container setup
Uncomment and modify these lines to set up your container.

```javascript
// import { render as provider } from 'my-pkg/render.js';
// import <Container> from 'my-pkg/containers/<Container>.js';
```
For example:

```javascript
```

</Task>

### Sandbox structure
The sandbox environment is divided into three main sections:

#### 1. Action Controls (Top)
Controls for triggering functionality:

```html
<fieldset class="actions">
  <legend>API Functions</legend>
  <button id="action-1" disabled>Action</button>
</fieldset>
```

Example usage:

```javascript
const $action_1 = document.getElementById('action-1');
$action_1.addEventListener('click', () => {
  console.log("action-1 has been clicked");
  myFunction(); // or pkg.myFunction();
});
```

#### 2. Data/debug display (Middle)
Real-time data and response visualization:

```html
<code data-label="fetchGraphQl">
  <pre id="data">â³ Loading...</pre>
</code>
```

Example usage:

```javascript
// Display event data
const $data = document.getElementById('data');
events.on('<eventName>', (data) => {
  $data.innerText = JSON.stringify(data, null, 2);
});

// Update loading state
$data.innerText = 'â³ Loading...';
```

#### 3. Container display (Bottom)
Where your drop-in components are rendered:

```html
<div class="containers">
  <h2 class="heading">Frontend Containers</h2>
  <div id="my-container" class="container"></div>
</div>
```

Example usage:

```javascript
const $my_container = document.getElementById('my-container');
provider.render(Container, {
  // Your container props
})($my_container);
```

:::tip[More Info]
For more details on the usage of _event bus_, _initializers_, and _render_, visit this documentation page: [SDK documentation](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/).
:::

### Styling the sandbox
The Sandbox environment is styled using two stylesheets:

- `style.css` which is the base styling file that handles root-level styles and variables as well as global element styles.  
- `example.css` which is specifically for styling sandbox UI components.



## Best practices and accessibility
- Use meaningful names for components and API functions.
- Write tests for every component and function.
- Keep components small and focused.
- Document your code and update the MDX docs in `src/docs/`.
- Use Storybook to visually test components.
- Commit early and often; use branches for new features.
- Use clear, simple language in UI and documentation.
- Ensure all components are keyboard accessible.
- Add ARIA labels where appropriate.
- Test with screen readers.

**Common pitfalls:**

- Forgetting to create and update `.env` with the correct endpoint.
- Not running `npm install` after cloning.
- Skipping tests before building for production.

## Summary and next steps
You've learned how to:

- Set up a drop-in component project
- Generate and configure components, API functions, and containers
- Run and test your frontend locally
- Build for production

**Next Steps:**

- Explore advanced component patterns
- Integrate with real backend APIs
- Contribute to the drop-in template repo

---

# Events

Drop-in components implement an event-driven architecture that uses the `@adobe/event-bus` package to facilitate communication between components. This event system enables drop-ins to respond to application state changes, maintain loose coupling between components, and keep their state synchronized across your storefront.

> **Note:** **Looking for the API reference?** For detailed API documentation including methods like `events.on()`, `events.emit()`, and advanced features like scoping, see the [Event Bus API Reference](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/events/).

## Event system architecture

The system uses a publish-subscribe pattern where components can:

1. **Subscribe** to specific events using `events.on()`
2. **Emit** events using `events.emit()`
3. **Unsubscribe** using `subscription.off()`

This pattern allows drop-ins to communicate without having direct dependencies on each other, making your storefront more modular and maintainable.

## Event declaration

Events are strongly typed using TypeScript declaration merging to provide type safety and autocomplete support. Each drop-in declares its events by extending the `Events` interface from the event bus.

Here's an example of how events are declared:

```typescript title="event-bus.d.ts"
declare module '@adobe/event-bus' {
  interface Events {
    'dropin/initialized': DataModel | null;
    'dropin/updated': DataModel | null;
    'dropin/data': DataModel;
    authenticated: boolean;
    locale: string;
    error: { source: string; type: string; error: Error };
  }
}
```

> **Note:** Each drop-in's event documentation includes the specific event contracts and payload types. See the individual [drop-in documentation](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/) for details.

## Event subscription

Components subscribe to events when they need to respond to changes happening elsewhere in the application.

### Subscription syntax

To subscribe to an event, provide:

1. The **event name** (as a string)
2. An **event handler** callback function that receives the payload
3. Optional **configuration** parameters

```javascript
const subscription = events.on('event-name', handler, options);
```

### Subscription options

Event subscriptions support the following configuration:

- **`eager: true`**: The handler executes immediately if the event has been emitted previously. This is useful when you want to get the current state right away.
- **`eager: false`** (default): The handler only responds to future emissions of the event.

```javascript
// Execute immediately if event was already emitted
events.on('cart/initialized', (data) => {
  console.log('Cart data:', data);
}, { eager: true });

// Only respond to future events
events.on('cart/updated', (data) => {
  console.log('Cart updated:', data);
}, { eager: false });
```

### Example: Subscribing to an event

Listen to an initialization event:

```javascript

// Subscribe to the event
const subscription = events.on('cart/initialized', (data) => {
  console.log('Cart initialized with data:', data);
  // Handle the cart data
  updateUI(data);
});

// Later, unsubscribe when no longer needed
subscription.off();
```

> **Note:** Always unsubscribe from events when your component unmounts or when the subscription is no longer needed. This prevents memory leaks.

## Event emission

Components emit events when they want to share information with other parts of the application.

### Emission syntax

To emit an event, provide:

1. The **event name** (as a string)
2. The **payload** containing the data to share

```javascript
events.emit('event-name', payload);
```

### Example: Emitting an event

Emit an event when state changes:

```javascript

function updateCartQuantity(itemId, quantity) {
  // Update the cart
  const updatedCart = performCartUpdate(itemId, quantity);
  
  // Notify other components about the change
  events.emit('cart/updated', updatedCart);
}
```

## Common event patterns

Drop-ins use consistent naming conventions for their events:

- **`dropin/initialized`**: Fired when a drop-in completes initialization
- **`dropin/updated`**: Fired when a drop-in's state changes
- **`dropin/data`**: Provides current data state
- **`dropin/reset`**: Fired when a drop-in's state is reset
- **`dropin/error`**: Fired when an error occurs

### Event directions

Events can flow in different directions:

- **Emits**: The drop-in publishes this event for others to consume
- **Listens**: The drop-in subscribes to this event from external sources
- **Emits and listens**: The drop-in both publishes and subscribes to this event (bidirectional)

> **Note:** Each drop-in's event documentation clearly indicates which events it emits and which it listens to. This helps you understand the data flow in your storefront.

## Best practices

### 1. Use type-safe event names

Import event types when available to ensure you're using the correct event names:

```typescript

// TypeScript will validate the event name
events.on('cart/initialized', (data) => {
  // ...
});
```

### 2. Clean up subscriptions

Always unsubscribe when your component unmounts:

```javascript
// In a component lifecycle
const subscription = events.on('cart/updated', handleUpdate);

// On unmount or cleanup
subscription.off();
```

### 3. Use eager mode wisely

Set `eager: true` when you need the current state immediately:

```javascript
// Good: Getting initial state on component mount
events.on('cart/data', (data) => {
  initializeComponent(data);
}, { eager: true });

// Good: Only responding to future changes
events.on('cart/updated', (data) => {
  updateComponent(data);
}, { eager: false });
```

### 4. Keep handlers focused

Event handlers should be small and focused on a single responsibility:

```javascript
// Good: Focused handler
events.on('cart/updated', (cart) => {
  updateCartBadge(cart.itemCount);
});

// Avoid: Handler doing too much
events.on('cart/updated', (cart) => {
  updateCartBadge(cart.itemCount);
  updateMiniCart(cart);
  recalculateTotals(cart);
  logAnalytics(cart);
  // Too many responsibilities
});
```

### 5. Handle errors gracefully

Always include error listeners in production applications to gracefully handle failures and provide helpful feedback to users.

### 6. Use state management helpers

Use `events.lastPayload('<event>')` to retrieve the most recent state without waiting for the next event:

```javascript
// Get current authentication state
const currentAuth = events.lastPayload('authenticated');
if (currentAuth?.authenticated) {
  console.log('User is authenticated');
}

// Get current locale
const currentLocale = events.lastPayload('locale');
console.log('Current locale:', currentLocale);
```

---

## Common events reference

Many drop-ins listen for or emit common events that enable cross-component communication, authentication state management, localization, and error handling. These events provide a standardized way for your storefront to communicate with drop-ins and coordinate behavior across the application.

> **Note:** For drop-in-specific events, refer to each drop-in's individual Events page. This section only documents events that are shared across multiple drop-ins.

### Common event categories



| Event | Category | Used By | Description |
|-------|----------|---------|-------------|
| [authenticated](#authenticated) | Authentication | Most B2C & B2B drop-ins | Authentication state changes |
| [error](#error) | Error Handling | Most drop-ins | Error notifications |
| [locale](#locale) | Localization | All drop-ins | Language/locale changes |



---

### authenticated

**Category**: Authentication  
**Direction**: Emitted by external source, Listened to by drop-ins  
**Used By**: Cart, Checkout, Order, User Account, User Auth, Wishlist, and most B2B drop-ins

Fired when the user's authentication state changes (login, logout, token refresh, session expiration). Drop-ins listen to this event to update their internal state and UI based on the current authentication status.

#### When to emit

Emit this event from your storefront when:
- An authentication token is refreshed
- Authentication state is restored (e.g., page refresh with active session)
- A session expires
- A user logs out
- A user successfully logs in

#### Data payload

```typescript
{
  authenticated: boolean;
  userId?: string;
  email?: string;
  token?: string;
}
```

> **Note:** The exact payload structure may vary by implementation. At minimum, include an `authenticated` boolean. Consult your authentication service documentation for additional fields.

#### Usage

**Emit when authentication changes:**

```javascript

// User logged in
events.emit('authenticated', {
  authenticated: true,
  userId: 'user-123',
  email: 'user@example.com'
});

// User logged out
events.emit('authenticated', {
  authenticated: false
});
```

**Listen for authentication changes:**

```javascript

const authListener = events.on('authenticated', (data) => {
  if (data.authenticated) {
    console.log('User authenticated:', data.userId);
    // Update UI, load user-specific data, etc.
  } else {
    console.log('User logged out');
    // Clear user data, redirect to login, etc.
  }
});

// Later, when you want to stop listening
authListener.off();
```

---

### error

**Category**: Error Handling  
**Direction**: Emitted by drop-ins, Listened to by external code  
**Used By**: Most drop-ins for error reporting

Emitted when a drop-in encounters an error (API failure, validation error, network timeout, etc.). Your storefront should listen to this event to display error messages, log errors, or trigger error recovery logic.

#### When emitted

Drop-ins emit this event when:
- API requests fail
- Critical operations fail
- Network errors occur
- Unexpected errors occur
- Validation fails

#### Data payload

```typescript
{
  message: string;
  code?: string;
  details?: any;
  source?: string;
}
```

> **Note:** The exact payload structure varies by drop-in. The `message` field is typically always present. Check individual drop-in documentation for specific error structures.

#### Usage

**Listen for errors from drop-ins:**

```javascript

const errorListener = events.on('error', (error) => {
  console.error('Drop-in error:', error.message);
  
  // Display error to user
  showErrorNotification(error.message);
  
  // Log to error tracking service
  if (window.Sentry) {
    Sentry.captureException(error);
  }
  
  // Handle specific error codes
  if (error.code === 'AUTH_EXPIRED') {
    redirectToLogin();
  }
});

// Later, when you want to stop listening
errorListener.off();
```

**Emit errors from custom code:**

```javascript

try {
  // Your custom logic
  await customOperation();
} catch (err) {
  events.emit('error', {
    message: 'Custom operation failed',
    code: 'CUSTOM_ERROR',
    details: err,
    source: 'MyCustomComponent'
  });
}
```

---

### locale

**Category**: Localization  
**Direction**: Emitted by external source, Listened to by drop-ins  
**Used By**: All drop-ins with internationalization support

Fired when the application's language or locale changes. Drop-ins listen to this event to update their text content, date formatting, currency display, and other locale-specific elements.

#### When to emit

Emit this event from your storefront when:
- A user selects a different language
- The application detects and applies a locale based on user preferences
- The locale is programmatically changed

#### Data payload

```typescript
string
```

The locale string should follow standard locale format (e.g., `en-US`, `fr-FR`, `de-DE`).

#### Usage

**Emit when locale changes:**

```javascript

// User selects a new language
events.emit('locale', 'fr-FR');

// Or based on browser detection
const userLocale = navigator.language || 'en-US';
events.emit('locale', userLocale);
```

**Listen for locale changes:**

```javascript

const localeListener = events.on('locale', (newLocale) => {
  console.log('Locale changed to:', newLocale);
  // Update UI text, reload translations, etc.
  updateTranslations(newLocale);
});

// Later, when you want to stop listening
localeListener.off();
```

---

## Next steps

- Review the [Event Bus API Reference](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/events/) for detailed API methods and code examples
- Check individual drop-in event pages for component-specific events
- Try drop-in tutorials for practical event usage examples

---

# Extend, substitute, or create?

Commerce drop-ins offer three customization approaches. **Extending** existing drop-ins is the recommended and fully supported path. **Substituting** drop-ins with third-party solutions is sometimes necessary due to drop-ins' composable architecture. **Creating** new drop-ins with the Drop-in SDK (currently early access) is also possible. This guide helps you choose the right approach.

## Vocabulary



### Extend
Modify or enhance existing drop-ins using slots, styling, events, or configuration. This is the **recommended and fully supported** approach.

### Substitute
Replace an Adobe drop-in entirely with a third-party solution (like using Stripe for checkout). This comes with maintenance responsibilities and compatibility risks.

### Create
Build a brand-new drop-in from scratch using the SDK. Currently in **early access** with limited third-party support.

### Configuration
Settings and options that customize drop-in behavior without changing core functionality.

### Styling
Override CSS, modify layouts, and replace visual components to change how drop-ins appear without altering their core functionality.

### Slots
Declarative anchors where custom UI content can be injected into a drop-in.

### Events
Data events that drop-ins emit, allowing you to listen and add custom behavior.

### Transformers
Modify how drop-ins process and display data from Commerce APIs.

### SDK (Drop-in SDK)
Software Development Kit for building custom drop-ins from scratch (currently in early access).

### Third-party solution
External service or component that replaces an Adobe drop-in (for example, Stripe for checkout).



## Choose your approach


<Option>

### EXTEND

<Aside type="tip" title="Recommended approach">
Most customization needs can be met through slots, styling, events, and transformers without the complexity and maintenance burden of substitution or creation.
</Aside>

**Extend a drop-in if you need to:**
- Change how drop-ins look or behave
- Add custom content or UI elements
- Integrate third-party services (like payment methods)
- Respond to drop-in events with custom logic
- Modify how data is displayed or processed

**Note**: You can integrate third-party services using slots without replacing the entire drop-in. For example, integrate Stripe or PayPal payment methods into the Checkout drop-in rather than replacing the entire checkout flow.

#### Extension methods:
- **Slots** - Inject custom HTML/components at predefined points
- **Styling** - Override CSS, modify layouts, replace components
- **Events** - Listen to data events and add custom behavior
- **Configuration** - Modify drop-in settings and options
- **Transformers** - Change how drop-ins process and display data

#### Benefits:
- Fully supported by Adobe
- Automatic compatibility with updates
- Lower maintenance overhead
- Access to new features and bug fixes

</Option>

<Option>

### SUBSTITUTE

<Aside type="caution" title="Proceed with caution">
Substitution means you're responsible for maintaining compatibility with Commerce APIs and handling all future updates yourself.
</Aside>

**Replace an Adobe drop-in with a third-party solution if you have:**
- Complete solutions from a single provider (not just payment methods)
- Specialized functionality that doesn't align with Adobe's approach
- Legacy system integration requirements
- Provider-specific workflows requiring their complete UI and logic

#### Risks and responsibilities:
- **Maintenance burden** - You own all updates, bug fixes, and compatibility
- **API changes** - Must adapt to Commerce API changes independently
- **Feature gaps** - May miss out on new Commerce features
- **Support limitations** - Adobe cannot provide support for third-party code

</Option>

<Option>

### CREATE

<Aside type="caution" title='Early access considerations'>
The drop-in SDK is in early access with limited third-party support.

**Before building:** Contact Adobe to discuss your use case using the [Discord Commerce Storefront channel](https://discordapp.com/channels/1131492224371277874/1220042081209421945).
</Aside>

**Create a drop-in if you:**
- Have a use case that no existing drop-in addresses
- Are building entirely new functionality for multiple storefronts or brands
- Have the resources and expertise for long-term maintenance

</Option>


## Boundaries and limitations
Drop-ins work best for certain types of functionality. Understanding these boundaries helps you choose the right approach:

#### Drop-ins excel at:
- Commerce-specific UI components (product displays, cart management, checkout flows)
- Data-driven interfaces that connect to Commerce APIs
- Reusable functionality across multiple storefronts
- Components that benefit from Commerce's styling and theming system

#### Consider alternatives for these use cases:
- Simple static content (use HTML/CSS instead)
- Third-party integrations with existing UI (use vendor scripts)
- Highly merchant-specific logic (use application-level code)
- Temporary A/B testing variants (use feature flags)
- Single-use, non-reusable customizations

## Need a new extension point?
If existing drop-ins don't provide the slots or events you need:


1. **Document your use case** - Explain what you're trying to achieve
1. **Identify the gap** - What specific slot or event is missing?
1. **Submit a request** - Share your requirements in the [Discord Commerce Storefront channel](https://discordapp.com/channels/1131492224371277874/1220042081209421945)


## FAQs

**Q: Why does Adobe recommend extending over building new drop-ins?**  
Extending is fully supported, maintains compatibility with updates, and reduces maintenance overhead. Most customization needs can be met through extension without the risks associated with building from scratch or substituting drop-ins.

**Q: When is it acceptable to substitute a drop-in?**  
Substitution is acceptable when you need complete solutions from a single provider, have specialized functionality that doesn't align with Adobe's approach, need legacy system integration, or require provider-specific workflows with their complete UI and logic. However, you become responsible for maintaining compatibility with Commerce APIs and handling all updates independently.

**Q: Is the drop-in SDK ready for production use?**  
No. The SDK is currently in early access with limited third-party support and no timeline for full support. Contact Adobe before investing in custom drop-in development.

**Q: What extensibility options are available beyond slots?**  
While slots are the primary mechanism, you can also:
- Use configuration options to customize behavior
- Change how drop-ins look or behave (styling and layouts)
- Respond to drop-in events with custom logic
- Modify transformers to change how drop-ins process data

**Q: How do I know if my use case requires a new drop-in?**  
Follow the decision flow in this guide. Most needs can be met by extending existing drop-ins. Only consider building new drop-ins if you have a use case that no existing drop-in addresses, are building entirely new functionality for multiple storefronts or brands, and have the resources and expertise for long-term maintenance.

**Q: What happens if I substitute a drop-in and Commerce APIs change?**  
You're responsible for updating your substitute to maintain compatibility. Adobe cannot provide support for third-party substitutes, and you may miss out on new features or security updates.

---

# Extending drop-in components

Drop-in components are designed to be flexible and extensible. This guide provides an overview of how to extend drop-in components to add new features, integrate with third-party services, and customize the user experience.

## Extend drop-ins with Commerce APIs

The following steps describe how to add existing Commerce API services to a drop-in. For example, the Commerce API provides the necessary endpoints to fetch and update gift messages through GraphQL, but the checkout drop-in doesn't provide this feature out of the box. We will extend the checkout drop-in by adding a UI for gift messages, use the Commerce GraphQL API to update the message data on the cart, and extend the cart drop-in to include the message data when it fetches the cart.

### Step-by-step



<Task>
### Add your UI to the drop-in

The first step is to create a UI for the feature and add it to the checkout drop-in. You can implement the UI however you want, as long as it can be added to the HTML DOM. For this example, we'll implement a web component (`GiftOptionsField`) that provides the form fields needed to enter a gift message. Here's an example implementation of the UI component:

```js title='gift-options-field.js'

const sdkStyle = document.querySelector('style[data-dropin="sdk"]');
const checkoutStyle = document.querySelector('style[data-dropin="checkout"]');

class GiftOptionsField extends HTMLElement {
    static observedAttributes = ['cartid', 'giftmessage', 'fromname', 'toname', 'loading'];

    constructor() {
        super();
        this.attachShadow({ mode: 'open' });

        this._submitGiftMessageHandler = (event) => {
            event.preventDefault();
        }
    }

    set submitGiftMessageHandler(callback) {
        this._submitGiftMessageHandler = callback;
    }

    connectedCallback() {
        this._formTemplate = document.createElement('template');

        this._formTemplate.innerHTML = `
            <h2 class="checkout-payment-methods__title">Gift Message</h2>
            <form id="gift-options-form" class="checkout-fields-form__form">
                <div class="fromName-wrapper"></div>
                <div class="toName-wrapper"></div>
                <div class="giftMessage-wrapper dropin-field dropin-field--multiline"></div>
                
                <div class="submit-wrapper"></div>
            </form>
        `;

        this.render();
    }

    attributeChangedCallback(name, oldValue, newValue) {
        const toName = this.shadowRoot.querySelector('input[name="toName"]');
        const fromName = this.shadowRoot.querySelector('input[name="fromName"]');
        const giftMessage = this.shadowRoot.querySelector('textarea[name="giftMessage"]');
        const cartId = this.shadowRoot.querySelector('input[name="cartId"]');

        switch (name) {
            case 'cartid':
                cartId.value = newValue;
                break;
            case 'giftmessage':
                giftMessage.value = newValue;
                break;
            case 'fromname':
                fromName.value = newValue;
                break;
            case 'toname':
                toName.value = newValue;
                break;
            case 'loading':
                if (newValue) {
                    toName?.setAttribute('disabled', '');
                    fromName?.setAttribute('disabled', '');
                    giftMessage?.setAttribute('disabled', '');
                } else {
                    toName?.removeAttribute('disabled');
                    fromName?.removeAttribute('disabled');
                    giftMessage?.removeAttribute('disabled');
                }
                break;
        }
    }

    render() {
        this.shadowRoot.innerHTML = '';

        this.shadowRoot.appendChild(this._formTemplate.content.cloneNode(true));
        this.shadowRoot.querySelector('input[name="cartId"]').value = this.getAttribute('cartId');
        this.shadowRoot.querySelector('#gift-options-form').addEventListener('submit', this._submitGiftMessageHandler?.bind(this));

        const submitWrapper = this.shadowRoot.querySelector('.submit-wrapper');
        const fromNameWrapper = this.shadowRoot.querySelector('.fromName-wrapper');
        const toNameWrapper = this.shadowRoot.querySelector('.toName-wrapper');
        const giftMessageWrapper = this.shadowRoot.querySelector('.giftMessage-wrapper');

        UI.render(Input,
            {
                type: "text",
                name: "toName",
                placeholder: "To name",
                floatingLabel: "To name",
                value: this.getAttribute('toName'),
                disabled: !!this.hasAttribute('loading')
            })(toNameWrapper);
        UI.render(Input,
            {
                type: "text",
                name: "fromName",
                placeholder: "From name",
                floatingLabel: "From name",
                value: this.getAttribute('fromName'),
                disabled: !!this.hasAttribute('loading')
            })(fromNameWrapper);
        UI.render(TextArea,
            {
                name: "giftMessage",
                placeholder: "Message",
                value: this.getAttribute('giftMessage'),
                disabled: !!this.hasAttribute('loading')
            })(giftMessageWrapper);
        UI.render(Button,
            {
                variant: "primary",
                children: "Add Message",
                type: "submit",
                enabled: true,
                size: "medium",
                disabled: !!this.hasAttribute('loading')
            })(submitWrapper);

        this.shadowRoot.appendChild(sdkStyle.cloneNode(true));
        this.shadowRoot.appendChild(checkoutStyle.cloneNode(true));
    }
}

customElements.define('gift-options-field', GiftOptionsField);
```
</Task>

<Task>
### Render the UI into the checkout drop-in

Next, we need to render the `GiftOptionsField` component into the checkout page by creating the `gift-options-field` [custom element](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements).

```js
const GiftOptionsField = document.createElement('gift-options-field');
GiftOptionsField.setAttribute('loading', 'true');
```

Then, insert the custom element into the layouts defined on the checkout page. The following example updates the render function for mobile and desktop to insert the `giftOptionsField` element into the layouts.

```js title='commerce-checkout.js'
function renderMobileLayout(block) {
  root.replaceChildren(
    heading,
    giftOptionsField,
    ...
  );

  block.replaceChildren(root);
}

function renderDesktopLayout(block) {
  main.replaceChildren(
    heading,
    giftOptionsField,
    ...
  );

  block.replaceChildren(block);
}
```

</Task>

<Task>
### Add handler for gift message submission

Now that we have the UI in place, we need to add a handler to save the gift message data. We'll use the `fetchGraphl()` function from the API to send a GraphQL mutation to set the gift message on the cart.

```js title='commerce-checkout.js'
giftOptionsField.submitGiftMessageHandler = async (event) => {
  event.preventDefault();

  const form = event.target;
  const formData = new FormData(form);
  const cartId = formData.get('cartId');
  const fromName = formData.get('fromName');
  const toName = formData.get('toName');
  const giftMessage = formData.get('giftMessage');

  giftOptionsField.setAttribute('loading', 'true');
  console.log('form data', cartId, fromName, toName, giftMessage);

  const giftMessageInput = {
    from: fromName,
    to: toName,
    message: giftMessage,
  }

  fetchGraphQl(`
    mutation SET_GIFT_OPTIONS($cartId: String!, $giftMessage: GiftMessageInput!) {
        setGiftOptionsOnCart(input: {
          cart_id: $cartId,
          gift_message: $giftMessage
          printed_card_included: false
        }) {
					cart {
						id
						gift_message {
							from
							to
							message
						}
					}
        }
      }
    `,
    {
    variables: {
      cartId,
      giftMessage: giftMessageInput,
    },
  }).then(() => {
    refreshCart();
    giftOptionsField.removeAttribute('loading');
  });
};
```
</Task>

<Task>
### Extend the data payload for the drop-in

To extend the data payload of a drop-in, first you need to update the GraphQL fragment used by the cart drop-in to request the additional field. This is done by modifying the `build.mjs` script at the root of your storefront project. In the following example, the `CART_FRAGMENT` fragment is extended to include the gift message data whenever the cart drop-in requests the cart data from GraphQL:

```js title='build.mjs'
/* eslint-disable import/no-extraneous-dependencies */

// Extend the cart fragment to include the gift message
overrideGQLOperations([
  {
    // The name of the drop-in to extend
    npm: '@dropins/storefront-cart',
    // Additional fields to include in the cart results (gift_message)
    operations: [
      `fragment CART_FRAGMENT on Cart {
        gift_message {
          from
          to
          message
        }
      }`
    ],
  },
]);
```

When you run the install command, the `build.mjs` script generates a new GraphQL query for the cart drop-in that includes the `gift_message` data.

</Task>

<Task>

### Add new data to the payload

Map the new GraphQL data to the payload data that the cart events provide to listeners so they can access the gift message values.

Configure the cart drop-in's initializer to add the new cart data to the existing cart payload. This is done by defining a transformer function on the CartModel. This function receives the GraphQL data and returns an object that gets merged with the rest of the cart payload. As an example, here is how it might be configured:

```js title='cart.js'
/* eslint-disable import/no-cycle */

initializeDropin(async () => {
  await initializers.mountImmediately(initialize, {
    models: {
      CartModel: {
        transformer: (data) => {
          const { gift_message: giftMessage } = data;
          return {
            giftMessage,
          }
        }
      }
    }
  });
})();
```

Now when the cart emits an event with cart data, the `giftMessage` data is included.

</Task>

<Task>

### Retrieve the data and render it

Get the data from the cart event and use it to populate the gift message fields on the checkout page. Here's an example of how you might do this:

```js title='commerce-checkout.js'
// Event listener to hydrate the new fields with the cart data
events.on('cart/data', data => {
  if (!data) return;

  const { id, orderAttributes, giftMessage } = data;

  // Update gift options fields
  giftOptionsField.setAttribute('cartId', id);
  if(giftMessage) {
    giftOptionsField.setAttribute('giftmessage', giftMessage.message);
    giftOptionsField.setAttribute('fromname', giftMessage.from);
    giftOptionsField.setAttribute('toname', giftMessage.to);
  }
  giftOptionsField.removeAttribute('loading');
}, { eager: true });
```

</Task>

<Task>

### Summary

After just a few changes, we were able to add a new feature to the checkout drop-in that allows users to add a gift message to their order. We added a new UI component, integrated the Commerce API to fetch and update gift messages, and extended the data payload for the drop-in to include the gift message data. You can apply these same concepts to any drop-in.

</Task>



## Extend drop-ins with third-party components

The following steps guide you through adding a third-party component to a drop-in. We'll add a fictitious ratings & reviews component to the product details drop-in as an example.

### Prerequisites

- Third-party component API key. You typically need an API key to fetch data for the component.
- Familiarity with [project configurations](https://www.aem.live/docs/configuration).

### What you'll learn

- How to configure third-party API keys for use in drop-ins.
- How to use the `EventBus` to emit events and listen for events from the third-party component.
- How to delay loading large data sets from third-party components to improve page performance.

### Step-by-step



<Task>
### Add your third-party API key

Add your API key to your commerce configuration in your project's `config.json` file.

```json
{
  "public": {
    "default": {
      "commerce-core-endpoint": "MY_ENDPOINT",
      // other config...
      "third-party-api-key": "THIRD_PARTY_API_KEY"
    }
  }
}
```

</Task>

<Task>
### Fetch the API key

To fetch the API key, you need to import the `getConfigValue` function from the `configs.js` file. This function reads the API key from the config file and returns the value. You can then use this value to fetch data from the third-party service.

```js

export default async function decorate(block) {
  // Fetch API key from the config file
  const thirdPartyApiKey = await getConfigValue('third-party-api-key');

  // Fetch the component data
  setRatingsJson(product, thirdPartyApiKey);
}
```

</Task>

<Task>
### Fetch the component data

After the page loads, your third-party component likely needs to fetch some data. In our case, our ratings & reviews component needs to fetch data from its rating service to display the star-rating for the product. After your API key is fetched (`thirdPartyApiKey`), you can trigger a call to the service's endpoint and use the EventBus to emit an event when the data is received.

```js

function setRatingsJson(product, thirdPartyApiKey) {
  try {
    fetch(`https://api.rating.service.com/products/${thirdPartyApiKey}/${product.externalId}/bottomline`).then(e => e.ok ? e.json() : {}).then(body => {
      const { average_score, total_reviews } = body?.response?.bottomline || {};
      setHtmlProductJsonLd({
        aggregateRating: {
          '@type': 'AggregateRating',
          ratingValue: average_score || 0,
          reviewCount: total_reviews || 0,
        }
      });

      events.emit('eds/pdp/ratings', {average: average_score, total: total_reviews});
    });
} catch (error) {
    console.log(`Error fetching product ratings: ${error}`);
    setHtmlProductJsonLd({
      aggregateRating: {
        '@type': 'AggregateRating',
        ratingValue: 0,
        reviewCount: 0,
      }
    });

    events.emit('eds/pdp/ratings', {average: 0, total: 0});
  }
}
```

</Task>

<Task>
### Render the component

To ensure the least amount of CLS, we'll make sure we don't render the component until after its data is returned. To do this, we need to add an event listener for the third-party component's event. This strategy, along with reserving a predefined space for the component, will minimize CLS. Here's an example implementation for our third-party ratings component:

```js
events.on('eds/pdp/ratings', ({ average, total }) => {
  // Title slot logic
  const titleSlotElement = document.querySelector('.title-slot');

  // Optionally reserve space for the star rating to avoid CLS
  // e.g., setting a placeholder element or CSS min-height

  // Render star rating
  titleSlotElement.innerHTML = `
    <div class="star-rating">
      <span>Average Rating: ${average.toFixed(1)}</span>
      <span>(${total} reviews)</span>
    </div>
  `;
});
```
</Task>

<Task>
### Delay loading large data sets

Components like ratings & reviews typically load large blocks of text to display a product's reviews. In such cases, we need to ensure that those reviews are not loaded until the user scrolls near the reviews section or clicks a "View All Reviews" button. This strategy keeps the First Contentful Paint (FCP) and Cumulative Layout Shift (CLS) scores low.

The following example uses an Intersection Observer to load reviews only when a user scrolls near the reviews section or clicks "View All Reviews".

```js
// Trigger the delayed load when the user scrolls near the reviews section or clicks "View All Reviews"
const reviewsSection = document.getElementById('reviews-section');

const loadReviews = () => {
  // Fetch or render the full reviews only when needed
  fetch(`/path/to/full-reviews?apiKey=${YOUR_API_KEY}&productId=${PRODUCT_ID}`)
    .then(response => response.json())
    .then(data => {
      reviewsSection.innerHTML = data.reviewsHtml;
    })
    .catch(console.error);
};

// Event listener approach for a "View All Reviews" button
document.getElementById('view-reviews-btn').addEventListener('click', loadReviews);

// OR intersection observer approach to load when user scrolls near the section
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      loadReviews();
      observer.disconnect();
    }
  });
}, { threshold: 0.1 });

observer.observe(reviewsSection);
```

</Task>

<Task>
### Summary

Throughout this tutorial, we examined the key steps of integrating a fictitious third-party component. We learned how to configure API keys, fetch data, and delay loading data sets to improve page performance. You can apply these same concepts to any drop-in.
</Task>

---

# Installing drop-in components

Drop-in components are designed for the browser's JavaScript run-time without the need for a bundler. But they can also be installed and executed in a build-time environment with bundlers like Webpack and Vite. The installation steps for both run-time and build-time environments are the same after the initial drop-in component package imports.

## Why install drop-in components?

Installing drop-in components is essential for customizing and enhancing your Adobe Commerce storefront, especially if you choose not to start with the [boilerplate template](https://experienceleague.adobe.com/developer/commerce/storefront/get-started/boilerplate-project/). It is a strategic choice for businesses looking to customize, optimize, and scale their Adobe Commerce storefronts effectively. This approach provides the flexibility and modularity needed to create a unique and high-performing online shopping experience.

If you have an existing storefront project and are not starting with the boilerplate template, you can install drop-in components individually to add the specific features that you need.

## Workflow

The following diagram provides an overview of the steps necessary for installing a drop-in:

![PDP Installation](@images/pdp/pdp-installation.svg/)

The installation of all drop-in components follows the same pattern described in the workflow diagram above. Refer to the following resources for step-by-step instructions to install specific drop-in components:

- [Product details page (PDP)](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/installation/)
- [Cart](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/installation/)
- [Checkout](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/installation/)

---

# Introduction to drop-in components

Drop-in components (with Commerce services) make up the entire storefront experience. They are equivalent to small apps that you can mix and match to create a storefront that fits your needs.

## What are drop-in components?

Drop-in components are full-featured shopping components. They are not primitive components like Carousels and Galleries. drop-in components _define_ the storefront shopping experience. Our drop-in components include product details, carts, checkout, user authentication, user accounts, with more on the way. This section introduces these drop-in components and provides links to their details.

### Cart

The [cart](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/) drop-in
provides a summary of the items that the user has added to their cart. It allows users to view and
manage their cart contents, update quantities, and proceed to checkout. The cart is a critical
component of the e-commerce experience, providing users with a convenient way to review and adjust
their selections before completing their purchase.

### Checkout

The [checkout](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/)
drop-in component is a key component of the e-commerce experience, providing users with a streamlined process
for completing their purchase. It allows users to enter shipping and payment information, review
their order details, and confirm their purchase.

### Order

The [order](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/order/) drop-in component provides a comprehensive set of tools and containers designed to manage and display order-related data across various pages and scenarios. It simplifies the implementation of order management functionality and supports seamless integration with both customer accounts and guest user workflows.

### Payment Services

The [Payment Services](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/payment-services/) drop-in renders the credit card form, allowing shoppers to efficiently enter their payment details. The drop-in currently supports credit/debit cards only.

### Product details

The [product details](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/) drop-in component renders detailed information about products
and services, including SKUs, pricing, descriptions, and customizable options, with built-in support
for internationalization and accessibility. This drop-in component is a key component of the e-commerce
experience, providing users with essential product information to enable informed
purchasing decisions.

### Product Discovery

The [product discovery](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/) drop-in component you can create a seamless and engaging shopping experience for your customers by allowing them to easily find and explore products that match their interests.

### Recommendations

The [recommendations](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/recommendations/) drop-in component provides a powerful way to suggest products to customers based on their browsing patterns and behaviors. These recommendations are displayed as units with descriptive labels such as "Customers who viewed this product also viewed" or "Customers who bought this product also bought". The component can be managed and deployed across different store views directly from the Adobe Commerce Admin.

### User account

The [user account](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/) drop-in component
provides users with a personalized experience, allowing them to view their order history, manage
their account settings, and access other account-related features.

### User authentication

The [user authentication](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/) drop-in component provides users with a secure and seamless way to log in
or create an account on your e-commerce platform. It supports various authentication methods,
including email, social media, and single sign-on (SSO), ensuring a smooth user experience across
devices and platforms.

### Wishlist

The [wishlist](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/wishlist/) drop-in component provides both guests and registered customers with a mechanism to store products they are interested in purchasing later.

## How can I customize drop-in components?

All drop-in components can be customized in five ways: design tokens, CSS classes, slots, content enrichment, and localization. In this section, you'll learn how to use each approach.

### Design tokens

[Design tokens](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/branding/) are the quickest way to customize your storefront. By changing the default token values with your own brand colors, typography, spacing, and shapes, you can make quick, global brand changes to your entire storefront.

### CSS classes

[CSS classes](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/styling/) provide deeper style changes for drop-in components than design tokens. Overriding or adding new CSS classes allows you to restyle specific areas of the drop-in component. You'll find best practices for styling here.

### Slots

[Slots](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/extending/) provide the deepest level of customization. Slots are built-in extension points in the drop-in component to add your own UI components and functions. You'll learn how powerful slots can be.

### Localization

[Localization](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/labeling/) is one of the easiest ways to customize drop-in components for a region. This topic shows you how to add and use a second language file in your drop-in components.

---

# Labeling and localizing drop-in components

In this topic, you will learn how to update drop-in component labels by using the resources available in the commerce boilerplate.

## Key concepts



### Placeholders files

Multiple JSON files to manage storefront labels, including localization. Each drop-in component has its own placeholders file (e.g., `cart.json`, `checkout.json`, `pdp.json`). See the [Placeholders files](https://experienceleague.adobe.com/developer/commerce/storefront/resources/placeholders/) for more information.

### Language objects

A JavaScript object (named `langDefinitions` by convention) that contains key-value pairs for UI text labels in a specific language. The object is used to override the default dictionary with the placeholder file's keys and values.

### Labeling

To add or change UI text labels within Commerce drop-in components. Merchants use placeholer files to quickly change the default UI labels for drop-in components.

### Localizing

To adapt UI text labels and formatting for a specific language. This process includes translating text labels and changing the text direction, date and time formats, and currency symbols to match the target language.



## Big picture

Labeling drop-in components in the storefront involves two files:


1. The **placeholders files** that provide the default drop-in component UI labels that merchants can quickly update as needed.
2. The **drop-in block** (examples, `product-details.js`, `cart.js`) where you add code to fetch, map, and override the drop-in component dictionary at runtime.


The following diagram shows the process for adding and overriding labels and text for drop-in components within the boilerplate template.


  ![How localization and labeling works in storefronts.](@images/DropinDictionaries.svg/)




1. **Placeholder files**. Merchants can change the storefront labels by changing the values in the placeholder JSON files, which are organized by drop-in componentsâ€”`cart.json`, `checkout.json`, `pdp.json`, and so on.
1. **Import function**. You need to import the `fetchPlaceholders` function from the boilerplate's `commerce.js` file.
1. **Fetch placeholders.** Use the `fetchPlaceholders` function to retrieve the `placeholders` key-value pairs from the content folder.
1. **Override default dictionary**. Override the `default` property from the `langDefinitions` object with the keys and values from the `placeholder` object.
1. **Initialize dictionary**. Use the `register` function to update the dictionary at runtime.



## Step-by-step

In the boilerplate code, the UI text labels in drop-in components come from the placeholder files. By using these files as the source for all storefront UI labels, merchants can easily change labels without involving developers.

There are two things to be aware of when using the `fetchPlaceholders()` function:

1. **During initialization**:  
   You must provide the path to the drop-inâ€™s placeholders file. This file will be fetched and merged into the existing placeholders object. Subsequent calls to `fetchPlaceholders()` without a path will return the merged object containing all fetched labels.

2. **After initialization**:  
   You can call `fetchPlaceholders()` without a path to retrieve all initialized placeholders as a single object. This object can be accessed from a Block or anywhere else in the project.



<Task>
### Import `fetchPlaceholders` function

In the drop-in block (for example, `product-details.js`, `cart.js`), import the `fetchPlaceholders` function from the boilerplate's `commerce.js` file.

```javascript
```
</Task>

<Task>
### Initialize placeholders with path

During initialization, you must use the `fetchPlaceholders()` function using an argument to the path to your drop-in's placeholders file. This fetches and merges the placeholders into the global object.

```javascript
// Initialize placeholders for this drop-in
const placeholders = await fetchPlaceholders('placeholders/cart.json');

const langDefinitions = {
  default: {
    ...placeholders,
  },
};

// Register Initializers
initializers.mountImmediately(initialize, {
  langDefinitions,
  //...
});
```
</Task>

<Task>
### Fetch placeholders after initialization

After initialization, you can use the `fetchPlaceholders` function without a path to retrieve all merged placeholders. The following diagram and code snippet shows how to fetch the placeholders.

<Diagram caption="Using placeholder labels in your EDS commerce block">
  ![Using placeholder labels in your EDS commerce block](@images/LabelUsage.svg/)
</Diagram>

```javascript
// Retrieve the placeholders language object
const labels = await fetchPlaceholders();

export default async function decorate(block) {
  const $elem = document.createElement('div');
  $elem.innerText = labels.Cart.PriceSummary.shipping.label;
}
```
</Task>

<Task>
### Test the changes

After you've updated the drop-in component dictionary with the new `langDefinitions` object, test the changes in the storefront to ensure the new labels are displayed correctly. If the labels are not displaying as expected, review the mapping between the placeholder keys and the drop-in component dictionary keys. Make sure the keys match exactly. If the keys don't match, the drop-in component will use the default dictionary values.
</Task>

---

# Commerce block layouts

A drop-in component's layout is defined by an HTML fragment that controls where the drop-in's containers appear on the page. You can customize the layout as you would with any HTML, by using CSS and adding, removing, or rearranging the elements in the HTML. In this topic, we'll customize the product details layout by adding the Product Recommendations block.

## Big Picture

This screenshot shows the product details page with the Product Recommendations block below the product gallery container.


![Add Product Recommendations block to the page](@images/ProductDetailsLayout.png/)


## Customize commerce block layouts

For this use case, we'll customize the product details layout by adding the Product Recommendations block inside the product details block, instead of below it.


<Task>
### Add an Edge Delivery block to a commerce page

For example, add a Product Recommendations block to the product details page so that it can be rendered on the page, then referenced and moved to the layout (in code):

<Diagram caption="Add Product Recommendations block to the page">
![Add Product Recommendations block to the page](@images/PrexBlockPDP.png/)
</Diagram>

</Task>

<Task>
### Add an element to the layout and reference it

Add an HTML element to the commerce block's layout where you want the Edge Delivery block (or other content) to appear. In this example, we want the Product Recommendations block to appear in the left column of the product-details layout, below the product gallery. So we add a `div` element to the left column with a class of `product-details__prex`.

```js ins={12}
export default async function decorate(block) {
  // eslint-disable-next-line no-underscore-dangle
  const product = events._lastEvent?.['pdp/data']?.payload ?? null;
  const labels = await fetchPlaceholders();

  // Layout
  const fragment = document.createRange().createContextualFragment(`
    <div class="product-details__wrapper">
      <div class="product-details__alert"></div>
      <div class="product-details__left-column">
        <div class="product-details__gallery"></div>
        <div class="product-details__prex"></div>
      </div>
      <div class="product-details__right-column">
        <div class="product-details__header"></div>
        <div class="product-details__price"></div>
        <div class="product-details__gallery"></div>
        <div class="product-details__short-description"></div>
        <div class="product-details__configuration">
          <div class="product-details__options"></div>
          <div class="product-details__quantity"></div>
          <div class="product-details__buttons">
            <div class="product-details__buttons__add-to-cart"></div>
            <div class="product-details__buttons__add-to-wishlist"></div>
          </div>
        </div>
        <div class="product-details__description"></div>
        <div class="product-details__attributes"></div>
      </div>
    </div>
  `);
```

Then, we reference the `div` element in the layout as follows:

```js
  // Reference the element
  const $prex = fragment.querySelector('.product-details__prex');
```
</Task>

<Task>
### Move the Edge Delivery block to the layout

Within the `eds/lcp` lifecycle event, query the Edge Delivery block's class selector from the rendered block and append it to right element in the layout. In this example, we select the Product Recommendations block using the `.product-recommendations` class, then move it to the element you want in the layout (`$prex`).

```js ins={9-12}
  events.on(
    'eds/lcp',
    () => {
      if (product) {
        setJsonLdProduct(product);
        setMetaTags(product);
        document.title = product.name;
      }
      const $productRecommendations = document.querySelector('.product-recommendations');
      if ($productRecommendations) {
        $prex.appendChild($productRecommendations);
      }
    },
    { eager: true },
  );
```
</Task>

---

# Localizing links

The best practice for localizing URL text is to store it within the content. Alternatively, you can use functions from `scripts/commerce.js` to localize links programmatically."

## decorateLinks

The `decorateLinks` function automatically prepends all content links with the root path for each language.

This function is enabled by default in the Commerce Boilerplate via `scripts/script.js`.

```js

/**
 * Decorates the main element.
 * @param {Element} main The main element
 */
export function decorateMain(main) {
  decorateLinks(main); // enables localizationb of links
  decorateButtons(main);
  decorateIcons(main);
  buildAutoBlocks(main);
  decorateSections(main);
  decorateBlocks(main);
}
```

## rootLink

The `rootLink` function prepends the appropriate language root path to a given link. Use it within a block to localize links from a drop-in for loading scripts, styles or links to other pages within a drop-in. This approach ensures consistency across languages and store views.

```js

export async function decorateMyBlock(block) {
  const atag = document.createElement('a');
  atag.innerText = 'My Link';
  atag.href = rootLink('/my-path'); // returns the localized url for '/my-path'
  // ...
}
```

---

# Using drop-in slots

Using slots provides the deepest level of customization for drop-in components. Slots are built-in extension points in the drop-in. A slot provides a place in the drop-in component to add your own UI components and functions. This architecture makes it easy to change the default look, layout, and behavior. Let's learn how slots work.

## Big Picture

![What is a slot?](@images/slots/what-is-a-slot.svg/)

The following functions are available to all slots:



1. `prependSibling`: A function to prepend a new HTML element before the slot's content.
1. `prependChild`: A function to prepend a new HTML element to the slot's content.
1. `replaceWith`: A function to replace the slot's content with a new HTML element.
1. `appendChild`: A function to append a new HTML element to the slot's content.
1. `appendSibling`: A function to append a new HTML element after the slot's content.
1. `remove`: A function to remove the slot from the DOM.
1. `getSlotElement`: A function to get a slot element.
1. `onChange`: A function to listen to changes in the slot's context.
1. `dictionary`: JSON Object for the current locale. If the locale changes, the `dictionary` values change to reflect the values for the selected language.



## Vocabulary



### Container

Component that manages or encapsulates other components. Containers handle logic, fetch data, manage state, and pass data to the UI components that are rendered on the screen.

### Slot

Component that provides placeholders to add other components. You can use a drop-in component's built-in slots to add or remove UI components and functions. Or you can add your own additional slots.

### Component

In web development, this term is overused. That's why we need to be specific about the kind of component we are talking about. Here's a few examples of components from top-to-bottom: a **drop-in component** can contain multiple **container components** that can contain multiple **slot components** that can contain multiple **UI components**.

---

# Styling drop-in components

Overriding and adding CSS classes for drop-in components provides the next level of customizing your storefront drop-in components. By modifying a drop-in component's built-in CSS classes and adding additional classes, you can quickly change the built-in classes to meet your specifications. You'll find best-practices for styling here.


The CSS classes for each UI component that provides the product details drop-in component with its UI are provided here. Override these classes and add new classes to customize the look and feel of your PDP drop-in component to match your specific style requirements.

:::tip[CSS Tip!]
Drop-in components contain several components that provide its UI. If you plan to make several CSS changes to the drop-in component, we suggest creating individual CSS files for each component in your drop-in component and import those into an aggregate `drop-in.css` file as shown below. This practice makes it easier to maintain and update your CSS as your changes accumulate.

This example shows how to import several CSS files into a single `drop-in.css` file:

```css title="drop-in.css"
@import 'carousel.css';
@import 'gallery-grid.css';
@import 'overlay.css';
@import 'price-range.css';
@import 'product.css';
@import 'swatches.css';
```

:::

## Step-by-step

The quickest way to override the CSS classes used in the drop-in component is to inspect the drop-in component's UI from your browser's developer tools. The following example shows a product details component with the classes applied to the UI components that compose the drop-in:


  ![Find CSS classes to override](@images/dropins/findstyles.webp/)




1. **Inspect the element** in the UI that you want to customize (right-click on the element and select "Inspect" from the menu).
1. **Identify the CSS class(es)** for the element. We use [BEM naming](https://getbem.com/naming/), which makes it easy to know which component you're changing (and which CSS file to use). This class styles the `Product` component, so use your `product.css` file.
1. **Copy the CSS class** to your `product.css` file to override the existing rules or add new rules to the class. But wait! Look closely ðŸ§ at the `.pdp-product__title` class. It's using two **design tokens**. And when you see a design token within a CSS rule, don't remove the token. Instead, change the token's value (where it's defined) OR create a new token along-side this existing one to ensure maintenance and updates continue to benefit from global design token usage.



## Example overrides

Here's an example of adding CSS class overrides to your `product.css` file:

```css title="product.css"
.pdp-product__options {
  grid-column: 1 / span 3;
}

.pdp-product__quantity {
  grid-column: 1 / span 3;
}

.pdp-product__buttons {
  grid-gap: 0.5rem;
}
```

---

# CartSummaryGrid container

The `CartSummaryGrid` container manages and displays the contents of the shopping cart in a grid layout. Its state is managed by the `CartModel` interface, which contains the cart's initial data and is passed down to any child components.


  ![CartSummaryGrid container](@images/dropins/cart/cart-summary-grid-small.png/)


## Configurations

The `CartSummaryGrid` container provides the following configuration options:



The `CartModel` object has the following shape:



## Example configuration

The following example demonstrates how to render the `CartSummaryGrid` container with the `routeProduct` and `routeEmptyCartCTA` callbacks:

```js
          provider.render(CartSummaryGrid, {
            routeProduct: (item) => {
              return `${item.url.categories.join('/')}/${item.url.urlKey}`;
            },
            routeEmptyCartCTA: () => '#empty-cart',
          })(document.getElementById('@dropins/CartSummaryGrid'));
```

---

# CartSummaryList container

The `CartSummaryList` container displays a summary of the items in the shopping cart by rendering a list of `CartItem` components. Each `CartItem` represents an individual item in the cart.


  ![CartSummaryList container](@images/dropins/cart/cart-summary-list.png/)



## Configurations

The `CartSummaryList` container provides the following configuration options:



The `CartModel` object has the following shape:



## Supported slots

The `CartSummaryList` container supports the following slots:

* Heading
* EmptyCart
* Footer
* Thumbnail
* ProductAttributes
* CartSummaryFooter
* CartItem
* UndoBanner
* ItemTitle
* ItemPrice
* ItemQuantity
* ItemTotal
* ItemSku
* ItemRemoveAction

## Example configuration

The following example demonstrates how to render the `CartSummaryList` container with the `routeProduct` and `routeEmptyCartCTA` callbacks:

```js
provider.render(CartSummaryList, {
  enableRemoveItem: true,
  enableUpdateItemQuantity: true,
  showDiscount: true,
  // accordion: true,
  // showMaxItems: false,
  // maxItems: 6,
  // routeCart: () => '#cart',
  // showSavings: true,
  // quantityType: 'dropdown',
  // dropdownOptions: [
  //   { value: '1', text: '1' },
  //   { value: '2', text: '2' },
  //   { value: '3', text: '3' },
  // ],
  routeProduct: (item) => {
    return `${item.url.categories.join('/')}/${item.url.urlKey}`;
  },
  routeEmptyCartCTA: () => '#empty-cart',
  slots: {
    Footer: (ctx) => {
      // Runs on mount
      const wrapper = document.createElement('div');
      ctx.appendChild(wrapper);

      // Append Product Promotions on every update
      ctx.onChange((next) => {
        wrapper.innerHTML = '';

        next.item?.discount?.label?.forEach((label) => {
          const discount = document.createElement('div');
          discount.style.color = '#3d3d3d';
          discount.innerText = label;
          wrapper.appendChild(discount);
        });
      });
    },
  },
})($cartSummaryList);

---

# CartSummaryTable container

The `CartSummaryTable` container displays a summary of the items in the shopping cart by rendering a table of cart items. Each row represents an individual item in the cart, with columns for the item details, price, quantity, subtotal, and actions.


  ![CartSummaryGrid container](@images/dropins/cart/cart-summary-table.png/)


## Features

The `CartSummaryTable` container includes the following features:

- Automatic loading state with skeleton UI
- Support for out-of-stock items with visual indicators
- Quantity update functionality with error handling
- Item removal capability
- Tax price display (including/excluding)
- Product image display with lazy loading
- Configurable product routing
- Customizable slots for all major components
- Support for product configurations
- Warning and alert message display
- Discount and savings display

## Configurations

The `CartSummaryTable` container provides the following configuration options:



The `CartModel` object has the following shape:



## Supported slots

The `CartSummaryTable` container supports the following slots for customization:

* **Item**: Customize the item cell content
  * Context: `{ item: CartModel['items'][number] }`

* **Price**: Customize the price cell content
  * Context: `{ item: CartModel['items'][number] }`

* **Quantity**: Customize the quantity cell content
  * Context: `{ 
      item: CartModel['items'][number],
      isUpdating: boolean,
      quantityInputValue: number,
      handleInputChange: (e: Event) => void,
      itemUpdateErrors: Map<string, string>
    }`

* **Subtotal**: Customize the subtotal cell content
  * Context: `{ item: CartModel['items'][number] }`

* **Thumbnail**: Customize the thumbnail image on an item
  * Context: `{ 
      item: CartModel['items'][number],
      defaultImageProps: ImageProps,
      index: number
    }`

* **ProductTitle**: Customize the product title on an item
  * Context: `{ item: CartModel['items'][number] }`

* **Sku**: Customize the product SKU on an item
  * Context: `{ item: CartModel['items'][number] }`

* **Configurations**: Customize the product configurations on an item
  * Context: `{ item: CartModel['items'][number] }`

* **ItemAlert**: Customize the product alert on an item
  * Context: `{ item: CartModel['items'][number] }`

* **ItemWarning**: Customize the product warning on an item
  * Context: `{ item: CartModel['items'][number] }`

* **Actions**: Customize the actions on an item
  * Context: `{ 
      item: CartModel['items'][number],
      itemsUpdating: Map<string, { isUpdating: boolean, updatedValue: number }>,
      setItemUpdating: (uid: string, state: boolean) => void,
      setItemUpdateError: (uid: string, error: string) => void
    }`

## Example configuration

The following example demonstrates how to render the `CartSummaryTable` container with the some of the configuration options and slots:

```js
provider.render(CartSummaryTable, {
  initialData: cartData,
  allowQuantityUpdates: true,
  allowRemoveItems: true,
  routeProduct: (item) => `/products/${item.urlKey}`,
  onQuantityUpdate: (item, quantity) => {
    // Handler after quantity update
  },
  onItemRemove: (item) => {
    // Handler after item removal
  },
  slots: {
    Item: (ctx) => {
      // Custom item cell content
    },
    Price: (ctx) => {
      // Custom price cell content
    },
    // ... other slot customizations
  }
});
```

---

# Coupons container

The `Coupons` container manages the application of coupons to the shopping cart. It provides a text box for users to enter coupon codes. The container uses the `applyCouponsToCart` function to apply the coupon to the cart.


  ![Coupons container](@images/dropins/cart/apply-coupon.png/)


## Configurations

The `Coupons` container provides the following configuration options:



## Example configuration

The following example demonstrates how to render the `Coupons` container as part of the OrderSummary slot:

```js
{
        provider.render(OrderSummary, {
          routeCheckout: () => '#checkout',
          slots: {
            Coupons: (ctx) => {
              const coupons = document.createElement('div');

              provider.render(Coupons)(coupons);

              ctx.appendChild(coupons);
            },
          },
          showTotalSaved: true,
        })('.cart__order-summary'),

---

# EmptyCart container

The `EmptyCart` container renders a message or component indicating that the cart is empty.
It can provide navigation options to continue shopping or explore products.


  ![EmptyCart container](@images/dropins/cart/empty-cart.png/)



## Configurations

The `EmptyCart` container provides the following configuration options:



## Example configuration

The following example demonstrates how to render the `EmptyCart` container:

```js
    provider.render(EmptyCart, {
      routeCTA: startShoppingURL ? () => startShoppingURL : undefined,
    })($emptyCart),
```
`;

---

# EstimateShipping container

The `EstimateShipping` container renders a form that allows shoppers to estimate shipping costs based on their specified location. The form includes fields for the shopper to enter their country, state, and postal code.


  ![EstimateShipping container](@images/dropins/cart/estimate-shipping.png/)


## Configurations

The `EstimateShipping` container provides the following configuration options:



## Example configuration

The following example demonstrates how to render the `EstimateShipping` container:

```js
EstimateShipping: (ctx) => {
  const estimateShippingForm = document.createElement('div');

provider.render(EstimateShipping, {
    showDefaultEstimatedShippingCost: true,
})('#estimate-shipping');

---

# GiftCards container

The `GiftCards` container manages the application and removal of gift cards to the shopping cart. It provides a text box for users to enter gift card codes. The container uses the `applyGiftCardToCart` and `removeGiftCardFromCart` functions to apply the coupon to the cart. When a gift card code is applied, the corresponding amount is subtracted from the total order value, and the discount is displayed in the cart and order summary.

The Adobe Commerce merchant can manage gift card configuration from **Marketing** > **Gift Card Accounts**.


  ![GiftCards container](@images/dropins/cart/gift-cards.png/)


## Configurations

The `GiftCards` container provides the following configuration options:



## Example configuration

The following example demonstrates how to render the `GiftCards` container as part of the OrderSummary slot:

```js
provider.render(OrderSummary, {
 routeProduct: (product) => rootLink(`/products/${product.url.urlKey}/${product.topLevelSku}`),
 routeCheckout: checkoutURL ? () => rootLink(checkoutURL) : undefined,
 slots: {
   GiftCards: (ctx) => {
     const giftCards = document.createElement('div');

     provider.render(GiftCards)(giftCards);

     ctx.appendChild(giftCards);
   },
 },
})($summary);

```

---

# GiftOptions container

The `GiftOptions` container allows shoppers to personalize their orders by adding gift wrapping and a gift message for each cart item or by applying gift-related options to the entire order. It can be displayed in a product or order view, with each view supporting both editable and non-editable modes, controlled via props.

Products can have the following gift options:

* Gift wrapping
* Gift message

Orders can have the following gift options:

* Gift receipt
* Printed card
* Gift wrapping
* Gift message

The following diagrams illustrate how gift options can be rendered.


  ![GiftOptions container with all available options](@images/dropins/cart/gift-options-unset.png/)



  ![GiftOptions container with options that have been set](@images/dropins/cart/gift-options-set.png/)


## Admin configuration

Gift options highly configurable, allowing merchants to manage gift options at both the global and product levels. This flexibility ensures that gift options can be tailored to meet the specific needs of the store and its products. These configurations determine how your frontend code will behave and what options will be available to customers during the shopping experience.

### Global configuration

The merchant can manage global gift option configurations from the Admin at **Stores** > Configuration > **Sales** > **Sales** > **Gift Options**. The following options are available:

* **Allow Gift Messages on Order Level**
* **Allow Gift Messages for Order Items**
* **Allow Gift Wrapping on Order Level**
* **Allow Gift Wrapping for Order Items**
* **Allow Gift Receipt**
* **Allow Printed Card**
* **Default Price for Printed Card**

Global configurations apply to all products unless overridden by product level configurations.

### Product-level configuration

Each product can have its own gift option configuration, which takes precedence over the global configurations. To manage product-level configurations, the administrator must ensure that the product is enabled for gift options. This can be done by setting the following options in the product configuration (**Catalog** > **Products** > _Product_ > **Gift Options**):

**Allow Gift Message** - If enabled, customers can add a personalized gift message for this product even if gift messages are globally disabled. If disabled, gift messages will not be available for this product, even if globally enabled.

**Allow Gift Wrapping** - If enabled, customers can select a gift wrapping for this product even if gift wrapping is globally disabled. If disabled, gift wrapping will not be available for this product, even if globally enabled. If gift wrapping is disabled at least for one product in cart, you cannot apply gift wrapping to the whole order, even if order-level gift wrapping is enabled globally.

**Price for Gift Wrapping** - If set, overrides the pricing for all gift-wrapping options for this product.

### Gift wrapping configuration

Gift wrapping options can be configured and managed from **Stores** > Configuration > **Gift Wrapping**. Settings include a title, price, and image for each gift wrapping option.

### Tax Display configuration

Tax display settings define how taxes for gift options are shown on different pages, such as the cart and order summary. These settings can be configured under **Stores** > Configuration > **Sales** > **Tax**.

## Container configurations

The `GiftOptions` container provides the following configuration options:



For the `dataSource` prop, specify `cart` when the source of truth is the cart page, meaning gift options are applied at the cart level and the container should initialize with the currently selected gift options. Also, specify card on any other page where the cart drop-in fires a `cart/data` event. Specify `order` when the source of truth is a previously-placed order or if the page is controlled by the order drop-in and initialized by an `order/data` event.

For the `view` prop, specify `product` when the `GiftOptions` container is rendered at the product level, allowing users to configure gift options for a specific product. Use `order` when the container is rendered at the order level, enabling users to configure gift options for the entire order.

Set the `isEditable` prop to `true` when gift options should be editable, such as on the cart page, where users can modify options before placing an order. Use `false` when gift options should be non-editable, such as on the Order Details page, where users view gift options for an already placed order.

The `items` prop accepts:

* A cart item object (for seamless integration with the cart and checkout pages).
* A custom-shaped object with the required fields:

  ```js
  export type ProductGiftOptionsConfig = {
    giftWrappingAvailable: boolean;
    giftMessageAvailable: boolean;
    giftWrappingPrice?: Price;
    giftMessage?: {
        recipientName?: string;
        senderName?: string;
        message?: string;
    };
  productGiftWrapping: GiftWrappingConfigProps[];
  };
  ```

## Example configurations

The following examples demonstrate how to configure the `GiftOptions` container in different scenarios.

### Product view: editable

The following example demonstrates how to render the `GiftOptions` container in an editable mode at the product level:

```js
provider.render(CartSummaryList, {
 hideHeading: hideHeading === 'true',
 routeProduct: (product) => rootLink(`/products/${product.url.urlKey}/${product.topLevelSku}`),
 routeEmptyCartCTA: startShoppingURL ? () => rootLink(startShoppingURL) : undefined,
 maxItems: parseInt(maxItems, 10) || undefined,
 attributesToHide: hideAttributes
   .split(',')
   .map((attr) => attr.trim().toLowerCase()),
 enableUpdateItemQuantity: enableUpdateItemQuantity === 'true',
 enableRemoveItem: enableRemoveItem === 'true',
 slots: {
   Footer: (ctx) => {
     const giftOptions = document.createElement('div');

     provider.render(GiftOptions, {
       item: ctx.item,
       view: 'product',
       dataSource: 'cart',
       handleItemsLoading: ctx.handleItemsLoading,
       handleItemsError: ctx.handleItemsError,
       onItemUpdate: ctx.onItemUpdate,
     })(giftOptions);

     ctx.appendChild(giftOptions);
   },
 },
})($list);
```

### Product View: non-editable

The following example demonstrates how to render the `GiftOptions` container in a non-editable mode at the product level:

```js
CartProvider.render(CartSummaryList, {
 variant: 'secondary',
 slots: {
   Heading: (headingCtx) => {
     const title = 'Your Cart ({count})';

     const cartSummaryListHeading = document.createElement('div');
     cartSummaryListHeading.classList.add('cart-summary-list__heading');

     const cartSummaryListHeadingText = document.createElement('div');
     cartSummaryListHeadingText.classList.add(
       'cart-summary-list__heading-text',
     );

     cartSummaryListHeadingText.innerText = title.replace(
       '({count})',
       headingCtx.count ? `(${headingCtx.count})` : '',
     );
     const editCartLink = document.createElement('a');
     editCartLink.classList.add('cart-summary-list__edit');
     editCartLink.href = rootLink('/cart');
     editCartLink.rel = 'noreferrer';
     editCartLink.innerText = 'Edit';

     cartSummaryListHeading.appendChild(cartSummaryListHeadingText);
     cartSummaryListHeading.appendChild(editCartLink);
     headingCtx.appendChild(cartSummaryListHeading);

     headingCtx.onChange((nextHeadingCtx) => {
       cartSummaryListHeadingText.innerText = title.replace(
         '({count})',
         nextHeadingCtx.count ? `(${nextHeadingCtx.count})` : '',
       );
     });
   },
   Footer: (ctx) => {
     const giftOptions = document.createElement('div');

     CartProvider.render(GiftOptions, {
       item: ctx.item,
       view: 'product',
       dataSource: 'cart',
       isEditable: false,
       handleItemsLoading: ctx.handleItemsLoading,
       handleItemsError: ctx.handleItemsError,
       onItemUpdate: ctx.onItemUpdate,
     })(giftOptions);

     ctx.appendChild(giftOptions);
   },
 },
})($cartSummary);
```

### Order view: editable

The following example demonstrates how to render the `GiftOptions` container in an editable mode at the order level:

```js
provider.render(GiftOptions, {
 view: 'order',
 dataSource: 'cart',
})($giftOptions);
```

### Order view: non-editable

The following example demonstrates how to render the `GiftOptions` container in a non-editable mode at the order level:

```js
CartProvider.render(GiftOptions, {
 view: 'order',
 dataSource: 'cart',
 isEditable: false,
})($giftOptions);
```

## Custom integrations

You can build additional custom integrations for gift option functionality using the GiftOptions container.
As an example, we can integrate the GiftOptions container on the Product Detail Page (PDP), allowing customers to select gift options for products before adding them to the cart. The code examples provided below demonstrate the general approach to building custom integrations with the GiftOptions container.

---

# Cart containers

Cart containers display shopping cart information, pricing, and management features. The following containers provide the building blocks for complete cart experiences.



| Container | Description |
|-----------|-------------|
| [CartSummaryGrid](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/cart-summary-grid/) | Cart items in responsive grid layout with images and details. |
| [CartSummaryList](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/cart-summary-list/) | Cart items in vertical list with detailed product information. |
| [CartSummaryTable](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/cart-summary-table/) | Cart items in table with columns for details, quantity, and pricing. |
| [Coupons](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/coupons/) | Apply promotional codes and discount coupons. |
| [EmptyCart](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/empty-cart/) | Messaging and call-to-action when cart is empty. |
| [EstimateShipping](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/estimate-shipping/) | Estimate shipping costs by destination. |
| [GiftCards](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/gift-cards/) | Apply gift cards as payment method. |
| [GiftOptions](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/gift-options/) | Add gift messages, wrapping, and gift options. |
| [MiniCart](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/minicart/) | Compact cart preview with product count and cart access. |
| [OrderSummary](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/order-summary/) | Order totals including subtotal, taxes, shipping, and discounts. |
| [OrderSummaryLine](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/order-summary-line/) | Individual line items for order summary like shipping and tax. |

---

# MiniCart container

The `MiniCart` container displays a summary of the shopper's shopping cart. It shows a list of products currently in the cart and subtotal amounts. It also provides call-to-action buttons for proceeding to checkout or updating the cart.


  ![MiniCart container](@images/dropins/cart/mini-cart.png/)


## Configurations

The `MiniCart` container provides the following configuration options:



The `CartModel` object has the following shape:


## Supported slots

The `MiniCart` container supports the following slots:

* ProductList
* ProductListFooter
* PreCheckoutSection
* Thumbnail
* Heading
* EmptyCart
* Footer
* ProductAttributes
* CartSummaryFooter
* CartItem
* UndoBanner
* ItemTitle
* ItemPrice
* ItemQuantity
* ItemTotal
* ItemSku
* ItemRemoveAction

## Example configuration

The following example demonstrates how to render the `MiniCart` container:

```javascript
provider.render(MiniCart, {
  routeProduct: (item) => {
      return `${item.url.categories.join('/')}/${item.url.urlKey}`;
  },
  routeEmptyCartCTA: () => '#empty-cart',
  routeCart: () => '#cart',
  routeCheckout: () => '#checkout',
  showDiscount: true,
  // showSavings: true,
  // enableItemRemoval: true,
  // enableQuantityUpdate: true,
  // hideHeading: true,
})($miniCart);
```

---

# OrderSummary container

The `OrderSummary` container displays a detailed summary of the shopper's order. It includes the subtotal, taxes, shipping costs, and total amount due. It optionally applies discounts or coupons.


  ![OrderSummary container](@images/dropins/cart/order-summary.png/)


This container supports the Coupon and EstimatedShipping slots.

## Configurations

The `OrderSummary` container provides the following configuration options:



The `CartModel` object has the following shape:



## Supported slots

The `OrderSummary` container supports the Coupons and EstimateShipping slots.

## Example configuration

The following example demonstrates how to render the `OrderSummary` container with the `EstimateShipping` and `Coupons` slots:

```js
provider.render(OrderSummary, {
  routeCheckout: () => '#checkout',
  errors: ctx.hasErrors,
  slots: {
    EstimateShipping: (ctx) => {
      const estimateShippingForm = document.createElement('div');
      provider.render(EstimateShipping, {
        showDefaultEstimatedShippingCost: true
      })(estimateShippingForm);
      ctx.appendChild(estimateShippingForm);
    },
    Coupons: (ctx) => {
      const coupons = document.createElement('div');
      provider.render(Coupons)(coupons);
      ctx.appendChild(coupons);
    },
  },
  showTotalSaved: true
})(orderSummary);
```

---

# OrderSummaryLine container

The `OrderSummaryLine` container  displays a line item in the order summary. The `OrderSummaryLine` container behaves like a wrapper for the `OrderSummaryLine` component. The component ultimately decides how to render the line item, based on the `children` attribute.


  ![OrderSummaryLine container](@images/dropins/cart/order-summary-line.png/)



## Configurations

The `OrderSummaryLine` container provides the following configuration options:



## Example configuration

The following example adds the Fixed Product Tax (PDT) line to the order summary:

```js
updateLineItems: (lineItems) => {
    const totalFpt = ctx.data.items.reduce((allItemsFpt, item) => {
    const itemFpt = item.fixedProductTaxes.reduce((accumulator, fpt) => {
      accumulator.labels.push(fpt.label);
      accumulator.total += fpt.amount.value;
      return accumulator;
    }, {
      labels: [],
      total: 0
    });
    allItemsFpt.labels = [...allItemsFpt.labels, ...itemFpt.labels];
    allItemsFpt.total += itemFpt.total;
    return allItemsFpt;
  }, {
    labels: [],
    total: 0
  });

  lineItems.push({
    key: 'fpt',
    sortOrder: 350,
    title: 'Fixed Product Tax',
    content: OrderSummaryLine({label: "FPT(" + totalFpt.labels.join(',') + ')', price: Price({amount: totalFpt.total}), classSuffix: 'fpt'})
  })

  return lineItems;
};
```

---

# Cart dictionary

The default cart dictionary file (`i18n/en_US.json`) contains the default values for all labels and text common to the cart drop-in component.

## Default keys and values

---

# Cart Data & Events

{/*
  âš ï¸ TEMPLATE USAGE GUIDE âš ï¸
  
  This template is used by scripts/generate-events-docs.js to generate event documentation.
  
  WHAT THE SCRIPT USES FROM THIS TEMPLATE:
  - Section headings and descriptive text (used as-is)
  - Import statements
  - The REPEAT_FOR_EACH_EVENT block (replicated for each event)
  - Placeholders: Cart, Cart, EVENT_NAME, etc.
  
  WHAT THE SCRIPT GENERATES INDEPENDENTLY:
  - Table contents between START/END markers (example rows are for reference only)
  - Event-specific data (names, descriptions, payloads from source repos)
  
  TO CHANGE:
  - Section text/descriptions â†’ Edit this template
  - Table structure (columns, links, formatting) â†’ Edit scripts/generate-events-docs.js
  - Both template and script must be kept in sync for table structure changes
*/}


The **Cart** drop-in uses the [event bus](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/) to emit and listen to events for communication between drop-ins and external integrations. For common events shared across multiple drop-ins (such as `locale`, `error`, `authenticated`, etc.), see the [Common events reference](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/#common-events-reference).


<strong>Version: 1.5.1</strong>


> **Note:** **New to drop-in events?** Learn about the [event system architecture](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/), including the publish-subscribe pattern, subscription configuration, and best practices for event handling.

## Events reference

{/* EVENTS_TABLE_START */}


| Event | Direction | Description |
|-------|-----------|-------------|
| [cart/initialized](#cartinitialized-emits) | Emits | Emitted when the component completes initialization |
| [cart/product/added](#cartproductadded-emits) | Emits | Emitted when an item is added |
| [cart/product/removed](#cartproductremoved-emits) | Emits | Emitted when an item is removed |
| [cart/product/updated](#cartproductupdated-emits) | Emits | Emitted when the component state is updated |
| [checkout/initialized](#checkoutinitialized-listens) | Listens | Fired by Checkout (`checkout`) when the component completes initialization |
| [checkout/updated](#checkoutupdated-listens) | Listens | Fired by Checkout (`checkout`) when the component state is updated |
| [companyContext/changed](#companycontextchanged-listens) | Listens | Fired by Company Context (`companyContext`) when a change occurs |
| [cart/data](#cartdata-emits-and-listens) | Emits and listens | Triggered when data is available or changes |
| [cart/merged](#cartmerged-emits-and-listens) | Emits and listens | Triggered when data is merged |
| [cart/reset](#cartreset-emits-and-listens) | Emits and listens | Triggered when the component state is reset |
| [cart/updated](#cartupdated-emits-and-listens) | Emits and listens | Triggered when the component state is updated |
| [shipping/estimate](#shippingestimate-emits-and-listens) | Emits and listens | Triggered when an estimate is calculated |


{/* EVENTS_TABLE_END */}

## Event details

The following sections provide detailed information about each event, including its direction, data payload structure, and usage examples.


### `cart/data` (emits and listens)

Triggered when data is available or changes

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const cartDataListener = events.on('cart/data', (data) => {
  console.log('cart/data event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
cartDataListener.off();
```

### `cart/initialized` (emits)

Emitted when the component completes initialization

#### Data payload

```typescript
CartModel | null
```



#### Usage

Listen to this event in your storefront:

```javascript

const cartInitializedListener = events.on('cart/initialized', (data) => {
  console.log('cart/initialized event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
cartInitializedListener.off();
```

### `cart/merged` (emits and listens)

Triggered when data is merged

#### Data payload

```typescript
{
oldCartItems: Item[] | null;
newCart: CartModel | null;
}
```

| Property | Type | Description |
|----------|------|-------------|
| `oldCartItems` | `Item[] \| null` | See type definition in source code |
| `newCart` | `CartModel \| null` | See type definition in source code |


#### Usage

Listen to this event in your storefront:

```javascript

const cartMergedListener = events.on('cart/merged', (data) => {
  console.log('cart/merged event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
cartMergedListener.off();
```

### `cart/product/added` (emits)

Emitted when an item is added

#### Data payload

```typescript
Item[] | null
```



#### Usage

Listen to this event in your storefront:

```javascript

const cartProductAddedListener = events.on('cart/product/added', (data) => {
  console.log('cart/product/added event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
cartProductAddedListener.off();
```

### `cart/product/removed` (emits)

Emitted when an item is removed

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const cartProductRemovedListener = events.on('cart/product/removed', (data) => {
  console.log('cart/product/removed event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
cartProductRemovedListener.off();
```

### `cart/product/updated` (emits)

Emitted when the component state is updated

#### Data payload

```typescript
Item[] | null
```



#### Usage

Listen to this event in your storefront:

```javascript

const cartProductUpdatedListener = events.on('cart/product/updated', (data) => {
  console.log('cart/product/updated event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
cartProductUpdatedListener.off();
```

### `cart/reset` (emits and listens)

Triggered when the component state is reset

#### Data payload

```typescript
void
```



#### Usage

Listen to this event in your storefront:

```javascript

const cartResetListener = events.on('cart/reset', (data) => {
  console.log('cart/reset event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
cartResetListener.off();
```

### `cart/updated` (emits and listens)

Triggered when the component state is updated

#### Data payload

```typescript
CartModel | null
```



#### Usage

Listen to this event in your storefront:

```javascript

const cartUpdatedListener = events.on('cart/updated', (data) => {
  console.log('cart/updated event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
cartUpdatedListener.off();
```

### `checkout/initialized` (listens)

Fired by Checkout (`checkout`) when the component completes initialization

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const checkoutInitializedListener = events.on('checkout/initialized', (data) => {
  console.log('checkout/initialized event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
checkoutInitializedListener.off();
```

### `checkout/updated` (listens)

Fired by Checkout (`checkout`) when the component state is updated

#### Data payload

```typescript
any
```



#### Usage

Listen to this event in your storefront:

```javascript

const checkoutUpdatedListener = events.on('checkout/updated', (data) => {
  console.log('checkout/updated event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
checkoutUpdatedListener.off();
```

### `companyContext/changed` (listens)

Fired by Company Context (`companyContext`) when a change occurs

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const companyContextChangedListener = events.on('companyContext/changed', (data) => {
  console.log('companyContext/changed event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
companyContextChangedListener.off();
```

### `shipping/estimate` (emits and listens)

Triggered when an estimate is calculated

#### Data payload

```typescript
{
address: PartialAddress;
shippingMethod: ShippingMethod | null;
}
```

| Property | Type | Description |
|----------|------|-------------|
| `address` | `PartialAddress` | See type definition in source code |
| `shippingMethod` | `ShippingMethod \| null` | See type definition in source code |


#### Usage

Listen to this event in your storefront:

```javascript

const shippingEstimateListener = events.on('shipping/estimate', (data) => {
  console.log('shipping/estimate event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
shippingEstimateListener.off();
```

---

# Cart functions

The cart drop-in component provides API functions that allow developers to retrieve and display detailed cart information dynamically.

## addProductsToCart

The `addProductsToCart` function adds products to a cart. You must supply a `sku` and `quantity`for each product. The other parameters are specified for complex product types. The function calls the [`addProductsToCart`](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/add-products/) mutation.

```ts
export const addProductsToCart = async (
  items: {
    sku: string;
    parentSku?: string;
    quantity: number;
    optionsUIDs?: string[];
    enteredOptions?: { uid: string; value: string }[];
  }[]
): Promise<CartModel | null>
```



### Returns

Returns a promise that resolves to a `CartModel` object or null. The `CartModel` object has the following shape:



### Events

The event bus emits the `cart/updated` and `cart/data` events with the `CartModel` as the data payload. Additionally, it emits `cart/product/added` for new items and `cart/product/updated` for items with increased quantities. It also publishes add-to-cart or remove-from-cart events to the Adobe Client Data Layer (ACDL).

### Usage

To add a simple product to the cart:

```js
addProductsToCart([
  {
    sku: 'VA19-GO-NA',
    quantity: 1,
  },
]);
```

To add a configurable product to the cart:

```js
addProductsToCart([
  {
    sku: 'VSW01',
    quantity: 1,
    optionsUIDs: ['Y29uZmlndXJhYmxlLzE1Ny8zMQ==', 'Y29uZmlndXJhYmxlLzE5MC80NA=='],
  },
]);
```

## applyCouponsToCart

The `applyCouponsToCart` function applies one or more predefined coupon codes to the specified cart. Any previously applied coupons are replaced. The function calls the [`applyCouponsToCart`](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/apply-coupons/) mutation.

```ts
export const applyCouponsToCart = async (
  couponCodes: string[],
    type: ApplyCouponsStrategy
): Promise<CartModel | null>
```



### Returns

Returns a promise that resolves to a `CartModel` object or null. The `CartModel` object has the following shape:



### Events

The event bus emits the `cart/updated` and `cart/data` events with the `CartModel` as the data payload.

### Usage

To apply a single coupon, replacing any existing coupons in the cart:

```js

applyCouponsToCart(['COUPON1'], 'REPLACE');
```

To apply multiple coupons to the cart:

```js

applyCouponsToCart(['COUPON1', 'COUPON2', 'COUPON3'], 'APPEND');
```

## applyCouponsToCart

A function that applies or replaces one or more coupons to the cart.

```ts

applyCouponsToCart(Array<string>);
```

Apply or replace a single coupon to the cart:

```js
applyCouponsToCart(['COUPON1']);
```

Apply or replace multiple coupons to the cart:

```js
applyCouponsToCart(['COUPON1', 'COUPON2', 'COUPON3']);
```

Here's the shape of the data returned from the `applyCouponsToCart` function:

```ts
type CartModel = {
  id: string;
  totalQuantity: number;
  errors?: ItemError[];
  items: Item[];
  miniCartMaxItems: Item[];
  total: {
    includingTax: Price;
    excludingTax: Price;
  };
  discount?: Price;
  subtotal: {
    excludingTax: Price;
    includingTax: Price;
    includingDiscountOnly: Price;
  };
  appliedTaxes: TotalPriceModifier[];
  totalTax?: Price;
  appliedDiscounts: TotalPriceModifier[];
  shipping?: Price;
  isVirtual?: boolean;
  addresses: {
    shipping?: {
      countryCode: string;
      zipCode?: string;
      regionCode?: string;
    }[];
  };
  isGuestCart?: boolean;
  hasOutOfStockItems?: boolean;
  hasFullyOutOfStockItems?: boolean;
  appliedCoupons?: Coupon[];
};
```
## applyGiftCardToCart

The applyGiftCardToCart function is used to apply a gift card to the current shopping cart. It takes the gift card code as an argument and updates the cart with the applied gift card.

```ts
export const applyGiftCardToCart = async (
  giftCardCode: string
): Promise<CartModel | null>
```



### Returns

Returns a promise that resolves to a `CartModel` object or null. The `CartModel` object has the following shape:



### Events

This function emits the `cart/updated` and `cart/data` events. It also publishes add-to-cart or remove-from-cart events to the Adobe Client Data Layer (ACDL).

### Usage

```ts

applyGiftCardToCart(giftCardCode: string);
```

## createEmptyCart

The `createEmptyCart` function creates an empty shopping cart for a guest or logged in customer. It returns a cart ID. The function calls the [`createEmptyCart`](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/create-empty-cart/) mutation.

```ts
export const createEmptyCart = async();
```

### Returns

The data returned is a new empty cart ID as a string:

```ts
type EmptyCartId = string;
```

If guest carts have been disabled from the Admin, the function returns an error.

### Usage

To create an empty cart:

```js

createEmptyCart();
```

## getCartData

The `getCartData` function is mainly used internally by the `initializeCart()` and `refreshCart()` functions. If you need detailed information about the current user's shopping cart, a more optimal approach is to listen for `cart/data` or `cart/updated` events so that you do not need to make another network call.

```ts
export const getCartData = async (): Promise<CartModel | null>
```

### Returns

Returns a promise that resolves to a `CartModel` object or null. The `CartModel` object has the following shape:



### Usage

To get detailed information about the user's shopping cart:

```js

getCartData();
```

## getEstimatedTotals

A function that returns estimated totals for cart based on an address. It takes an `address` parameter.

```ts
export const getEstimatedTotals = async (
  address: EstimateAddressShippingInput
): Promise<CartModel | null>
```



The `EstimateAddressShippingInput` object has the following parameters:



### Returns

Returns a promise that resolves to a `CartModel` object or null. The `CartModel` object has the following shape:



### Usage

To get estimated totals for the cart based on an address:

```js

getEstimatedTotals([
  {
    address: {
      countryCode: string,
      postcode?: string,
      region?: {
        region?: string,
        code?: string,
        id?: number,
      }
    }
  }
]);
```

Here's the shape of the data returned from the `getEstimatedTotals` function:

```ts
type EstimatedTotals = {
  cartId: string;
  address: {
    countryCode: string;
    postcode?: string;
    region?: {
      region?: string;
      code?: string;
      id?: number;
    };
  };
  shippingMethod: {
    carrierCode: string;
    methodCode: string;
  };
};
```

## getEstimateShipping

The `getEstimateShipping` function returns a list of shipping methods and the estimated shipping costs, based on the country ID. The function calls the [`estimateShippingMethods`](https://developer.adobe.com/commerce/webapi/graphql-api/index.html#mutation-estimateShippingMethods) mutation. 

```ts
export const getEstimateShipping = async (
  address: EstimateAddressInput
): Promise<any | null>
```



The `EstimateAddressInput` object has the following parameters:



### Returns

Returns a promise that contains shipping data or null. The `EstimatedShipping` object has the following shape:

```ts
type EstimatedShipping = {
  cartId: string;
  address: {
    countryCode: string;
    postcode?: string;
    region?: {
      region?: string;
      code?: string;
      id?: number;
    };
  };
  shippingMethod: {
    carrierCode: string;
    methodCode: string;
  };
};
```

### Events

The event bus emits the `shipping/estimate` event, which contains data about the address and shipping method.

### Usage

To get an estimate of the shipping costs:

```js

getEstimateShipping({
  countryCode: 'US',
  region: {
    code: 'NY',
  },
});
```

## getStoreConfig

The `getStoreConfig` function returns information about a store's configuration. The function calls the [`storeConfig`](https://developer.adobe.com/commerce/webapi/graphql/schema/store/queries/store-config/) query.

```ts
export const getStoreConfig = async (): Promise<StoreConfigModel | null>
```

### Returns

Returns a promise that resolves to a `StoreConfigModel` object or null. The `StoreConfigModel` object has the following shape:

```ts
type StoreConfigModel = {
  displayMiniCart: boolean;
  miniCartMaxItemsDisplay: number;
  cartExpiresInDays: number;
  cartSummaryDisplayTotal: number;
  defaultCountry: string;
  categoryFixedProductTaxDisplaySetting: string;
  productFixedProductTaxDisplaySetting: string;
  salesFixedProductTaxDisplaySetting: string;
  shoppingCartDisplaySetting: {
    fullSummary: boolean;
    grandTotal: boolean;
    price: number | string;
    shipping: number | string;
    subtotal: number | string;
    taxGiftWrapping: string;
    zeroTax: boolean;
  };
};
```

### Usage

To get cart-related configuration values:

```js

getStoreConfig();
```

## initializeCart

The `initializeCart` function initializes a guest or customer cart. This function is automatically called during the initialize phase of a dropin's lifecycle. You do not need to call this manually. It also emits the cart/initialized and cart/data events.

```ts
export const initializeCart = async (): Promise<CartModel | null>
```

### Returns

Returns a promise that resolves to a `CartModel` object or null. The `CartModel` object has the following shape:



### Events

The event bus emits the `cart/initialized` event and the `cart/data` event, which contains data about the address and shipping method.

### Usage

To initialize a cart:

```js

initializeCart();
```

## refreshCart

The `refreshCart` function refreshes the cart data.

```ts
export const refreshCart = async (): Promise<CartModel | null>
```

### Returns

Returns a promise that resolves to a `CartModel` object or null. The `CartModel` object has the following shape:



### Events

The event bus emits the `cart/updated` and `cart/data` events.

### Usage

To refresh the cart data:

```ts

refreshCart();
```
## removeGiftCardFromCart

This function removes a single gift card from the cart. It function calls the [`removeGiftCardFromCart`](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/remove-giftcard/) mutation.

```ts
export const removeGiftCardFromCart = async (
  giftCardCode: string
): Promise<CartModel | null>
```



### Returns

Returns a promise that resolves to a `CartModel` object or null. The `CartModel` object has the following shape:



### Events

The event bus emits the `cart/updated` and `cart/data` events.

### Usage

To remove a gift card from the cart:

```ts

removeGiftCardFromCart(giftCardCode: string);
```

## resetCart

This function resets the cart drop-in. As a result, the cart ID is set to null and the authenticated status is set to false.

```ts
export const resetCart = (): Promise<CartModel | null>
```

### Returns

Returns a promise that resolves to a `CartModel` object or null. The `CartModel` object has the following shape:



### Usage

To reset the cart:

```js

resetCart();
```

## setGiftOptionsOnCart


[`setGiftOptionsOnCart`](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/set-gift-options/) is a function that sets gift options on the cart. It takes a `giftOptions` parameter.

```ts
export const setGiftOptionsOnCart = async (
  giftForm: GiftFormDataType
): Promise<CartModel | null>
```



The `GiftFormDataType` object has the following parameters:
 


The `GiftWrappingConfigProps` object has the following parameters:



### Returns

Returns a promise that resolves to a `CartModel` object or null. The `CartModel` object has the following shape:



### Events

The event bus emits the `cart/updated` and `cart/data` events.

### Usage

```ts

setGiftOptionsOnCart(
  giftMessage: {
    from: string;
    to: string;
    message: string;
  };
  giftWrappingId: string;
  giftReceiptIncluded: boolean;
  printedCardIncluded: boolean;
);
```

## updateProductsFromCart

The `updateProductsFromCart` function updates cart items by either changing the quantity or removing and adding an item in one step. When passing a specified quantity, the function replaces the current quantity. Setting the quantity to 0 removes an item from the cart. The function calls the [`updateCartItems`](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/update-items/) mutation.

When an `optionsUIDs` array is sent along with the cart itemâ€™s UID and quantity, the function adds the item with the specified options. It removes any pre-existing item with the same UID that lacks the newly provided `optionsUIDs`. In this process, the function invokes first the [addProductsToCart](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/add-products/), and later the [updateCartItems](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/update-items/) mutations.

```ts
export const updateProductsFromCart = async (
  items: UpdateProductsFromCart
): Promise<CartModel | null>
```



The `UpdateProductsFromCart` object has the following parameters:



### Returns

Returns a promise that resolves to a `CartModel` object or null. The `CartModel` object has the following shape:



### Events

This function emits the `cart/updated` and `cart/data` events. Additionally, it emits `cart/product/updated` event with the affected items when their quantities are changed. It also publishes add-to-cart or remove-from-cart events to the Adobe Client Data Layer (ACDL).

### Usage

To set the quantity of an item in the cart to 3.

```js

updateProductsFromCart([
  {
    uid: 'VA19-GO-NA',
    quantity: 3,
  },
]);
```

To remove the item from the cart.

```js

updateProductsFromCart([
  {
    uid: 'VA19-GO-NA',
    quantity: 0,
  },
]);
```

To update the item from the cart by replacing the cart item. By passing `optionsUIDs`, this function adds the product associated with the new `optionsUIDs` and removes the previous item with the same UID.

```js

updateProductsFromCart([
  {
    sku: 'VT02-PE-M',
    uid: 'NTE1NDY=',
    quantity: 2,
    optionsUIDs: [
                'Y29uZmlndXJhYmxlLzE4MC8zMg==',
                'Y29uZmlndXJhYmxlLzE5MS80Mw==',
              ]
  },
]);
```

---

# Cart overview

The cart drop-in component provides a variety of fully-editabled controls to help you view, update, and merge the products in your cart and mini-cart, including image thumbnails, pricing, descriptions, quantities, estimated shipping and taxes, order summary, merging guest and authenticated cart, and more.

## Supported Commerce features

The following table provides an overview of the Adobe Commerce features that the cart supports:

| Feature                                                          | Status                                     |
| ---------------------------------------------------------------- | ------------------------------------------ |
| Adobe Experience Platform Audiences                              |  |
| All product types                                                |    |
| Apply coupons                                                    |    |
| Apply gift cards                                                 |    |
| Apply gift options                                               |    |
| Cart API extensibility                                           |    |
| Cart layout templates                                            |    |
| Cart rules                                                       |    |
| Cart with 100+ products                                          |    |
| Commerce segments                                                |    |
| Customer cart                                                    |    |
| Edit product configuration in cart                               |    |
| Estimate tax/shipping                                            |    |
| Guest cart                                                       |    |
| Low product stock alert                                          |    |
| Mini-cart                                                        |    |
| No-code UI configurations                                        |    |
| Out of stock/insufficient quantity products                      |    |
| Product line discounts (catalog rule, special price, tier price) |    |
| Save to wishlist                                                 |    |
| Slots for extensibility                                          |    |
| Taxes: Fixed                                                     |  |
| Taxes: Sales, VAT                                                |    |
| Undo remove product from cart                                    |  |

## Section topics

The topics in this section will help you understand how to customize and use the cart effectively within your storefront.

### Installation

Provides the step-by-step process for embedding the cart into your site. This topic covers everything from basic setup requirements to more advanced configurations, ensuring that the drop-in component integrates seamlessly with your existing website architecture. It is designed for compatibility with modern web technologies, focusing on ease of use and flexibility for developers. Visit the [cart installation](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/installation/) page to get started.

### Styles

Describes how to customize the appearance of the cart using CSS. We provide guidelines and examples for applying styles to various components within the drop-in. This customization allows brands to align the drop-in component's look and feel with their overall design aesthetic, enhancing brand consistency across the platform. Visit the [cart styles](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/styles/) page to learn more.

### Containers

Describes the structural elements of the cart, specifically focusing on how the container manages and displays content. It includes information on configuration options and how to leverage these settings to customize the user experience. Understanding the container is essential for developers looking to optimize the layout and styling of the cart. Visit the cart containers page to learn more.

### Slots

Slots allow developers to customize the appearance of the cart by adding or modifying content within specific sections of the drop-in component. Visit the [cart slots](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/slots/) page to learn more.

### Functions

Describes the API functions available in the Cart dropin. These functions allow developers to retrieve and display detailed cart information dynamically. Visit the [Cart Functions](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/functions/) page to learn more.

---

# Cart initialization

The cart drop-in component initializer provides options for configuring language definitions and extending the default models with new fields and transformers.

## Configuration options

The cart component initializer accepts the following configuration options:



### Example

The following code shows an example implementation of the cart initializer configuration:

```ts
// Initialize cart 
initializeDropin(async () => {
  await initializers.mountImmediately(initialize, {
    langDefinitions,
    models,
  });
})();
```

### Set language definitions

The `langDefinitions` property registers the cart component dictionary files, which are used for internationalization purposes. These files allow you to provide localized text for different languages in your application.

```ts
// Fetch the dictionary files for your application
const en_US = await fetch('/i18n/en_US.json').then((res) => res.json());
const fr_FR = await fetch('/i18n/fr_FR.json').then((res) => res.json());

// Register the component with language definitions
const langDefinitions = {
  default: en_US,
  en_US,
  fr_FR,
};

// Register initializers
initializers.register(api.initialize, {
  langDefinitions,
});
```

### Set models

You can extend the default models in the cart component and provide transformers to process new fields.

The `models` property is an object that contains the default models that you might want to extend and the transformers to use to transform the data. By default, the cart component initializer only accepts the `CartModel`.

The following example shows how to extend the default models with new fields and transformers:

```ts
// Initialize cart
initializeDropin(async () => {
  await initializers.mountImmediately(initialize, {
    langDefinitions,
    models: {
      CartModel: {
        transformer: (data) => ({
          printedCardIncluded: data?.printed_card_included,
          giftReceiptIncluded: data?.gift_receipt_included,
        }),
      },
    },
  });
})();
```

---

# Cart installation

The cart drop-in component, like our other drop-in components, are designed for the browser's JavaScript runtime without the need for a bundler. You can also install and execute drop-in components in a build-time environment with bundlers like Vite. The installation steps for both runtime and build-time environments are the same after the initial drop-in component package imports.

## Step-by-step

Use the following steps to install the cart component:

:::note[Edge Delivery Service]
These steps are specific for EDS projects, and may not necessarily be the same for other frameworks such as a static HTML or React framework.
:::



<Task>

### Install the packages

Use a CDN or NPM (recommended for performance) to install the drop-in component tools (`@dropins/tools`) and cart (`@dropins/storefront-cart`) packages.

<Tabs>
  <TabItem label="NPM" icon="seti:npm">

    ```bash frame="none"
    npm install @dropins/tools @dropins/storefront-cart
    ```

  </TabItem>
  <TabItem label="CDN" icon="external">

    ```html title="index.html" del={"Replace with actual URLs":5-7}
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Your Storefront</title>

      <script src="https://cdn.jsdelivr.net/npm/@dropins/tools@latest"></script>
      <script src="https://cdn.jsdelivr.net/npm/@dropins/storefront-cart@latest"></script>
    </head>
    ```

  </TabItem>
</Tabs>

:::note[Install @dropins/tools]
All drop-in components require the `@dropins/tools` package. This package contains the libraries that drop-in components need to initialize and communicate, including `fetch-graphql`, `event-bus`, and `initializer` utilities.
:::

</Task>

<Task>
### Map the packages

In the `<head>` tag of your `index.html` or `head.html` file, use an `importmap` pointed to the `node_modules` directory, a **custom local directory**, or **CDN** (for run-time environments).

<Tabs>
<TabItem label="node_modules" icon="seti:npm">
    This example shows an `importmap` added to a `head.html` The `importmap` points both packages to the local `node_modules` directory that contains your installed drop-in component files from the drop-in component tools (@dropins/tools) and the cart (@dropins/storefront-cart):

  ```html title="head.html"
  <script type="importmap">
    {
      "imports": {
        "@dropins/tools/": "/node_modules/@dropins/tools/",
        "@dropins/storefront-cart/": "/node_modules/@dropins/storefront-cart/",
      }
    }
  </script>
  <script src="/scripts/scripts.js" type="module"></script>
    ```
  </TabItem>
    <TabItem label="custom" icon="seti:folder">
    This example shows an `importmap` added to a `head.html` The `importmap` points both packages to local directories that contain all the optimized/minified files from the drop-in component tools (@dropins/tools) and the cart (@dropins/storefront-cart):

    ```html title="head.html"
    <script type="importmap">
      {
        "imports": {
          "@dropins/tools/": "/scripts/__dropins__/tools/",
          "@dropins/storefront-cart/": "/scripts/__dropins__/storefront-cart/",
        }
      }
    </script>
    <script src="/scripts/scripts.js" type="module"></script>
    ```

  </TabItem>
  <TabItem label="CDN" icon="external">
    This example shows an `importmap` pointing both packages to a CDN for the drop-in component tools (@dropins/tools) and the cart (@dropins/storefront-cart):

    ```html title="index.html" {"Replace CDN URLs with correct URLs":5-7} del='https://cdn.jsdelivr.net/npm/'
    <head>
      <script type="importmap">
        {
          "imports": {

            "@dropins/tools/": "https://cdn.jsdelivr.net/npm/@dropins/tools@latest",
            "@dropins/storefront-cart/": "https://cdn.jsdelivr.net/npm/@dropins/storefront-cart@latest",
          }
        }
      </script>
    </head>
    ```

  </TabItem>

</Tabs>

With the `importmap` defined for both runtime and build-time environments, you can now **import the required files** from these packages into your cart block as described in the next step.

</Task>

<Task>
### Import the required files

Import the required files from the drop-in components tools (`@dropins/tools/fetch-graphql.js'`, `@dropin/tools/initializers.js`) and the cart (`@dropins/storefront-cart`) into a JavaScript file for your cart block. The example here shows the imports added to a `cart.js` file. These imports constitute the minimum imports you need to create a fully functioning cart for your site:

```js title="cart.js"
// GraphQL Client

// component tools

// drop-in component functions

// Drop-in component provider

// Drop-in component containers
```

<Vocabulary>

### GraphQL client

Enables the ability to set and get endpoints and headers, as well as fetches data and configurations.

### Drop-in component tools

The Initializer is responsible for setting up event listeners and initializing a module with the given configuration.

### drop-in component functions

Enables the cart API functions: addProductsToCart, createEmptyCart, getCartData... and more.

### Drop-in component provider

Renders the cart UI.

### Drop-in component containers

Structural elements that are responsible for managing and displaying the UI for the `Cart` and `Mini-cart`.

</Vocabulary>

</Task>

<Task>
### Connect to the endpoint

Connect your cart component to the API Mesh endpoint and set the required headers as shown in the example below. Replace the endpoint URL and header placeholder values with the actual values from your Commerce backend services:

```js title="cart.js"
// Set endpoint configuration
mesh.setEndpoint('https://<graphql-service-endpoint>/graphql');
```

#### Request headers

The cart does not need additional headers set for basic installation. But if you're looking to enable features for your drop-in component, the GraphQL request accepts additional headers. The below example shows how you could set the `Commerce-Auth` header with the customer token for the Authorization header, and how to set the store code header for store specific features. Replace the header values with the actual values from your Commerce backend services:

```js title="cart.js"
// Set the customer token. This method is specific to @dropins/storefront-cart package.
pkg.setFetchGraphQlHeader('commerce-auth', '<token>');

// Set store code header. This method is specific to the @dropins/tools package.
mesh.setFetchGraphQlHeader('store', '<default>');
```

:::note[Authentication]
Note that this setting is specific for GraphQL Mesh, so refer to the [Commerce GraphQL Service](https://developer.adobe.com/commerce/webapi/graphql/usage/headers/#request-headers) for direct connections. Visit the [user authentication](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/) drop-in component for instructions on setting up Authentication features.
:::

</Task>

<Task>
### Register and load the drop-in

The code below shows how to register the cart, load it (mount), and enable the logger for debugging purposes. You can add these functions within a `<script>` tag in your Cart HTML page as shown here:

```html title="index.html" ins={"1":5} ins={"2":8}
<script type="module">
  // more code above...

  // Register and load the Cart drop-in
  initializers.register(pkg.initialize);

  // Mount Initializers (must be called after all initializers are registered)
  window.addEventListener('load', initializers.mount);
</script>
```

<Callouts square color="var(--sl-color-green)">

1. This function registers the cart to be loaded on the page by the `initializers.mount` function.
1. This event handler triggers the initializers.mount function to load the cart after the page has loaded.

</Callouts>

</Task>

<Task>
### Render the drop-in

Render the cart on the page. The example below provides the minimal configuration options required to render the default Cart drop-in component, along with an example to render Mini-Cart.

```js title="cart.js"
// Render Cart
provider.render(Cart, {
  routeProduct: (item) => {
    return `${item.url.categories.join('/')}/${item.url.urlKey}`;
  },
  routeEmptyCartCTA: () => 'your-empty-cart-element',
  routeCheckout: () => 'your-checkout-element',
})(document.getElementById('your-cart-element'));

// Render MiniCart
provider.render(MiniCart, {
  routeProduct: (item) => {
    return `${item.url.categories.join('/')}/${item.url.urlKey}`;
  },
  routeEmptyCartCTA: () => 'your-empty-cart-element',
  routeCart: () => 'your-cart-element',
  routeCheckout: () => 'your-checkout-element',
})(document.getElementById('your-mini-cart-element'));
```

Test the cart by viewing your cart page in a browser, or running your local dev or build server. If you see the cart rendered in the browser, congrats!, you have a successful installation. If not, check the console for any errors and verify that you have followed all the steps correctly.

</Task>



## Summary

The installation of all drop-in components follow the same pattern demonstrated by installing the cart: Install, Map, Import, Connect, Register, and Render.

---

# Cart slots

Learn about the slots provided in the Cart drop-in component.

[Extending drop-in components](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/extending/) describes default properties available to all slots.

## CartSummaryList slots

The slots for the `CartSummaryList` container allow you to customize the appearance of the cart summary list.

```js
interface CartSummaryListProps

slots?: {
  Heading?: SlotProps;
  EmptyCart?: SlotProps;
  Footer?: SlotProps;
  Thumbnail?: SlotProps<{
    item: CartModel['items'][number];
    defaultImageProps: ImageProps;
  }>;
  ProductAttributes?: SlotProps;
  CartSummaryFooter?: SlotProps;
  CartItem?: SlotProps;
  UndoBanner?: SlotProps<{
    item: CartModel['items'][0];
    loading: boolean;
    error?: string;
    onUndo: () => void;
    onDismiss: () => void;
  }>;
  ItemTitle?: SlotProps<{ item: CartModel['items'][number] }>;
  ItemPrice?: SlotProps<{ item: CartModel['items'][number] }>;
  ItemQuantity?: SlotProps<{
    item: CartModel['items'][number];
    enableUpdateItemQuantity: boolean;
    handleItemQuantityUpdate: (
      item: CartModel['items'][number],
      quantity: number
    ) => void;
    itemsLoading: Set<string>;
    handleItemsError: (uid: string, message?: string) => void;
    handleItemsLoading: (uid: string, state: boolean) => void;
    onItemUpdate?: ({ item }: { item: CartModel['items'][number] }) => void;
  }>;
  ItemTotal?: SlotProps<{ item: CartModel['items'][number] }>;
  ItemSku?: SlotProps<{ item: CartModel['items'][number] }>;
  ItemRemoveAction?: SlotProps<{
    item: CartModel['items'][number];
    enableRemoveItem: boolean;
    handleItemQuantityUpdate: (
      item: CartModel['items'][number],
      quantity: number
    ) => void;
    handleItemsError: (uid: string, message?: string) => void;
    handleItemsLoading: (uid: string, state: boolean) => void;
    onItemUpdate?: ({ item }: { item: CartModel['items'][number] }) => void;
    itemsLoading: Set<string>;
  }>;
};
```

### Heading slot

The `Heading` slot allows you to add content to the top of the `CartSummaryList` container.

```js
 provider.render(CartSummaryList, {
  slots: {
    Heading: (ctx) => {
      // Runs on mount
      const heading = document.createElement('h2');
      heading.innerText = 'Cart List';
      ctx.appendChild(heading);
    },
  },
})($list),
```

### EmptyCart slot

The `EmptyCart` slot allows you to add content to the `CartSummaryList` container when the cart is empty.

```js
 provider.render(CartSummaryList, {
  slots: {
    EmptyCart: (ctx) => {
      // Runs on mount
      const emptyCart = document.createElement('div');
      emptyCart.innerText = 'Your cart is empty';
      ctx.appendChild(emptyCart);
    },
  },
})($list),
```


### Thumbnail slot

Define a callback function in the `Thumbnail` slot of the `CartSummaryList` container to modify or replace the thumbnail section for each item in the cart.

The context object passed to the callback function includes an `item` property that contains the item data with the following type:

```typescript
export interface Item {
  taxedPrice: {
    value: number;
    currency: string;
  };
  rowTotal: {
    value: number;
    currency: string;
  };
  rowTotalIncludingTax: {
    value: number;
    currency: string;
  };
  itemType: string;
  uid: string;
  url: {
    urlKey: string;
    categories: string[];
  };
  quantity: number;
  sku: string;
  name: string;
  image: {
    src: string;
    alt: string;
  };
  links?: {
    count: number;
    result: string;
  };
  price: {
    value: number;
    currency: string;
  };
  total: {
    value: number;
    currency: string;
  };
  discountedTotal?: {
    value: number;
    currency: string;
  };
  discount?: {
    value: number;
    currency: string;
  };
  regularPrice: {
    value: number;
    currency: string;
  };
  discounted: boolean;
  bundleOptions?: { [key: string]: any };
  selectedOptions?: { [key: string]: any };
  customizableOptions?: { [key: string]: any };
  message?: string;
  recipient?: string;
  recipientEmail?: string;
  sender?: string;
  senderEmail?: string;
  lowInventory?: boolean;
  insufficientQuantity?: boolean;
  onlyXLeftInStock?: number | null;
  outOfStock?: boolean;
  notAvailableMessage?: string;
  stockLevel?: string;
  productAttributes?: Array<{
  code: string;
  value?: string;
  selected_options?: {
    value: string;
    label: string;
  }[];
}>;
}
```

#### Example extension

The following example demonstrates how to extend the `Thumbnail` slot.

```javascript
  return provider.render(CartSummaryList, {
    hideHeading: hideHeading === 'true',
    routeProduct: (product) => `/products/${product.url.urlKey}/${product.sku}`,
    routeEmptyCartCTA: startShoppingURL ? () => startShoppingURL : undefined,
    maxItems: parseInt(maxItems, 10) || undefined,
    attributesToHide: hideAttributes.split(',').map((attr) => attr.trim().toLowerCase()),
    enableUpdateItemQuantity: enableUpdateItemQuantity === 'true',
    enableRemoveItem: enableRemoveItem === 'true',
    slots: {
      Thumbnail: (ctx) => {
        const { item } = ctx;

        // Create a link to save the item for later
        const saveForLaterLink  = document.createElement('a');
        saveForLaterLink.href = '#';
        saveForLaterLink.addEventListener('click', (e) => {
          e.preventDefault();
          console.log(`Saving ${item.name}(${item.sku}) for later`);
          // TODO: Implement save for later functionality
        });
        saveForLaterLink.innerText = 'Save for later';

        // Create a separator
        const separator = document.createElement('span');
        separator.innerText = ' | ';

        // Create a link to remove the item from the cart
        const removeLink = document.createElement('a');
        removeLink.href = '#';
        removeLink.addEventListener('click', (e) => {
          e.preventDefault();
          console.log(`Removing ${item.name}(${item.sku}) from cart`);
          // TODO: Implement remove item functionality
        });
        removeLink.innerText = 'Remove';

        // Create a container to hold the links
        const container = document.createElement('div');
        container.innerHTML = '';

        // Style the container
        container.style.font = 'var(--type-details-caption-2-font)'
        container.style.display = 'flex';
        container.style.justifyContent = 'space-between';

        // Append the links to the container
        container.appendChild(saveForLaterLink);
        container.appendChild(separator);
        container.appendChild(removeLink);

        // Append the container as a child to the existing thumbnail content
        ctx.appendChild(container)
      }
    }
  })(block);
```

### Footer slot

The `Footer` slot allows you to add content to the bottom of the `CartSummaryList` container.

The following example demonstrates how to extend the `Footer` slot by adding a promotional cart rule to each product in the cart.

```js
Footer: (ctx) => {
  // Runs on mount
  const wrapper = document.createElement('div');
  ctx.appendChild(wrapper);

  // Append Product Promotions on every update
  ctx.onChange((next) => {
    wrapper.innerHTML = '';

    next.item?.discount?.label?.forEach((label) => {
      const discount = document.createElement('div');
      discount.style.color = '#3d3d3d';
      discount.innerText = label;
      wrapper.appendChild(discount);
    });
  });
},
```

### ProductAttributes slot

The `ProductAttributes` slot allows you to add custom content to the `CartSummaryList` container.

The following example demonstrates how to add the Fashion Material and Fashion Style product attributes to each product in the cart.

```javascript
  return provider.render(CartSummaryList, {
    enableRemoveItem: true,
    enableUpdateItemQuantity: true,
    routeProduct: (item) => {
      return `${item.url.categories.join('/')}/${item.url.urlKey}`;
    },
    routeEmptyCartCTA: () => '#empty-cart',
    slots: {
      ProductAttributes: (ctx) => {
        // Prepend Product Attributes
        const ProductAttributes = ctx.item?.productAttributes;

        ProductAttributes?.forEach((attr) => {
          if(attr.code === "Fashion Material" || attr.code === "Fashion Style") {
            if(attr.selected_options) {
              const selectedOptions = attr.selected_options
              .filter((option) => option.label.trim() !== '')
              .map((option) => option.label)
              .join(', ');
              
              if(selectedOptions) {
                const productAttribute = document.createElement('div');
                productAttribute.innerText = `${attr.code}: ${selectedOptions}`;
                ctx.appendChild(productAttribute);
              }
            } else if (attr.value) {
              const productAttribute = document.createElement('div');
              productAttribute.innerText = `${attr.code}: ${attr.value}`;
              ctx.appendChild(productAttribute);
            }
          }
        })
      },
    },
  })(productList);
```

### CartSummaryFooter slot

The `CartSummaryFooter` slot allows you to add content to the bottom of the `CartSummaryList` container.

```js
 provider.render(CartSummaryList, {
  slots: {
    CartSummaryFooter: (ctx) => {
      const cartSummaryFooter = document.createElement('div');
      cartSummaryFooter.innerText = 'Cart summary footer';
      ctx.appendChild(cartSummaryFooter);
    },
  },
})($list),
```

### ItemTitle slot

The `ItemTitle` slot allows you to customize the title display for each item in the `CartSummaryList` container.

The following example demonstrates how to replace the default title with a custom title:

```javascript
provider.render(CartSummaryList, {
  enableRemoveItem: true,
  enableUpdateItemQuantity: true,
  slots: {
    ItemTitle: (ctx) => {
      // Create custom title element
      const customTitle = document.createElement('div');
      customTitle.className = 'cart-item-custom-title';
      customTitle.textContent = 'Custom Title';

      ctx.replaceWith(customTitle);
    },
  },
})(cartSummaryList);
```

### ItemPrice slot

The `ItemPrice` slot allows you to customize the price display for each item in the `CartSummaryList` container.

The following example demonstrates how to add a custom price label:

```javascript
provider.render(CartSummaryList, {
  enableRemoveItem: true,
  enableUpdateItemQuantity: true,
  slots: {
    ItemPrice: (ctx) => {
      const priceLabel = document.createElement('span');
      priceLabel.className = 'cart-item-price-label';
      priceLabel.textContent = 'Item Price';

      ctx.prependChild(priceLabel);
    },
  },
})(cartSummaryList);
```

### ItemQuantity slot

The `ItemQuantity` slot allows you to customize the quantity display and controls for each item in the `CartSummaryList` container.

The following example demonstrates how to customize the quantity field by adding a "Qty:" label and using an input component from the SDK:

```javascript

provider.render(CartSummaryList, {
  enableRemoveItem: true,
  enableUpdateItemQuantity: true,
  slots: {
    ItemQuantity: (ctx) => {
      const { item, handleItemQuantityUpdate } = ctx;

      // Create container with label and input
      const quantityContainer = document.createElement('div');
      quantityContainer.className = 'cart-item-quantity-container';

      // Add "Qty:" label
      const quantityLabel = document.createElement('span');
      quantityLabel.className = 'cart-item-quantity-label';
      quantityLabel.textContent = 'Qty:';

      // Create input wrapper for SDK Input component
      const inputWrapper = document.createElement('div');
      inputWrapper.className = 'cart-item-quantity-input';
      inputWrapper.style.display = 'inline-block';
      inputWrapper.style.width = '60px';

      // Render SDK Input component
      UI.render(Input, {
        value: item.quantity.toString(),
        min: 1,
        size: 'small',
        variant: 'primary',
        onValue: (value) => {
          const newQuantity = parseInt(value, 10);
          if (
            !Number.isNaN(newQuantity)
            && newQuantity > 0
            && newQuantity !== item.quantity
          ) {
            handleItemQuantityUpdate(item, newQuantity);
          }
        },
      })(inputWrapper);

      // Style the container for inline layout
      quantityContainer.style.display = 'flex';
      quantityContainer.style.alignItems = 'center';
      quantityContainer.style.gap = 'var(--spacing-xsmall)';

      quantityContainer.appendChild(quantityLabel);
      quantityContainer.appendChild(inputWrapper);

      ctx.replaceWith(quantityContainer);
    },
  },
})(cartSummaryList);
```

### ItemTotal slot

The `ItemTotal` slot allows you to customize the total price display for each item in the `CartSummaryList` container.

The following example demonstrates how to add a custom total label:

```javascript
provider.render(CartSummaryList, {
  enableRemoveItem: true,
  enableUpdateItemQuantity: true,
  slots: {
    ItemTotal: (ctx) => {
      const totalLabel = document.createElement('div');
      totalLabel.className = 'cart-item-total-label';
      totalLabel.textContent = 'Item Total';

      ctx.prependChild(totalLabel);
    },
  },
})(cartSummaryList);
```

### ItemSku slot

The `ItemSku` slot allows you to customize the SKU display for each item in the `CartSummaryList` container.

The following example demonstrates how to replace the default SKU with a custom SKU:

```javascript
provider.render(CartSummaryList, {
  enableRemoveItem: true,
  enableUpdateItemQuantity: true,
  slots: {
    ItemSku: (ctx) => {
      const customSku = document.createElement('div');
      customSku.className = 'cart-item-custom-sku';
      customSku.textContent = 'custome-sku';

      ctx.replaceWith(customSku);
    },
  },
})(cartSummaryList);
```

### ItemRemoveAction slot

The `ItemRemoveAction` slot allows you to customize the remove action button for each item in the `CartSummaryList` container.

The following example demonstrates how to replace the default remove button with a custom button:

```javascript
provider.render(CartSummaryList, {
  enableRemoveItem: true,
  enableUpdateItemQuantity: true,
  slots: {
    ItemRemoveAction: (ctx) => {
      // Simple remove button with text
      const removeButton = document.createElement('button');
      removeButton.innerText = 'Remove';
      // apply styling using design tokens where possible
      removeButton.style.background = 'transparent';
      removeButton.style.border = 'none';
      removeButton.style.color = 'var(--color-neutral-600)';
      removeButton.style.cursor = 'pointer';
      removeButton.style.fontSize = 'var(--type-body-2-font-size)';
      removeButton.style.padding = '0';
      removeButton.style.paddingRight = 'var(--spacing-medium)';
      removeButton.style.fontWeight = 'var(--type-body-2-font-weight, normal)';
      removeButton.style.textDecoration = 'underline';
      removeButton.style.float = 'right';
      removeButton.style.marginLeft = 'auto';
      removeButton.style.display = 'block';

      // Remove functionality
      removeButton.addEventListener('click', () => {
        if (ctx.handleItemQuantityUpdate) {
          ctx.handleItemQuantityUpdate(ctx.item, 0);
        }
      });

      ctx.replaceWith(removeButton);
    },
  },
})(cartSummaryList);
```

## OrderSummary slots

The `OrderSummaryProps` interface defines two slots for customizing the appearance of the order summary.

```js
interface OrderSummaryProps

slots?: {
  EstimateShipping?: SlotProps;
  Coupons?: SlotProps;
};
```

### EstimateShipping slot

The `EstimateShipping` slot allows you to add estimated shipping information to the `OrderSummary` container. 

The following example demonstrates how to add the Estimate Shipping layout to the OrderSummary container.

```javascript
  return provider.render(OrderSummary, {
    routeCheckout: () => '#checkout',

    errors: ctx.hasErrors,

    slots: {
      EstimateShipping: (ctx) => {
        const estimateShippingForm = document.createElement('div');

        provider.render(EstimateShipping)(estimateShippingForm);

        ctx.appendChild(estimateShippingForm);
      }
    },
  })(orderSummary);
```

### Coupons slot

The Coupons slot allows you to add the Coupons layout to the `OrderSummary` container. 

The following example demonstrates how to enable coupons to the `OrderSummary` container.

```javascript
  return provider.render(OrderSummary, {
    routeCheckout: () => '#checkout',

    errors: ctx.hasErrors,

    slots: {
      Coupons: (ctx) => {
          const coupons = document.createElement('div');

          provider.render(Coupons)(coupons);

          ctx.appendChild(coupons);
        }
    },
  })(orderSummary);
```

## MiniCart slot

The `MiniCartProps` interface defines slots for customizing the appearance of the mini cart.

```js
interface MiniCartProps

slots?: {
  ProductList?: SlotProps;
  ProductListFooter?: SlotProps;
  PreCheckoutSection?: SlotProps;
  Thumbnail?: SlotProps<{
    item: CartModel['items'][number];
    defaultImageProps: ImageProps;
  }>;
  Heading?: SlotProps;
  EmptyCart?: SlotProps;
  Footer?: SlotProps;
  ProductAttributes?: SlotProps;
  CartSummaryFooter?: SlotProps;
  CartItem?: SlotProps;
  UndoBanner?: SlotProps<{
    item: CartModel['items'][0];
    loading: boolean;
    error?: string;
    onUndo: () => void;
    onDismiss: () => void;
  }>;
  ItemTitle?: SlotProps<{ item: CartModel['items'][number] }>;
  ItemPrice?: SlotProps<{ item: CartModel['items'][number] }>;
  ItemQuantity?: SlotProps<{
    item: CartModel['items'][number];
    enableUpdateItemQuantity: boolean;
    handleItemQuantityUpdate: (
      item: CartModel['items'][number],
      quantity: number
    ) => void;
    itemsLoading: Set<string>;
    handleItemsError: (uid: string, message?: string) => void;
    handleItemsLoading: (uid: string, state: boolean) => void;
    onItemUpdate?: ({ item }: { item: CartModel['items'][number] }) => void;
  }>;
  ItemTotal?: SlotProps<{ item: CartModel['items'][number] }>;
  ItemSku?: SlotProps<{ item: CartModel['items'][number] }>;
  ItemRemoveAction?: SlotProps<{
    item: CartModel['items'][number];
    enableRemoveItem: boolean;
    handleItemQuantityUpdate: (
      item: CartModel['items'][number],
      quantity: number
    ) => void;
    handleItemsError: (uid: string, message?: string) => void;
    handleItemsLoading: (uid: string, state: boolean) => void;
    onItemUpdate?: ({ item }: { item: CartModel['items'][number] }) => void;
    itemsLoading: Set<string>;
  }>;
};
```

**Note:** Many slots are shared between MiniCart and CartSummaryList components. For implementation details of shared slots, refer to the corresponding examples in the [CartSummaryList slots section](#cartsummarylist-slots) above.

The following slots are specific to the MiniCart component:

### ProductListFooter slot

The ProductListFooter slot allows you to add content after the product list and before the subtotal section of the `MiniCart` container.

The following example demonstrates how to extend the `ProductListFooter` by adding the store return policy.

```javascript
  return provider.render(MiniCart, {
    routeEmptyCartCTA: () => '#empty-cart',
    routeCart: () => '#cart',
    routeCheckout: () => '#checkout',
    slots: {
      ProductListFooter: (ctx) => {
        const productListFooter = document.createElement('div');
        ctx.appendChild(productListFooter);
    
        ctx.onChange((next) => {
          // Clear the existing content
          productListFooter.innerHTML = '';
    
          if (Object.keys(next.data.items).length === 0) {
            return;
          }
    
          const shadowWrapper = document.createElement('div');
          shadowWrapper.style.backgroundColor = '#EFF5EF';
          shadowWrapper.style.borderRadius = '5px';
    
          // Create the content div
          const contentDiv = document.createElement('div');
          contentDiv.innerHTML = "Enjoy hassle-free shopping with our 30-day return policy!";
          contentDiv.style.display = 'flex';
          contentDiv.style.flexDirection = 'column';
          contentDiv.style.padding = '12px';
    
          // Append the content div to the shadow wrapper
          shadowWrapper.appendChild(contentDiv);
    
          productListFooter.appendChild(shadowWrapper);
        });
      },
    },
  })(orderSummary);
```

### PreCheckoutSection slot

The PreCheckoutSection slot allows you to add content after the the subtotal section and before the Call to Action buttons of the `MiniCart` container.

The following example demonstrates how to extend the `PreCheckoutSection` by adding the loyalty program callouts.

```javascript
  return provider.render(MiniCart, {
    routeEmptyCartCTA: () => '#empty-cart',
    routeCart: () => '#cart',
    routeCheckout: () => '#checkout',
    slots: {
      PreCheckoutSection: (ctx) => {
        const preCheckoutSection = document.createElement('div');
        ctx.appendChild(preCheckoutSection);
    
        ctx.onChange((next) => {
          // Clear the existing content
          preCheckoutSection.innerHTML = '';
    
          if (Object.keys(next.data.items).length === 0) {
            return;
          }
    
          // Create a wrapper div for the shadow background
          const shadowWrapper = document.createElement('div');
          shadowWrapper.style.backgroundColor = '#EEEFFB';
          shadowWrapper.style.borderRadius = '5px';
    
          // Create the content div
          const contentDiv = document.createElement('div');
          contentDiv.innerHTML = "Earn rewards every time you shop! Sign up for our free loyalty program today and start earning points on this purchase.";
          contentDiv.style.display = 'flex';
          contentDiv.style.flexDirection = 'column';
          contentDiv.style.padding = '12px';
    
          // Append the content div to the shadow wrapper
          shadowWrapper.appendChild(contentDiv);
    
          // Append the shadow wrapper to the preCheckoutSection div
          preCheckoutSection.appendChild(shadowWrapper);
        });
      },
    },
  })(orderSummary);
```

---

# Cart styles

The CSS classes for each UI component that provides the cart drop-in component with its UI are provided here. Override these classes and add new classes to customize the look and feel of your cart to match your specific style requirements.

## Customizing your cart styles

The quickest way to override the cart CSS is to inspect the cart UI from your browser's developer tools.


  ![Find CSS classes to override](@images/dropins/findstylescart.webp/)




1. **Inspect the element** in the UI that you want to customize (right-click on the element and select "Inspect" from the menu).
1. **Identify the CSS class(es)** for the element. We use [BEM naming](https://getbem.com/naming/), which makes it easy to know which component you're changing (and which CSS file to use). This class styles the `Cart` component, so use your `cart.css` file.
1. **Copy the CSS class** to your `cart.css` file to override the existing rules or add new rules to the class. But wait! Look closely ðŸ§ at the `.cart-cart__heading` class. It's using two **design tokens**. And when you see a design token within a CSS rule, don't remove the token. Instead, change the token's value (where it's defined) OR create a new token along-side this existing one to ensure maintenance and updates continue to benefit from global design token usage.



## Example CSS overrides

Here's an example of adding CSS class overrides to your `cart.css` file:

```css title="cart.css"
.cart-cart__heading {
  color: var(--color-positive-800);
}

.cart-empty-cart__wrapper {
  text-align: center;
}

.cart-mini-cart__footer {
  row-gap: var(--spacing-small);
}
```

## Cart component CSS

The CSS classes for each cart component are provided here.







## Summary

You can customize the cart by overriding the CSS classes provided for each component. Create a CSS file for each component to make it easier to maintain and update your cart CSS. Use the BEM naming convention and your browser's dev tools to identify and copy the class to your corresponding component CSS file and override it as needed. Happy styling! ðŸŽ¨

---

# Add messages to mini cart

This tutorial shows you how to add inline and overlay feedback messages that appear in the mini cart when products are added or updated to the cart. These messages provide visual feedback to shoppers about their cart actions.

Inline messages appear at the top of the mini cart for a brief period (three seconds by default) and then automatically disappear, providing immediate feedback to users about their cart actions.


  ![Minicart inline message](@images/dropins/cart/minicart-inline.png/)


Overlay messages are displayed at the top center of the mini cart with a semi-transparent background when the same events occur.


  ![Minicart overlay message](@images/dropins/cart/minicart-overlay.png/)


You can customize the appearance and behavior of the inline and overlay messages by modifying the following:

- **Message text**: Update the translations in the the content placeholders sheet under the `Cart.MiniCart.Message` namespace.
- **Message styling**: Modify the CSS classes in `commerce-mini-cart.css`. The styles use design tokens (prefixed with `--`) to maintain consistency with the design system. Overlays can be customized as follows:
   - Background opacity using the alpha value in the overlay's `background-color` (default is 50%)
   - Message position using the `top`, `left`, and `transform` properties
   - Colors, spacing, shadows, and other visual properties using design tokens

- **Message position**: For inline messages, change where the message appears in the mini cart by modifying the insertion point in the DOM.
- **Display duration**: Change the timeout value in the `showMessage` function (default is 3000ms).

## Prerequisites

Before implementing inline messages, ensure you have:

- Access to the content folder to manage message localization through placeholders.
- Understanding of the design system tokens used in the Commerce boilerplate template.
- The `commerce-mini-cart.css` file in your `blocks/commerce-mini-cart/` directory.

> **Note:** The CSS styles use design tokens (prefixed with `--`) to maintain consistency with the design system. These tokens are defined in the boilerplate's design system.

## Events

The inline and overlay messages respond to two cart events:

- `cart/product/added`: Triggered when products are added to the cart
- `cart/product/updated`: Triggered when products in the cart are updated

## Implementation

To add inline or overlay messages to your mini cart, follow these steps:


<Task>
### Retrieve translations for message texts using placeholders

Get translations for custom messages from the content folder.

```javascript
const placeholders = await fetchPlaceholders();

// Access the message texts from the Cart.MiniCart.Message namespace
const MESSAGES = {
  ADDED: placeholders?.Cart?.MiniCart?.Message?.added,
  UPDATED: placeholders?.Cart?.MiniCart?.Message?.updated,
};
```
</Task>
<Task>
### Create the appropriate message containers

Inline messages require a container for the update message and a shadow wrapper to display the message. Overlay messages require an overlay container and a message container.

<Tabs>
<TabItem label="Inline messages">

```javascript
// Create a container for the update message
const updateMessage = document.createElement('div');
updateMessage.className = 'commerce-mini-cart__update-message';

// Create a shadow wrapper
const shadowWrapper = document.createElement('div');
shadowWrapper.className = 'commerce-mini-cart__message-wrapper';
shadowWrapper.appendChild(updateMessage);
```
</TabItem>
<TabItem label="Overlay messages">

```javascript
// Create an overlay container
const overlay = document.createElement('div');
overlay.className = 'commerce-mini-cart__overlay';

// Create a message container
const messageContainer = document.createElement('div');
messageContainer.className = 'commerce-mini-cart__message';

overlay.appendChild(messageContainer);
```
</TabItem>
</Tabs>

</Task>

<Task>
### Create a function to show and hide messages

Create a function that displays the message in the container and then hides it after a specified duration, such as three seconds.

<Tabs>
<TabItem label="Inline messages">
```javascript
const showMessage = (message) => {
  updateMessage.textContent = message;
  updateMessage.classList.add('commerce-mini-cart__update-message--visible');
  shadowWrapper.classList.add('commerce-mini-cart__message-wrapper--visible');
  setTimeout(() => {
    updateMessage.classList.remove('commerce-mini-cart__update-message--visible');
    shadowWrapper.classList.remove('commerce-mini-cart__message-wrapper--visible');
  }, 3000);
};
```
</TabItem>
<TabItem label="Overlay messages">

```javascript
const showMessage = (message) => {
  messageContainer.textContent = message;
  overlay.classList.add('commerce-mini-cart__overlay--visible');
  setTimeout(() => {
    overlay.classList.remove('commerce-mini-cart__overlay--visible');
  }, 3000);
};
```
</TabItem>
</Tabs>
</Task>

<Task>
### Add event listeners for cart updates

Listen for the `cart/product/added` and `cart/product/updated` events and display the appropriate message.

```javascript

events.on('cart/product/added', () => showMessage(MESSAGES.ADDED), {
  eager: true,
});
events.on('cart/product/updated', () => showMessage(MESSAGES.UPDATED), {
  eager: true,
});
```
</Task>

<Task>
### Insert the message container into the mini cart block

Add the message container to the mini cart block to display the messages.

<Tabs>
<TabItem label="Inline messages">
```javascript
// Find the products container and add the message div at the top
const productsContainer = block.querySelector('.cart-mini-cart__products');
if (productsContainer) {
  productsContainer.insertBefore(shadowWrapper, productsContainer.firstChild);
} else {
  console.info('Products container not found, appending message to block');
  block.appendChild(shadowWrapper);
}
```
</TabItem>

<TabItem label="Overlay messages">
```javascript
block.appendChild(overlay);
```
</TabItem>
</Tabs>
</Task>

<Task>
### Update the CSS styles

Add styles to your `commerce-mini-cart.css` file.

<Tabs>
<TabItem label="Inline messages">
```css
.commerce-mini-cart__update-message {
  display: none;
  font: var(--type-body-2-default-font);
  letter-spacing: var(--type-body-2-default-letter-spacing);
}

.commerce-mini-cart__message-wrapper {
  background-color: var(--color-positive-200);
  border-radius: var(--shape-border-radius-1);
  padding: var(--spacing-xsmall);
  display: none;
  margin-bottom: var(--spacing-small);
}

.commerce-mini-cart__message-wrapper--visible,
.commerce-mini-cart__update-message--visible {
  display: block;
}
```
</TabItem>
<TabItem label="Overlay messages">
```css
.commerce-mini-cart__overlay {
  background-color: rgb(0 0 0 / 50%);
  display: none;
  position: absolute;
  inset: 0;
  z-index: 1000;
  border-radius: var(--shape-border-radius-1);
}

.commerce-mini-cart__message {
  background-color: var(--color-positive-200);
  border-radius: var(--shape-border-radius-1);
  padding: var(--spacing-small);
  position: absolute;
  top: var(--spacing-medium);
  left: 50%;
  transform: translateX(-50%);
  font: var(--type-body-2-default-font);
  letter-spacing: var(--type-body-2-default-letter-spacing);
  box-shadow: var(--shape-shadow-3);
  width: 90%;
  max-width: 400px;
  text-align: center;
}

.commerce-mini-cart__overlay--visible {
  display: block;
}
```
</TabItem>
</Tabs>
</Task>


## Complete example

Here's a complete example of implementing inline and overlay messages in your `commerce-mini-cart.js` block file:


<TabItem label="Inline messages">
```javascript

// Initializers


export default async function decorate(block) {
  const {
    'start-shopping-url': startShoppingURL = '',
    'cart-url': cartURL = '',
    'checkout-url': checkoutURL = '',
  } = readBlockConfig(block);

  // Get translations for custom messages
  const placeholders = await fetchPlaceholders();

  const MESSAGES = {
    ADDED: placeholders?.Cart?.MiniCart?.Message?.added,
    UPDATED: placeholders?.Cart?.MiniCart?.Message?.updated,
  };

  // Create a container for the update message
  const updateMessage = document.createElement('div');
  updateMessage.className = 'commerce-mini-cart__update-message';

  // Create shadow wrapper
  const shadowWrapper = document.createElement('div');
  shadowWrapper.className = 'commerce-mini-cart__message-wrapper';
  shadowWrapper.appendChild(updateMessage);

  const showMessage = (message) => {
    updateMessage.textContent = message;
    updateMessage.classList.add('commerce-mini-cart__update-message--visible');
    shadowWrapper.classList.add('commerce-mini-cart__message-wrapper--visible');
    setTimeout(() => {
      updateMessage.classList.remove('commerce-mini-cart__update-message--visible');
      shadowWrapper.classList.remove('commerce-mini-cart__message-wrapper--visible');
    }, 3000);
  };

  // Add event listeners for cart updates
  events.on('cart/product/added', () => showMessage(MESSAGES.ADDED), {
    eager: true,
  });
  events.on('cart/product/updated', () => showMessage(MESSAGES.UPDATED), {
    eager: true,
  });

  block.innerHTML = '';

  // Render MiniCart first
  await provider.render(MiniCart, {
    routeEmptyCartCTA: startShoppingURL ? () => rootLink(startShoppingURL) : undefined,
    routeCart: cartURL ? () => rootLink(cartURL) : undefined,
    routeCheckout: checkoutURL ? () => rootLink(checkoutURL) : undefined,
    routeProduct: (product) => rootLink(`/products/${product.url.urlKey}/${product.topLevelSku}`),
  })(block);

  // Find the products container and add the message div at the top
  const productsContainer = block.querySelector('.cart-mini-cart__products');
  if (productsContainer) {
    productsContainer.insertBefore(shadowWrapper, productsContainer.firstChild);
  } else {
    console.info('Products container not found, appending message to block');
    block.appendChild(shadowWrapper);
  }

  return block;
}
```
</TabItem>
<TabItem label="Overlay messages">
```javascript

// Initializers


export default async function decorate(block) {
  const {
    'start-shopping-url': startShoppingURL = '',
    'cart-url': cartURL = '',
    'checkout-url': checkoutURL = '',
  } = readBlockConfig(block);

  // Get translations for custom messages
  const placeholders = await fetchPlaceholders();

  const MESSAGES = {
    ADDED: placeholders?.Cart?.MiniCart?.Message?.added,
    UPDATED: placeholders?.Cart?.MiniCart?.Message?.updated,
  };

  block.innerHTML = '';

  // Render MiniCart first
  await provider.render(MiniCart, {
    routeEmptyCartCTA: startShoppingURL ? () => rootLink(startShoppingURL) : undefined,
    routeCart: cartURL ? () => rootLink(cartURL) : undefined,
    routeCheckout: checkoutURL ? () => rootLink(checkoutURL) : undefined,
    routeProduct: (product) => rootLink(`/products/${product.url.urlKey}/${product.topLevelSku}`),
  })(block);

  // Create overlay container
  const overlay = document.createElement('div');
  overlay.className = 'commerce-mini-cart__overlay';

  // Create message container
  const messageContainer = document.createElement('div');
  messageContainer.className = 'commerce-mini-cart__message';

  overlay.appendChild(messageContainer);
  block.appendChild(overlay);

  const showMessage = (message) => {
    messageContainer.textContent = message;
    overlay.classList.add('commerce-mini-cart__overlay--visible');
    setTimeout(() => {
      overlay.classList.remove('commerce-mini-cart__overlay--visible');
    }, 3000);
  };

  // Add event listeners for cart updates
  events.on('cart/product/added', () => showMessage(MESSAGES.ADDED), {
    eager: true,
  });
  events.on('cart/product/updated', () => showMessage(MESSAGES.UPDATED), {
    eager: true,
  });

  return block;
}
```
</TabItem>

And here's the accompanying CSS file (`commerce-mini-cart.css`):


<TabItem label="Inline messages">
```css
.commerce-mini-cart__update-message {
  display: none;
  font: var(--type-body-2-default-font);
  letter-spacing: var(--type-body-2-default-letter-spacing);
}

.commerce-mini-cart__message-wrapper {
  background-color: var(--color-positive-200);
  border-radius: var(--shape-border-radius-1);
  padding: var(--spacing-xsmall);
  display: none;
  margin-bottom: var(--spacing-small);
}

.commerce-mini-cart__message-wrapper--visible,
.commerce-mini-cart__update-message--visible {
  display: block;
}
```
</TabItem>
<TabItem label="Overlay messages">
```css
.commerce-mini-cart__overlay {
  background-color: rgb(0 0 0 / 50%);
  display: none;
  position: absolute;
  inset: 0;
  z-index: 1000;
  border-radius: var(--shape-border-radius-1);
}

.commerce-mini-cart__message {
  background-color: var(--color-positive-200);
  border-radius: var(--shape-border-radius-1);
  padding: var(--spacing-small);
  position: absolute;
  top: var(--spacing-medium);
  left: 50%;
  transform: translateX(-50%);
  font: var(--type-body-2-default-font);
  letter-spacing: var(--type-body-2-default-letter-spacing);
  box-shadow: var(--shape-shadow-3);
  width: 90%;
  max-width: 400px;
  text-align: center;
}

.commerce-mini-cart__overlay--visible {
  display: block;
}
```
</TabItem>

---

# Add custom product lines to the cart summary

This tutorial describes how to make the following customizations to the `CartSummaryList` container using the Adobe Commerce Boilerplate:

- Add text from a custom product attribute
- Display promotional information in the footer of each product in the cart

## Prerequisites

This tutorial requires that you create the following entities in the Adobe Commerce Admin:

- A custom product attribute. Here, the product attribute is assigned the label `Shipping Notes`, and the **Catalog Input Type for Store Owner* is set to **Text Field**. You can optionally set the **Used for Sorting in Product Listing** option to **Yes** to increase the visibility of products using the product attribute in the Products grid. [Product attributes overview](https://experienceleague.adobe.com/en/docs/commerce-admin/catalog/product-attributes/product-attributes) describes how to create a custom product attribute.

  In addition, you must assign the product attribute to one or more products. In this tutorial, the text fields will contain the strings "These item(s) are available to ship on Nov 1, 2024" and "FINAL SALE: This item ships separately and is ineligible for return.".

- A custom cart price rule. In this tutorial, a cart price rule named `25% Off $75+ with Code BOO24` has been created. Its definition defines the coupon code, the discount amount, and the conditions that must be met to apply the discount. [Cart price rules overview](https://experienceleague.adobe.com/en/docs/commerce-admin/marketing/promotions/cart-rules/price-rules-cart) describes how to create a cart price rule.

## Step-by-step

The following steps describe how to modify the [commerce-cart.js](https://github.com/hlxsites/aem-boilerplate-commerce/blob/main/blocks/commerce-cart/commerce-cart.js) block file in the boilerplate template to add custom content to the `CartSummaryList` container.



<Task>

### Add text from a custom product attribute

In this task, we'll add text that provides shipping information when certain conditions apply. For example, an item might be out of stock, and therefore cannot be shipped immediately. Or maybe the product is on clearance and cannot be returned. The `CartSummaryList` component is extended to display text defined by a merchant in the Admin using a custom product attribute. If the custom product attribute is not assigned to a product, then no additional information is displayed.

The following images show how these custom lines can be rendered:

<Diagram caption="">
   ![](@images/dropins/cart/cart-product-line-shipping.png)
</Diagram>

<Diagram caption="">
   ![](@images/dropins/cart/cart-product-line-final.png)
</Diagram>

<Steps>

1. Open the `blocks/commerce-cart/commerce-cart.js` boilerplate file. This file imports the `CartSummaryList` container, and we want to use a slot to display the custom product attribute. Find the `provider.render(CartSummaryList, {` line in the file and insert a `ProductAttributes` slot with the following code:

   ```javascript
    slots: {
      ProductAttributes: (ctx) => {
        // Prepend Product Attributes
        const ProductAttributes = ctx.item?.productAttributes;

        ProductAttributes?.forEach((attr) => {
          if(attr.code === "shipping_notes") {
            if(attr.selected_options) {
              const selectedOptions = attr.selected_options
              .filter((option) => option.label.trim() !== '')
              .map((option) => option.label)
              .join(', ');
              
              if(selectedOptions) {
                const productAttribute = document.createElement('div');
                productAttribute.innerText = `${attr.code}: ${selectedOptions}`;
                ctx.appendChild(productAttribute);
              }
            } else if (attr.value) {
              const productAttribute = document.createElement('div');
              productAttribute.innerText = `${attr.code}: ${attr.value}`;
              ctx.appendChild(productAttribute);
            }
          }
        })
      },
   ```

   This code creates a slot named `ProductAttributes` that displays the custom product attribute `Shipping Notes`, if it is assigned to a product. If the corresponding attribute is found, the slot creates a new `div` element and appends the attribute code and value to the element. The element is then appended to the `ctx` element, which is the product line in the cart summary.

1. Save the file and generate the page to see the changes.


</Steps>

</Task>

<Task>

### Display promotional information in the footer of a cart item

Now we'll add information defined in a custom cart price rule to the footer of the `CartSummaryList` container. If the the conditions set in the cart price rules are not met, then no additional information is displayed. For example, if a specific coupon has not been applied or if the subtotal threshold has not been met, then this information is not displayed.

<Diagram caption="Display coupon information">
   ![Display coupon information](@images/dropins/cart/cart-product-line-footer.png/)
</Diagram>

<Steps>

1. Add a `Footer` slot beneath the `ProductAttributes` slot.

   ```javascript

    slots: {
      ProductAttributes: (ctx) => {
        ...
        }
        
      Footer: (ctx) => {
        // Runs on mount
        const wrapper = document.createElement('div');
        ctx.appendChild(wrapper);

        // Append Product Promotions on every update
        ctx.onChange((next) => {
        wrapper.innerHTML = '';

          next.item?.discount?.label?.forEach((label) => {
          const discount = document.createElement('div');
          discount.style.color = '#3d3d3d';
          discount.innerText = label;
          wrapper.appendChild(discount);
        });
      });
    },
   ```

   This code creates a slot named `Footer`, which displays the promotional information defined in the custom cart price rule. If the conditions set in the cart price rule are met, the slot creates a new `div` element and appends the promotional information to the element. The element is then appended to the `ctx` element, which is the product line in the cart summary.

1. Save the file. Add products that total at least $75 and apply the BOO24 coupon code to the cart. The page displays the rule name beneath each item in the cart.

</Steps>

</Task>

---

# Customize the cart summary block

This tutorial describes how to make the following customizations to the `CartSummaryList` container using the Adobe Commerce Boilerplate:

- Change the product quantity selector to a dropdown menu.
- Configure how to display savings.
- Configure the savings display from the Cart content document.

## Step-by-step

The following steps describe how to modify the [commerce-cart.js](https://github.com/hlxsites/aem-boilerplate-commerce/blob/main/blocks/commerce-cart/commerce-cart.js) block file in the boilerplate template to add custom content to the `CartSummaryList` container.



<Task>

### Change the product quantity selector to a dropdown menu

By default, the product quantity selector is a stepper, as shown below:

<Diagram caption="Stepper quantity selector">
   ![Stepper quantity selector](@images/dropins/cart/cart-summary-stepper.png/)
</Diagram>

In this task, you'll change the quantity selector to a dropdown menu. The dropdown allows shoppers to select a maximum of 20 items.

<Diagram caption="Dropdown quantity selector">
   ![Dropdown quantity selector](@images/dropins/cart/cart-summary-dropdown.png/)
</Diagram>

<Steps>

1. Navigate to the `blocks/commerce-cart/commerce-cart.js` file and enable the dropdown selector by adding the following lines to the `provider.render(CartSummaryList)` method:

   ```js
   quantityType: 'dropdown',
   dropdownOptions,
   ```

   The `quantityType` property specifies the type of quantity selector to use. The `dropdownOptions` property specifies the values to display in the dropdown. It is defined in the next step.

1. Define the `dropdownOptions` constant at the top of the file, in the `export defult async function decorate(block){}` statement.

   ```js
   const DROPDOWN_MAX_QUANTITY = 20;

   const dropdownOptions = Array.from(
     { length: parseInt(DROPDOWN_MAX_QUANTITY, 10) },
     (_, i) => {
         const quantityOption = i + 1;
         return {
           value: `${quantityOption}`,
           text: `${quantityOption}`,
         };
     }
   );
     ```

     This code creates an array of objects with `value` and `text` properties. The `value` property is the quantity value, and the `text` property is the text displayed in the dropdown.

1. Save the file and generate the page to see the changes.

</Steps>

</Task>

<Task>

### Display savings as a percentage or a fixed amount

In order to encourage shoppers to buy more, you can display the savings they'll get by purchasing more items. You can display the savings on an item that's on sale as a percentage or as a fixed amount.

<Diagram caption="Savings expressed as a percentage">
   ![Savings expressed as a percentage](@images/dropins/cart/cart-summary-percentage.png/)
</Diagram>

<Diagram caption="Savings expressed as a total">
   ![Savings expressed as a percentage](@images/dropins/cart/cart-summary-total.png/)
</Diagram>

<Steps>

1. Add the following lines to the `provider.render(CartSummaryList)` method, below the `dropdownOptions,` line:

   ```js
   showDiscount: true,
   //showSavings: true
   ```

   Comment out one of the lines to choose between displaying the discount as a percentage or a fixed amount.

1. Save the file and generate the page to see the changes.

</Steps>

</Task>

<Task>

### Configure the savings display from the Cart content document

To allow a merchandiser or other non-developer to configure how to display savings values, you need to make more changes to the `commerce-cart.js` file and the relevant content documents. For guidance on starter content and the Sidekick browser extension, review [Create your storefront](https://experienceleague.adobe.com/developer/commerce/storefront/get-started/).

<Steps>

1. Comment out the savings properties from the `provider.render(CartSummaryList)` method.

    ```js
    //showDiscount: true,
    //showSavings: true
    ```

1. Add the following lines to the constant definitions in the `export default async function decorate(block){}` statement:

   ```js
   'show-discount': showDiscount = 'false',
   'show-savings': showSavings = 'false',
   ```

1. Add new lines in the `provider.render(CartSummaryList)` method to check whether `showDiscount` or `showSavings` is set to `true`:

   ```js
   showDiscount: showDiscount === 'true',
   showSavings: showSavings === 'true',
   ```

1. Save the file. When you generate the page, discounts are not displayed because the default values are `false`.

1. Find the `cart` content document in your site's content folder, and add two rows to the Commerce Cart table that set the visibility values for these properties.

   <Diagram caption="Commerce Cart table">
      ![Commerce Cart table](@images/dropins/cart/cart-table.png/)
   </Diagram>

   Set the values of the Show Discount and Show Savings rows to either `true` or `false`.

1. Preview the changes with the Sidekick browser extension. Then publish the changes to your staging or production environment.

</Steps>

</Task>

---

# Configuring Product Variation Updates in the Cart

This tutorial shows you how to configure the Edit feature for product variations in both the cart and mini-cart. The **Edit** button allows shoppers to update product variations (like size or color) directly from the cart pages.

The implementation is already available in the codebase. This tutorial focuses on how to *enable* or *disable* this feature through the AEM block configuration.

> **Note:** This feature works for configurable products in the cart. When enabled, an **Edit** button appears for each applicable item, allowing shoppers to modify their selected options without having to navigate away from the cart.

## How it Works

The **Edit** button feature is controlled by a configuration flag (`enable-updating-product`) that can be set on both the `commerce-cart` and `commerce-mini-cart` blocks in AEM. When activated, it opens a modal interface with a mini Product Detail Page (PDP) that allows shoppers to modify their selected options contextually.


<TabItem label="Cart">
In the `commerce-cart.js` implementation, the code checks for this flag and conditionally renders an **Edit** button in the `Footer` slot for configurable products:

```javascript
// First, the configuration is read from the block with a default of 'false'
const {
  'hide-heading': hideHeading = 'false',
  'max-items': maxItems,
  // ... other config properties ...
  'checkout-url': checkoutURL = '',
  'enable-updating-product': enableUpdatingProduct = 'false',
} = readBlockConfig(block);

// Later in the code, inside the Footer slot
if (ctx.item?.itemType === 'ConfigurableCartItem' && enableUpdatingProduct === 'true') {
  const editLink = document.createElement('div');
  editLink.className = 'cart-item-edit-link';

  UI.render(Button, {
    children: placeholders?.Global?.CartEditButton,
    variant: 'tertiary',
    size: 'medium',
    icon: h(Icon, { source: 'Edit' }),
    onClick: () => handleEditButtonClick(ctx.item),
  })(editLink);

  ctx.appendChild(editLink);
}
```

When a shopper clicks the **Edit** button, a modal opens with a mini-PDP interface that allows them to modify their product options. An auto-dismissing notification appears after a successful update.
</TabItem>

<TabItem label="Mini Cart">
Similarly, in the `commerce-mini-cart.js` implementation, the code uses the same configuration flag to determine whether to display an **Edit** button for each configurable product in the mini-cart, implementing it in the `Thumbnail` slot:

```javascript
// First, the configuration is read from the block with a default of 'false'
const {
  'start-shopping-url': startShoppingURL = '',
  'cart-url': cartURL = '',
  'checkout-url': checkoutURL = '',
  'enable-updating-product': enableUpdatingProduct = 'false',
} = readBlockConfig(block);

// Later in the code, inside the Thumbnail slot
if (item?.itemType === 'ConfigurableCartItem' && enableUpdatingProduct === 'true') {
  const editLinkContainer = document.createElement('div');
  editLinkContainer.className = 'cart-item-edit-container';

  const editLink = document.createElement('div');
  editLink.className = 'cart-item-edit-link';

  UI.render(Button, {
    children: placeholders?.Global?.CartEditButton,
    variant: 'tertiary',
    size: 'medium',
    icon: h(Icon, { source: 'Edit' }),
    onClick: () => handleEditButtonClick(item),
  })(editLink);

  editLinkContainer.appendChild(editLink);
  ctx.appendChild(editLinkContainer);
}
```

When enabled, this provides a convenient modal-based editing experience. Success messages appear in both the mini-cart and main cart notification areas simultaneously, ensuring consistent user feedback across all cart interfaces.
</TabItem>


## Configuration Steps

To modify this feature's configuration, follow these steps:


<Task>
### Configure the Cart Summary Block

The cart block shows **Edit** buttons *by default* when configurable products are present. If you want to disable it:

1. In your AEM authoring environment, navigate to the page containing your `commerce-cart` block.
2. Select the `commerce-cart` block and open its properties dialog.
3. Locate the existing property with the *Key* `Enable Updating Product`.
4. Change its *Value* to `false` to disable the feature.
5. Save the changes.
6. Preview the changes by clicking the **Preview** button.
7. Publish the changes by clicking the **Publish** button.

<Aside type="tip">
  The configuration is already provided in the content block, so you don't need to add a new property - just modify the existing one as needed.
</Aside>
</Task>

<Task>
### Configure the Mini Cart Block

The `enable-updating-product` property is *already set to `false` by default* in the mini-cart block. If you want to enable it:

1. In your AEM authoring environment, navigate to the page or header that contains your `commerce-mini-cart` block.
2. Select the `commerce-mini-cart` block and open its properties dialog.
3. Locate the existing property with the *Key* `Enable Updating Product`.
4. Change its *Value* to `true` to enable the feature.
5. Save the changes.
6. Preview the changes by clicking the **Preview** button.
7. Publish the changes by clicking the **Publish** button.

<Aside type="note">
By default, the mini cart does not show **Edit** buttons and needs to be explicitly enabled.
</Aside>
</Task>

<Task>
### Example Block Configurations

Here's how your block configuration should look like:

**Cart Block (Enabled by Default):**

| Key                       | Value |
| :------------------------ | :---- |
| `Enable Updating Product` | `true`|
| `Checkout URL`            | `/checkout` |  *(Example of another common property)*

**Mini Cart Block (Disabled by Default):**

| Key                       | Value |
| :------------------------ | :---- |
| `Enable Updating Product` | `false`|
| `Checkout URL`            | `/checkout` | *(Example of another common property)*

<Aside type="caution">
  The property appears as `Enable Updating Product` (with spaces) in the AEM properties dialog, but is converted to kebab-case (`enable-updating-product`) when processed by the code.
</Aside>
</Task>


## Testing the Configuration

After configuring the feature, you should test it to ensure it's working as expected:

1. Add a configurable product to your cart.
2. View your cart page:
   - If enabled, you should see an **Edit** button for each configurable product.
   - If disabled, no **Edit** button should appear.
3. Open the mini cart:
   - If enabled, you should see an `Edit` option for configurable products.
   - If disabled, no `Edit` option should be visible.

## Feature Behavior

When the **Edit** button is clicked, the following happens:

1. **Modal Interface**: A mini-PDP modal opens directly over the current page, maintaining user context.
2. **Pre-populated Options**: The modal displays the product with current selections already chosen.
3. **In-place Updates**: Changes are applied to the existing cart item.
4. **Comprehensive Messaging**: Success notifications appear in:
   - The main cart notification area (if present)
   - The mini-cart message system
   - Both locations simultaneously for consistent feedback
5. **Auto-dismissing Notifications**: Messages automatically disappear for better UX.

> **Note:** Using modals ensures users don't lose their shopping context when making product modifications.

With this simple configuration, you can provide your shoppers with a more convenient shopping experience by allowing them to modify product variations directly from the cart.

---

# Add gift options to a product detail page

The [`GiftOptions` container](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/gift-options/) allows you to add gift options, such as gift wrapping or personalized messages, at various places on the storefront, including product detail pages. The gift option features enhance the shopping experience by enabling customers to select these options at multiple times during their shopping experience, such as when adding a product to the cart or during checkout.

The code examples provided here demonstrate the general approach to building custom integrations with the `GiftOptions` container.

> **Note:** This tutorial is not a fully functional integration and should only be used as a reference.

## Step-by-step

The following steps describe how to render the `GiftOptions` container on the PDP page and apply the selected gift options to the cart when the product is added.


<Task>
### Import required modules

Import the `GiftOptions` container and `CartProvider`.

```js
```

</Task>
<Task>
### Define gift options configuration for an item

In this step, we will define the gift options configuration for a specific item. This can be done in different ways, such as by fetching configurations from the backend using API methods or retrieving them from product data.

#### Example 1: Use `cartItem` data

Use this technique when the product has already been added to the cart, such as on the cart page:

```js
â€‹â€‹const cartItem = JSON.parse(
 sessionStorage.getItem('DROPIN__CART__CART__DATA'),
)?.items?.find((el) => el.sku === product.sku);
```

#### Example 2: Use a custom integration configuration

This configuration can be composed using product data available on the PDP and a store configuration query.

:::tip
It is crucial that the manually-composed configuration matches the actual backend configurations. For example, the available gift wrappings must be fetched from the backend. Otherwise, they will not be applied correctly. The [`GiftOptions` container](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/gift-options/) lists the relevant configuration screens in the Admin.
:::

```js
type ProductGiftOptionsConfig = {
 giftWrappingAvailable: boolean;
 giftMessageAvailable: boolean;
 giftWrappingPrice?: Price;
 giftMessage?: {
   recipientName?: string;
   senderName?: string;
   message?: string;
 };
 productGiftWrapping: GiftWrappingConfigProps[];
};

const predefinedConfig = {
 giftWrappingAvailable: true,
 giftMessageAvailable: true,
 productGiftWrapping: [
   {
     design: 'Glossy Print Paper',
     uid: 'Mg==',
     selected: false,
     image: {
       url: 'https://aemshop.example.com/media/wrapping/glossy.png',
       label: 'glossy.png',
     },
     price: {
       currency: 'USD',
       value: 25,
     },
   },
   {
     design: 'Foil Finish Paper',
     uid: 'NQ==',
     selected: false,
     image: {
       url: 'https://aemshop.example.com/media/wrapping/random-grid.jpg',
       label: 'random-grid.jpg',
     },
     price: {
       currency: 'USD',
       value: 30,
     },
   },
   {
     design: 'Kraft Brown Paper',
     uid: 'OA==',
     selected: false,
     image: {
       url: 'https://mcstaging.aemshop.net/media/wrapping/brown-paper.jpg',
       label: 'brown-paper.jpg',
     },
     price: {
       currency: 'USD',
       value: 45,
     },
   },
 ],
};
```

</Task>
<Task>
### Render the GiftOptions container

For custom integration, we must pass an item prop, which can be either a `cartItem` or a manually-composed gift options configuration. In addition, we need to pass the `onGiftOptionsChange` callback. When provided, the container will not automatically save the gift options. Instead, the integration layer must handle this. The callback receives the updated gift options whenever they change.

```js
CartProvider.render(GiftOptions, {
 item: cartItem ?? predefinedConfig,
 view: 'product',
 onGiftOptionsChange: async (data) => {
   console.info('onGiftOptionsChange :>> ', data);
   if (data) {
     sessionStorage.setItem('updatedGiftOptions', JSON.stringify(data));
   }
 },
})($giftOptions);
```
</Task>

<Task>
### Update the Add to Cart button

At this stage, we extend the **Add to Cart** button functionality by calling the `updateProductsFromCart` API method provided by the cart drop-in component to apply gift options after adding the product to the cart.

<Aside>
Gift options must be applied after adding the product to the cart. Adobe Commerce does not support applying gift options before adding the product.
</Aside>

```js
// Configuration - Button - Add to Cart
UI.render(Button, {
 children: labels.PDP?.Product?.AddToCart?.label,
 icon: Icon({ source: 'Cart' }),
 onClick: async () => {
   try {
     addToCart.setProps((prev) => ({
       ...prev,
       children: labels.Custom?.AddingToCart?.label,
       disabled: true,
     }));

     // get the current selection values
     const values = pdpApi.getProductConfigurationValues();
     const valid = pdpApi.isProductConfigurationValid();

     // add the product to the cart
     if (valid) {
       const { addProductsToCart, updateProductsFromCart } = await import(
         '@dropins/storefront-cart/api.js'
       );
       await addProductsToCart([{ ...values }]).then(async (response) => {
         const updatedGiftOptions = JSON.parse(
           sessionStorage.getItem('updatedGiftOptions'),
         );

         if (!updatedGiftOptions) return;

         const { items } = response;
         const dropinCartData = items.find((el) => el.sku === values.sku);

         const {
           recipientName,
           senderName,
           message,
           giftWrappingId,
           isGiftWrappingSelected,
         } = updatedGiftOptions;

         const giftOptions = {
           gift_message: {
             to: recipientName,
             from: senderName,
             message,
           },
           gift_wrapping_id: isGiftWrappingSelected
             ? giftWrappingId
             : null,
         };
         await updateProductsFromCart([
           {
             uid: dropinCartData.uid,
             quantity: dropinCartData.quantity,
             giftOptions,
           },
         ]);
       });
     }

     // reset any previous alerts if successful
     inlineAlert?.remove();
   } catch (error) {
     // add alert message
     inlineAlert = await UI.render(InLineAlert, {
       heading: 'Error',
       description: error.message,
       icon: Icon({ source: 'Warning' }),
       'aria-live': 'assertive',
       role: 'alert',
       onDismiss: () => {
         inlineAlert.remove();
       },
     })($alert);

     // Scroll the alertWrapper into view
     $alert.scrollIntoView({
       behavior: 'smooth',
       block: 'center',
     });
   } finally {
     addToCart.setProps((prev) => ({
       ...prev,
       children: labels.PDP?.Product?.AddToCart?.label,
       disabled: false,
     }));
   }
 },
})($addToCart);
```
</Task>


As a result of these customizations, the default `GiftOption` container is rendered as follows:


![Default GiftOption  container](@images/dropins/cart/pdp-gift-options-default.png/)


When the shopper makes a selection, the container is rendered as follows:


![Default GiftOption  container](@images/dropins/cart/pdp-gift-options-selected.png/)


After clicking **Add to Cart**, the product is added to the cart, and the selected gift options are applied. The cart page displays the applied gift options.


![Default GiftOption  container](@images/dropins/cart/pdp-gift-options-cart.png/)

---

# Order Summary Lines

The Cart dropin allows you to customize the lines of the Order Summary to meet your requirements.

You might want to group and sort the order summary lines into sections using the native [Accordion component](https://elsie.dev/?path=/docs/components-accordion--overview) from [Elsie](https://elsie.dev/).

:::note[Note]
The elsie.dev site is currently available to partners only.
:::

You can specify the line items shown in the accordion and decide the order in which they are displayed.
You can also customize the title and content of these order summary lines.

## Customize the lines of the Order Summary to meet your needs

This customization is possible thanks to the attribute `updateLineItems` from the `OrderSummary` container. This attribute allows you to modify the order summary lines before they are rendered.

```typescript
export const OrderSummary: Container<OrderSummaryProps, CartModel | null> = ({
  ...
  updateLineItems = (lineItems) => lineItems,
  ...
});
```

It doesn't matter if you want to customize the existing order summary lines, add new ones, or skip some of them.
The `OrderSummary` container passes the `updateLineItems` to the `OrderSummary` component, which performs the appropriate actions.

`updateLineItems` is an optional function that receives the line items as an argument and returns the updated line items. In both cases, `lineItems` are an array of `OrderSummaryLineItem` object.

```typescript
export interface OrderSummaryLineItem {
  key: string;
  title?: string;
  className?: string;
  sortOrder: number;
  content:
    | string
    | JSXInternal.Element
    | VNode<HTMLAttributes<HTMLDivElement>>
    | OrderSummaryLineItem[]
    | undefined;
}
```

There are default order summary lines in the `OrderSummary` component. If no customization is needed, and therefore nothing is passed using the `updateLineItems` attribute, the default order summary lines will be rendered.
Let's imagine that `lineItems` contains the following lines:
```typescript
  const lineItems: Array = [
    {
      key: 'subTotalContent',
      sortOrder: 100,
      content: subTotalContent,
    },
    {
      key: 'discountsContent',
      sortOrder: 300,
      content: discountsContent,
    },
    {
      key: 'taxContent',
      sortOrder: 400,
      content: taxContent,
    },
  ];
```

In the example above, the `OrderSummary` component renders the sub-total, discounts, and tax lines, in that order.
The value of the `sortOrder` attribute determines the order in which the lines are rendered.
The larger the `sortOrder` value, the lower the line will be rendered in the order summary.

The `content` attribute can be a string, a JSX element, or an array of `OrderSummaryLineItem` objects (whenever is not `undefined`).
For instance, you could choose to render a JSX element in a form of a `OrderSummaryLine` container.
This `OrderSummaryLine` container it is defined as follows:

```typescript
export interface OrderSummaryLineProps extends HTMLAttributes<HTMLDivElement> {
  label: string;
  price: VNode<HTMLAttributes<HTMLSpanElement>>;
  classSuffixes?: Array<string>;
  labelClassSuffix?: string;
  testId?: string;
  children?: any;
}
```

See an example of how to use the `OrderSummaryLine` container below, where only the mandatory props are passed:
```html
    <OrderSummaryLine
      label={translations.subtotalLabel}
      price={subTotal.price}
      classSuffixes={['subTotal']}
    >
      {children}
    
  );
```

Note that the `OrderSummaryLine` container behaves like a wrapper for the `OrderSummaryLine` component.
The component ultimately decides how to render the line item based on the `children` attribute.

```typescript
export interface OrderSummaryLineComponentProps
  extends HTMLAttributes<HTMLDivElement> {
  label: string;
  price: VNode<HTMLAttributes<HTMLSpanElement>>;
  classSuffixes?: Array<string>;
  labelClassSuffix?: string;
  testId?: string;
  children?: any;
}
```

### Where to perform the customizations

To customize the order summary lines, you need to render the `Cart` component passing the `OrderSummary` component as a slot.
When rendering the `OrderSummary` component, you can pass the `updateLineItems` attribute to customize the order summary lines as needed.

```typescript
    // Cart
    provider.render(Cart, {
        slots: {
            OrderSummary: (ctx) => {
                const orderSummary = document.createElement('div');

                provider.render(OrderSummary, {
                    updateLineItems: (lineItems) => {
                        // Customize the order summary lines here
                        return lineItems;
                    }
                }
            }
        }
    });
```

## Examples

For the examples shown below, assume that this is how `Order Summary` looks originally:


  ![Cart without any customization](@images/dropins/cart/cart-originally.png/)



### Remove Item: Remove total saved

The following example removes the Total saved line:

```typescript
updateLineItems: (lineItems) => {
  const index = lineItems.map(item => item.key).indexOf('totalSavedContent');
  lineItems.splice(index, 1);

  return lineItems;
}
```


  ![Cart after removing Total Saved line](@images/dropins/cart/cart-after-remove-item.png/)


### Reorder items: Move primary action to the beginning

The following example moves the Checkout button to the top:

```typescript
updateLineItems: (lineItems) => {
    lineItems.map(lineItem => {
        if (lineItem.key === 'primaryActionContent') {
            lineItem.sortOrder = 50;
        }
        return lineItem;
    });

    return lineItems;
};
```


  ![Cart after moving primary action to the beginning](@images/dropins/cart/cart-after-reorder-items.png/)


### Group items: Group subtotal and tax in an accordion

The following example groups the subtotal and tax in an accordion:

```typescript
updateLineItems: (lineItems) => {
  const totalsIndex = lineItems.map(item => item.key).indexOf('taxContent');
  const taxContent = lineItems.splice(totalsIndex, 1)[0];
  const subtotalIndex = lineItems.map(item => item.key).indexOf('subTotalContent');
  const subTotalContent = lineItems.splice(subtotalIndex, 1)[0];
  lineItems.push({
    key: 'subtotalTaxGrouped',
    sortOrder: 50,
    title: 'Subtotal and Tax',
    content: [
      taxContent,
      subTotalContent,
    ],
  });

  return lineItems;
}
```


  ![Cart after grouping subtotal and tax in an accordion](@images/dropins/cart/cart-after-group-items.png/)


### Add item: Add a new order summary line

The following example adds the FPT line:

```typescript
updateLineItems: (lineItems) => {
    const totalFpt = ctx.data.items.reduce((allItemsFpt, item) => {
    const itemFpt = item.fixedProductTaxes.reduce((accumulator, fpt) => {
      accumulator.labels.push(fpt.label);
      accumulator.total += fpt.amount.value;
      return accumulator;
    }, {
      labels: [],
      total: 0
    });
    allItemsFpt.labels = [...allItemsFpt.labels, ...itemFpt.labels];
    allItemsFpt.total += itemFpt.total;
    return allItemsFpt;
  }, {
    labels: [],
    total: 0
  });

  lineItems.push({
    key: 'fpt',
    sortOrder: 350,
    title: 'Fixed Product Tax',
    content: OrderSummaryLine({label: "FPT(" + totalFpt.labels.join(',') + ')', price: Price({amount: totalFpt.total}), classSuffix: 'fpt'})
  })

  return lineItems;
};
```


  ![Cart after adding a new order summary line](@images/dropins/cart/cart-after-add-item.png/)

---

# AddressValidation container

The `AddressValidation` container displays a suggested shipping address (from a third-party verification service) alongside the entered address, allowing shoppers to choose between them.

Typically invoked from a modal during checkout after calling your address verification service.

## AddressValidation configurations

The `AddressValidation` container provides the following configuration options:



### AddressValidationProps interface

The `AddressValidation` container receives an object that implements the following interface:

```ts
interface AddressValidationProps {
  suggestedAddress: Partial<CartAddressInput> | null;
  handleSelectedAddress?: (payload: {
    selection: 'suggested' | 'original';
    address: CartAddressInput | null | undefined;
  }) => void;
}
```

- `suggestedAddress` - The normalized address to propose to the shopper.
- `handleSelectedAddress` - Called when the shopper selects an address. Use this to persist the selection or continue checkout.

## CartAddressInput type

The `CartAddressInput` type has this shape:

```ts
interface CartAddressInput {
  city: string;
  countryCode: string;
  postcode: string;
  region: string;
  street: string[];
}
```

> **Note:** The container automatically maps the current shipping address to `CartAddressInput` from checkout events. Only pass `suggestedAddress` when available.

> **Note:** Transform your address verification service output to `CartAddressInput` format (with fields like `street`, `city`, `region`, `countryCode`, `postcode`) before passing to the container. Missing properties default to the original address values.

## Example

For a complete walkthrough, see the [Validate shipping address](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/tutorials/validate-shipping-address/) tutorial.

---

# BillToShippingAddress container

The `BillToShippingAddress` container includes a checkbox that allows users to indicate if the billing address is the same as the shipping address. If unchecked, the billing address form will be displayed.

This container provides internal business logic to hide itself in case the cart is empty or virtual.

## BillToShippingAddress configurations

The `BillToShippingAddress` container provides the following configuration options:



These configuration options implement the `BillToShippingAddressProps` interface:

### BillToShippingAddressProps interface

The `BillToShippingAddress` container receives an object as a parameter which implements the `BillToShippingAddressProps` interface with the following properties:

```ts
interface CartSyncError {
  error: Error;
}

export interface BillToShippingAddressProps extends Omit<HTMLAttributes<HTMLDivElement>, 'onChange'> {
  active?: boolean;
  autoSync?: boolean;
  onCartSyncError?: (error: CartSyncError) => void;
  onChange?: (checked: boolean) => void;
}
```

- Set the `active` property to _true_ to have the container in reactive mode (it is visible and responds to system events). If it is set to _false_, the container is deactivated (it does not subscribe to system events and is not rendered).
- Set the `autoSync` property to _true_ to automatically synchronize the container state changes with the backend via API calls. If it is set to _false_ the container does not automatically synchronize its state, but still maintains local updates.
- The `onCartSyncError` property is a handler used to perform actions called when bill to shipping address checkbox is clicked and the setBillingAddressOnCart() API throws an error. It could be used as a callback in the integration layer by the merchant to show errors or perform other actions.
- The `onChange` property is a handler used to perform actions called when the checkbox is checked/unchecked.

## Example

The following example renders the `BillToShippingAddress` container on a checkout page. It handles changes to the billing address form visibility and validation. If the billing address form is shown, it validates the form data and updates the billing address on the cart. Finally, an error message is shown in case there is an issue saving the billing address to the backend.

```ts

const DEBOUNCE_TIME = 1000;

const $billToShipping = checkoutFragment.querySelector(
  '.checkout__bill-to-shipping',
);
const $billingForm = checkoutFragment.querySelector(
  '.checkout__billing-form',
);

const billingFormRef = { current: null };

CheckoutProvider.render(BillToShippingAddress, {
  onCartSyncError: (error) => {
    const billToShippingMsg = document.createElement('div');
    billToShippingMsg.style.color = 'red';
    billToShippingMsg.innerText = `Error saving the Billing address with the Shipping address information: ${error.message}`;
    $billToShipping.appendChild(billToShippingMsg);
  },
  onChange: (checked) => {
    $billingForm.style.display = checked ? 'none' : 'block';
    if (!checked && billingFormRef?.current) {
      const { formData, isDataValid } = billingFormRef.current;

      setAddressOnCart({
        api: checkoutApi.setBillingAddress,
        debounceMs: DEBOUNCE_TIME,
        placeOrderBtn: placeOrder,
      })({ data: formData, isDataValid });
    }
  },
})($billToShipping),
```

---

# EstimateShipping container

The `EstimateShipping` container is designed to estimate and display shipping costs during the checkout process.

This container is read-only, unlike the editable [`EstimateShipping`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/estimate-shipping/) container in the cart drop-in component. Initially, it displays estimated shipping costs. After a customer provides a shipping address and selects a shipping method, it shows the actual shipping cost. This container is designed to be used as a slot within the `OrderSummary` container from the cart, where the estimated shipping information is displayed.

## EstimateShipping configurations

The `EstimateShipping` container provides the following configuration options:



These configuration options implement the `EstimateShippingProps` interface:

### EstimateShippingProps interface

The `EstimateShipping` container receives an object as a parameter which implements the `EstimateShippingProps` interface with the following properties:

```ts
export interface EstimateShippingProps {
  active?: boolean;
}
```

- Set the `active` property to _true_ to have the container in reactive mode (it is visible and responds to system events). If it is set to _false_, the container is deactivated (it does not subscribe to system events and is not rendered).

## Example

The following example renders an `OrderSummary` container within a checkout page and includes a slot for estimating shipping:

```ts


const $orderSummary = checkoutFragment.querySelector(
  '.checkout__order-summary',
);

CartProvider.render(OrderSummary, {
  slots: {
    EstimateShipping: (esCtx) => {
      const estimateShippingForm = document.createElement('div');
      CheckoutProvider.render(EstimateShipping)(estimateShippingForm);
      esCtx.appendChild(estimateShippingForm);
    },
  },
})($orderSummary),
```

---

# Checkout containers

Checkout containers handle address collection, payment, and order placement. The following containers provide the building blocks for complete checkout experiences.



| Container | Description |
|-----------|-------------|
| [AddressValidation](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/address-validation/) | Validate addresses for accurate delivery. |
| [BillToShippingAddress](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/bill-to-shipping-address/) | Use shipping address as billing address. |
| [EstimateShipping](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/estimate-shipping/) | Estimate shipping costs before entering full address. |
| [LoginForm](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/login-form/) | Customer login for returning customers. |
| [MergedCartBanner](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/merged-cart-banner/) | Notify when guest cart merges with logged-in cart. |
| [OutOfStock](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/out-of-stock/) | Handle cart items unavailable during checkout. |
| [PaymentMethods](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/payment-methods/) | Payment options and secure payment collection. |
| [PlaceOrder](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/place-order/) | Submit order and complete checkout. |
| [ServerError](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/server-error/) | Display errors when checkout operations fail. |
| [ShippingMethods](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/shipping-methods/) | Shipping options with costs and delivery times. |
| [TermsAndConditions](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/terms-and-conditions/) | Terms, conditions, and agreements for acceptance. |



## Common container configuration

The following sections describe common properties that can be applied to Checkout containers.

### Title and heading customization

Each container provides a title and a heading by default. If you want to hide the title or provide a customized title, you can use the `TitleProps` interface.

#### TitleProps interface

The `TitleProps` interface provides the following configuration options:



The container receives an object that implements the `TitleProps` interface with the following properties:

```ts
export interface TitleProps {
  displayTitle?: boolean;
  slots?: {
    Title?: SlotProps;
  };
}
```

- The `displayTitle` property set to _true_ displays the title of the container; otherwise, the title will be hidden.
- The `slots` property is an object containing the following properties:
  - The `Title` property is a handler used to render a customized title content.

:::note
In the pages that follow, you will learn how to customize the `Title` and how to use it.
:::

### Active property

The `active` property indicates whether the container is active. When set to _false_, the container becomes non-reactive, meaning it will not respond to system events, will not subscribe to them, and will not be displayed in the user interface.

#### `active` prop declaration



```ts
active?: boolean;
```

#### Behavior:

- When `active` is _true_:
  - The container subscribes to system events
  - It renders in the user interface and it is visible (shows a skeleton or renders the component in the UI)
  - It executes its normal operations
- When `active` is _false_:
  - The container does not subscribe to system events
  - It does not render in the user interface and its visibility is set to false
  - Side effects and state updates are not executed

#### Example of `active` prop definition

In the following example, the `ShippingMethods` container will be deactivated; this means it will not be rendered to the UI and will not listen to system events.

```ts
CheckoutProvider.render(ShippingMethods, {
  UIComponentType: 'ToggleButton',
  displayTitle: false,
  active: false,
})($deliveryMethods),
```

### AutoSync property

The `autoSync` property determines whether the container automatically synchronizes its state changes with the backend via API calls. When set to _false_, the container does not automatically synchronize its state, but still maintains local updates.

#### `autoSync` prop declaration



```ts
autoSync?: boolean;
```

#### Behavior:

- When `autoSync` is _true_:
  - Local changes are synchronized with the backend
  - GraphQL mutations are executed when selection or local state changes
  - The remote cart is automatically updated
- When `autoSync` is _false_:
  - Changes are only maintained locally
  - No automatic GraphQL mutations are performed on the backend
  - Control of mutations is passed to parent or external components

#### Use cases:

- In multi-step checkout flows where you want to control when data is sent to the backend
- For nested containers where a parent container handles synchronization
- In implementations that need additional validation before sending data

#### Example of `autoSync` prop definition

In the following example, the `ShippingMethods` container will not automatically synchronize its state changes with the backend; this means it will not automatically set the shipping method selected on the cart.

```ts
CheckoutProvider.render(ShippingMethods, {
  UIComponentType: 'ToggleButton',
  displayTitle: false,
  autoSync: false,
})($deliveryMethods),
```

---

# LoginForm container

The `LoginForm` container handles user email input and validation within the checkout process.

## LoginForm configurations

The `LoginForm` container provides the following configuration options:



(*) Properties inherited from `TitleProps`

These configuration options are implementing the `LoginFormProps` interface:

### LoginFormProps interface

The `LoginForm` container receives an object as a parameter which implements the `LoginFormProps` interface with the following properties:

```ts
interface ValidationError {
  email: string;
  message: string;
  type: 'missing' | 'invalid';
}

interface CartSyncError {
  email: string;
  error: Error;
}

export interface LoginFormProps extends HTMLAttributes<HTMLFormElement>, TitleProps {
  active?: boolean;
  autoSync?: boolean;
  displayHeadingContent?: boolean;
  onSignInClick?: (email: string) => void;
  onSignOutClick?: () => void;
  onCartSyncError?: (error: CartSyncError) => void;
  onValidationError?: (error: ValidationError) => void;
  slots?: {
    Heading?: SlotProps<{
      authenticated: boolean;
    }>;
  } & TitleProps['slots'];
}
```

- The `displayTitle (*)` property inherits from the `TitleProps` interface to display or hide the title.
- Set the `active` property to _true_ to have the container in reactive mode (it is visible and responds to system events). If it is set to _false_, the container is deactivated (it does not subscribe to system events and is not rendered).
- Set the `autoSync` property to _true_ to automatically synchronize the container state changes with the backend via API calls. If it is set to _false_ the container does not automatically synchronize its state, but still maintains local updates.
- Set the `displayHeadingContent` property to _true_ to display the heading content with the sign-in/sign-out button.
- The `onSignInClick` property is a handler used to perform actions called when the sign-in button is clicked. It accepts an email as an input parameter.
- The `onSignOutClick` property is a handler used to perform actions called when the sign-out button is clicked.
- The `onCartSyncError` property is a handler used to perform actions called when filling in the email address and the setGuestEmailOnCart() API throws an error. It could be used as a callback in the integration layer by the merchant to show errors or perform other actions.
- The `onValidationError` property is a handler used to perform actions called when the email address form field is validated with an error. It could be used as a callback in the integration layer by the merchant to show errors or perform other actions.
- The `slots` property is an object containing the following properties:
  - Use the `Title (*)` property to render a custom title. This property is inherited from `TitleProps` interface.
  - The `Heading` property is a handler used to render a customized heading content based on the authenticated status provided by the context.

## Example 1: Render with title and heading content by default

The following example renders the `LoginForm` container on a checkout page, which includes rendering the [`AuthCombine`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/auth-combine/) container from the user auth drop-in component in a modal for authentication:

```ts




const LOGIN_FORM_NAME = 'login-form';

const $loader = checkoutFragment.querySelector('.checkout__loader');
const $login = checkoutFragment.querySelector('.checkout__login');

let loader;

const displayOverlaySpinner = async () => {
  if (loader) return;

  loader = await UI.render(ProgressSpinner, {
    className: '.checkout__overlay-spinner',
  })($loader);
};

CheckoutProvider.render(LoginForm, {
  name: LOGIN_FORM_NAME,
  onSignInClick: async (initialEmailValue) => {
    const signInForm = document.createElement('div');

    AuthProvider.render(AuthCombine, {
      signInFormConfig: {
        renderSignUpLink: true,
        initialEmailValue,
        onSuccessCallback: () => {
          displayOverlaySpinner();
        },
      },
      signUpFormConfig: {
        slots: {
          ...authPrivacyPolicyConsentSlot,
        },
      },
      resetPasswordFormConfig: {},
    })(signInForm);

    showModal(signInForm);
  },
  onSignOutClick: () => {
    authApi.revokeCustomerToken();
  },
})($login),
```

## Example 2: Render without title and heading content

The following example renders the `LoginForm` container on a checkout page but without displaying both title and heading content:

```ts

const LOGIN_FORM_NAME = 'login-form';

const $login = checkoutFragment.querySelector('.checkout__login');

CheckoutProvider.render(LoginForm, {
  displayTitle: false,
  displayHeadingContent: false,
})($login),
```

## Example 3: Render with customized title and heading content

The following example renders the `LoginForm` container on a checkout page providing customized title and heading content:

```ts

const LOGIN_FORM_NAME = 'login-form';

const $login = checkoutFragment.querySelector('.checkout__login');

CheckoutProvider.render(LoginForm, {
  name: LOGIN_FORM_NAME,
  onSignInClick: async (initialEmailValue) => { . . . },
  onSignOutClick: () => { . . . },
  slots: {
    Title: (ctx) => {
      const content = document.createElement('div');
      content.innerText = 'Custom title';
      ctx.replaceWith(content);
    },
    Heading: (ctx) => {
      const content = document.createElement('div');
      if (ctx.authenticated) {
        // Put here a customized content when the user has signed-in
      } else {
        // Put here a customized content when the user still has not signed-in
      }
      ctx.replaceWith(content);
    },
  },
})($login),
```

## Example 4: Render with callbacks for error handling

The following example renders the `LoginForm` container on a checkout page providing handlers for validation and API errors:

```ts

const LOGIN_FORM_NAME = 'login-form';

const $login = checkoutFragment.querySelector('.checkout__login');

CheckoutProvider.render(LoginForm, {
  name: LOGIN_FORM_NAME,
  onSignInClick: async (initialEmailValue) => { . . . },
  onSignOutClick: () => { . . . },
  onCartSyncError: ({ email, error }) => {
    const loginFormMsg = document.createElement('div');
    loginFormMsg.style.color = 'red';
    loginFormMsg.innerText = `Error saving the email address ${email}: ${error.message}`;
    $login.appendChild(loginFormMsg);
  },
  onValidationError: ({ email, message, type }) => {
    const loginFormMsg = document.createElement('div');
    loginFormMsg.style.color = 'red';
    loginFormMsg.innerText = `Validation error (${type}) introducing the email address ${email}: ${message}`;
    $login.appendChild(loginFormMsg);
  },
})($login),
```

---

# MergedCartBanner container

Use the `MergedCartBanner` container to display a notification banner when items from an old cart are merged into the current cart.

When a customer signs in, if they had items in a previous cart, a banner will notify them that the items from their previous cart have been merged with the current cart. You can apply styles to the banner by passing a CSS `className` prop to the container.

## MergedCartBanner configurations

The `MergedCartBanner` container provides the following configuration options:



These configuration options are implementing the `MergedCartBannerProps` interface:

### MergedCartBannerProps interface

The `MergedCartBanner` container receives an object as a parameter which implements the `MergedCartBannerProps` interface with the following properties:

```ts
export interface MergedCartBannerProps extends AlertBannerProps {
  active?: boolean;
}
```

- Set the `active` property to _true_ to have the container in reactive mode (it is visible and responds to system events). If it is set to _false_, the container is deactivated (it does not subscribe to system events and is not rendered).

## Example

The following example renders the `MergedCartBanner` container with a custom class name:

```ts

const $mergedCartBanner = checkoutFragment.querySelector(
  '.checkout__merged-cart-banner'
);

CheckoutProvider.render(MergedCartBanner, {
  className: 'checkout__merged-cart-banner--custom',
})($mergedCartBanner);
```

---

# OutOfStock container

The `OutOfStock` container is designed to handle and display items in the shopping cart that are out of stock or have insufficient quantity. You can configure it to handle the removal of out-of-stock items and provide a route to the cart page.

## OutOfStock configurations

The `OutOfStock` container provides the following configuration options:



These configuration options implement the `OutOfStockProps` interface:

### OutOfStockProps interface

The `OutOfStock` container receives an object as a parameter which implements the `OutOfStockProps` interface with the following properties:

```ts
export type UpdateProductsFromCart = Array<{
  uid: string;
  quantity: number;
}>;

export interface OutOfStockProps extends Omit<HTMLAttributes<HTMLDivElement>, 'icon'> {
  active?: boolean;
  onCartProductsUpdate?: (items: UpdateProductsFromCart) => void;
  routeCart?: () => string;
}
```

- Set the `active` property to _true_ to have the container in reactive mode (it is visible and responds to system events). If it is set to _false_, the container is deactivated (it does not subscribe to system events and is not rendered).
- The `onCartProductsUpdate` property is a handler used to perform actions called when there are out-of-stock items. It takes the list of items (array with pairs of _uid_ and _quantity_ values) as an input parameter.
- The `routeCart` property is a handler used to indicate the route to the cart page.

## Example

The following example renders the `OutOfStock` container to handle and display out-of-stock items in the cart:

```ts

const $outOfStock = checkoutFragment.querySelector('.checkout__out-of-stock');

CheckoutProvider.render(OutOfStock, {
  routeCart: () => '/cart',
  onCartProductsUpdate: (items) => {
    cartApi.updateProductsFromCart(items).catch(console.error);
  },
})($outOfStock),
```

---

# PaymentMethods container

Use the `PaymentMethods` container to manage and display the available payment methods during the checkout process. Configuration options:
- Set the payment method automatically or manually (starting without a selected payment method)
- Show an icon beside of the label
- Display or hide the label
- Provide a specific handler to render the payment method

## PaymentMethods configurations

The `PaymentMethods` container provides the following configuration options:



(*) Properties inherited from `TitleProps`

These configuration options are implementing the `PaymentMethodsProps` interface:

### PaymentMethodsProps interface

The `PaymentMethods` container receives an object as parameter which implements the `PaymentMethodsProps` interface with the following properties:

```ts
export type UIComponentType = 'ToggleButton' | 'RadioButton';

interface CartSyncError {
  method: PaymentMethod;
  error: Error;
}

export interface PaymentMethodsProps extends HTMLAttributes<HTMLDivElement>, TitleProps {
  active?: boolean;
  autoSync?: boolean;
  onCartSyncError?: (error: CartSyncError) => void;
  onSelectionChange?: (method: PaymentMethod) => void;
  slots?: {
    Methods?: PaymentMethodsSlot;
  } & TitleProps['slots'];
  UIComponentType?: UIComponentType;
}
```

- The `displayTitle (*)` property is inherited from the `TitleProps` interface. It is used to determine whether to display the title.
- Set the `active` property to _true_ to have the container in reactive mode (it is visible and responds to system events). If it is set to _false_, the container is deactivated (it does not subscribe to system events and is not rendered).
- Set the `autoSync` property to _true_ to automatically synchronize the container state changes with the backend via API calls. If it is set to _false_ the container does not automatically synchronize its state, but still maintains local updates.
- The `onCartSyncError` property is a handler used to perform actions called when a payment method is selected and the setPaymentMethodOnCart() API throws an error. It could be used in the integration layer by the merchant to show errors.
- The `onSelectionChange` property is a handler used to perform actions called when a payment method is selected.
- The `UIComponentType` property is a string containing the name of the UI component type to be used as a selector for each payment method. The available UI components are: `ToggleButton` or `RadioButton`.
- The `slots` property is an object containing the following properties:
  - Use the `Title (*)` property to render a custom title. This property is inherited from `TitleProps` interface.
  - The `Methods` property is an object which implements the `PaymentMethodsSlot` interface:

  ```ts
  export interface PaymentMethodsSlot {
    [code: string]: PaymentMethodConfig;
  }
  ```

  It consists on a list of payment method codes providing a set of configurations to customize the payment method.
  Each payment method will have its own set of configurations implementing the `PaymentMethodConfig` interface:

  ```ts
  export type SlotProps<T = any> = (
    ctx: T & DefaultSlotContext<T>,
    element: HTMLDivElement | null
  ) => Promise<void> | void;

  export interface PaymentMethodRenderCtx {
    cartId: string;
    replaceHTML: (domElement: HTMLElement) => void;
  }

  export interface PaymentMethodConfig {
    displayLabel?: boolean;
    enabled?: boolean;
    icon?: string;
    autoSync?: boolean;
    render?: SlotProps<PaymentMethodRenderCtx>;
  }
  ```
  - The `PaymentMethodConfig` interface is composed by:
    - The `displayLabel` configuration hides the payment method label (for instance, if you only want to display the icon).
    - The `enabled` configuration allows merchants to individually hide payment methods filtering them from the available payment methods list (for instance, it is useful when a payment provider has enabled a payment method in the backend, which is configured with more than one payment option and you don't want to display one of them).
    - The `icon` configuration specifies the name of the icon to be shown beside of the label. The icon name must exist within the list of available icons defined on [Elsie](https://elsie.dev/docs/?path=/story/components-icon--all-icons).
    - The `autoSync` configuration sets the payment method automatically when it is selected. Only if a payment method is specifically set to _false_, the container will not automatically set the payment method to the cart when selected (for instance, if a payment method needs more information obtained during the place order action). This specific configuration has more priority than the generic one declared on the `PaymentMethodsProps`. In case this configuration is not provided, then it will be used the generic `autoSync` property.
    - The `render` configuration is a handler used to render and configure the payment method.

## Example 1: Render the available payment methods with callbacks

The following example renders the `PaymentMethods` container on a checkout page, displaying the available payment methods in the element with the class `checkout__payment-methods`. It includes configurations to show a message if the chosen payment method is Credit Card, and show an error message in case there was an issue saving the selected payment method to the backend.

```ts
// Checkout Dropin

// Payment Services Dropin

const $paymentMethods = checkoutFragment.querySelector(
  '.checkout__payment-methods',
);

CheckoutProvider.render(PaymentMethods, {
  onCartSyncError: ({ method, error }) => {
    const paymentMsg = document.createElement('div');
    paymentMsg.style.color = 'red';
    paymentMsg.innerText = `Error selecting the Payment Method ${method.code} ${method.title}: ${error.message}`;
    $paymentMethods.appendChild(paymentMsg);
  },
  onSelectionChange: (method) => {
    if (method.code === PaymentMethodCode.CREDIT_CARD) {
      const paymentMsg = document.createElement('div');
      paymentMsg.innerText = 'Payment method not available for the country selected';
      $paymentMethods.appendChild(paymentMsg);
    }
  },
})($paymentMethods),
```

## Example 2: Render with the `displayLabel` and `icon` configurations

The following example renders the `PaymentMethods` container on a checkout page, displaying the available payment methods in the element with the class `checkout__payment-methods`, providing an icon for `checkmo` and `banktransfer`, and hiding the label for `banktransfer`.

```ts
// Checkout Dropin

const $paymentMethods = checkoutFragment.querySelector(
  '.checkout__payment-methods',
);

CheckoutProvider.render(PaymentMethods, {
  slots: {
    Methods: {
      checkmo: {
        icon: 'Wallet',
        render: (ctx) => {
          const $content = document.createElement('div');

          $content.innerText = 'Pay later with Checkmo config handler';
          ctx.replaceHTML($content);
        },
      },
      banktransfer: {
        displayLabel: false,
        icon: 'Card',
      },
    },
  },
})($paymentMethods),

```

## Example 3: Render with the `autoSync` and `render` configurations

The following example renders the `PaymentMethods` container on a checkout page, displaying the available payment methods in the element with the class `checkout__payment-methods`, providing a specific handler for `braintree` payment method indicating it cannot be set to the cart when selected.

```ts
// Checkout Dropin


const $paymentMethods = checkoutFragment.querySelector(
  '.checkout__payment-methods',
);

let braintreeInstance;

CheckoutProvider.render(PaymentMethods, {
  slots: {
    Methods: {
      braintree: {
        autoSync: false,
        render: async (ctx) => {
          const container = document.createElement('div');

          window.braintree.dropin.create({
            authorization: 'sandbox_cstz6tw9_sbj9bzvx2ngq77n4',
            container,
          }, (err, dropinInstance) => {
            if (err) {
              console.error(err);
            }

            braintreeInstance = dropinInstance;
          });

          ctx.replaceHTML(container);
        },
      },
    },
  },
})($paymentMethods),

```

## Example 4: Render with the `enabled` configurations

The following example renders the `PaymentMethods` container on a checkout page, displaying the available payment methods in the element with the class `checkout__payment-methods`, providing a specific handler for the credit card payment option but disabling the rest of payment options from `PaymentServices` payment method.

```ts
// Checkout Dropin

// Payment Services Dropin

const $paymentMethods = checkoutFragment.querySelector(
  '.checkout__payment-methods',
);

// Container and component references
const creditCardFormRef = { current: null };

// Adobe Commerce GraphQL endpoint
const commerceCoreEndpoint = await getConfigValue('commerce-core-endpoint');

CheckoutProvider.render(PaymentMethods, {
  slots: {
    Methods: {
      [PaymentMethodCode.CREDIT_CARD]: {
        render: (ctx) => {
          const $content = document.createElement('div');

          PaymentServicesProvider.render(CreditCard, {
            apiUrl: commerceCoreEndpoint,
            getCustomerToken: getUserTokenCookie,
            getCartId: () => ctx.cartId,
            creditCardFormRef,
          })($content);

          ctx.replaceHTML($content);
        },
      },
      [PaymentMethodCode.SMART_BUTTONS]: {
        enabled: false,
      },
      [PaymentMethodCode.APPLE_PAY]: {
        enabled: false,
      },
      [PaymentMethodCode.GOOGLE_PAY]: {
        enabled: false,
      },
      [PaymentMethodCode.VAULT]: {
        enabled: false,
      },
    },
  },
})($paymentMethods),
```

## Example 5: Render with custom title and radio button as selector

The following example renders the `PaymentMethods` container on a checkout page to display a custom title and radio buttons instead of toggle buttons for selecting the payment options.

```ts
// Checkout Dropin

const $paymentMethods = checkoutFragment.querySelector(
  '.checkout__payment-methods',
);

CheckoutProvider.render(PaymentMethods, {
  UIComponentType: 'RadioButton',
  displayTitle: true,
  slots: {
    Title: (ctx) => {
      const content = document.createElement('div');
      content.innerText = 'Custom title';
      ctx.replaceWith(content);
    },
  },
})($paymentMethods),

```

---

# PlaceOrder container

The `PlaceOrder` container is designed to handle the final step in the checkout process, where the user confirms and places their order. You can configure it to disable the button, perform some validations before submitting the form, handle the place order action, and manage the content slot for the place order button.

## PlaceOrder configurations

The `PlaceOrder` container provides the following configuration options:



These configuration options are implementing the `PlaceOrderProps` interface:

### PlaceOrderProps interface

The `PlaceOrder` container receives an object as parameter which implements the `PlaceOrderProps` interface with the following properties:

```ts
export interface PlaceOrderProps extends HTMLAttributes<HTMLDivElement> {
  active?: boolean;
  disabled?: boolean;
  handleValidation?: () => boolean;
  handlePlaceOrder: (ctx: HandlePlaceOrderContext) => Promise<void>;
  slots?: {
    Content?: SlotProps<ContentSlotContext>;
  };
}
```

- Set the `active` property to _true_ to have the container in reactive mode (it is visible and responds to system events). If it is set to _false_, the container is deactivated (it does not subscribe to system events and is not rendered).
- The `disabled` property set to _true_ forces the Place Order button to be disabled.
- The `handleValidation` property is a handler used to perform some validation checks before submitting the checkout forms and placing the order.
- The `handlePlaceOrder` property is a handler used to perform some actions related to the order placement process. It is executed when the Place Order button is clicked and if the `handleValidation` returns _true_ (in case it is provided, otherwise it will be executed without validation checks).
  
  The asynchronous function provided accepts a context as parameter which implements the `HandlePlaceOrderContext` interface:

  ```ts
  export interface HandlePlaceOrderContext {
    code: string;
    cartId: string;
  }
  ```

- The `slots` property is an object containing the following properties:
  - The `Content` property is a handler used to render the PlaceOrder container content based on the selected payment method code:

  ```ts
  export type SlotProps<T = any> = (
    ctx: T & DefaultSlotContext<T>,
    element: HTMLDivElement | null
  ) => Promise<void> | void;

  export interface ContentSlotContext {
    code: string;
  }
  ```

## Example 1: Render performing validations and a handler for order placement

The following example renders the `PlaceOrder` container on a checkout page using the `PaymentServices` drop-in component as a payment method. It includes functionality to validate login, shipping, billing, and terms & conditions forms before placing an order. If the validation passes, it attempts to place the order and handles any errors.

```ts
// Checkout Dropin

// Order Dropin Modules

// Payment Services Dropin


const LOGIN_FORM_NAME = 'login-form';
const SHIPPING_FORM_NAME = 'selectedShippingAddress';
const BILLING_FORM_NAME = 'selectedBillingAddress';
const TERMS_AND_CONDITIONS_FORM_NAME = 'checkout-terms-and-conditions__form';

const $placeOrder = checkoutFragment.querySelector('.checkout__place-order');

const shippingFormRef = { current: null };
const billingFormRef = { current: null };
const creditCardFormRef = { current: null };

CheckoutProvider.render(PlaceOrder, {
  handleValidation: () => {
    let success = true;
    const { forms } = document;

    const loginForm = forms[LOGIN_FORM_NAME];

    if (loginForm) {
      success = loginForm.checkValidity();
      if (!success) scrollToElement($login);
    }

    const shippingForm = forms[SHIPPING_FORM_NAME];

    if (
      success
      && shippingFormRef.current
      && shippingForm
      && shippingForm.checkVisibility()
    ) {
      success = shippingFormRef.current.handleValidationSubmit(false);
    }

    const billingForm = forms[BILLING_FORM_NAME];

    if (
      success
      && billingFormRef.current
      && billingForm
      && billingForm.checkVisibility()
    ) {
      success = billingFormRef.current.handleValidationSubmit(false);
    }

    const termsAndConditionsForm = forms[TERMS_AND_CONDITIONS_FORM_NAME];

    if (success && termsAndConditionsForm) {
      success = termsAndConditionsForm.checkValidity();
      if (!success) scrollToElement($termsAndConditions);
    }

    return success;
  },
  handlePlaceOrder: async ({ cartId, code }) => {
    await displayOverlaySpinner();
    try {
      // Payment Services credit card
      if (code === PaymentMethodCode.CREDIT_CARD) {
        if (!creditCardFormRef.current) {
          console.error('Credit card form not rendered.');
          return;
        }
        if (!creditCardFormRef.current.validate()) {
          // Credit card form invalid; abort order placement
          return;
        }
        // Submit Payment Services credit card form
        await creditCardFormRef.current.submit();
      }
      // Place order
      await orderApi.placeOrder(cartId);
    } catch (error) {
      console.error(error);
      throw error;
    } finally {
      removeOverlaySpinner();
    }
  },
})($placeOrder),
```

## Example 2: Render providing explicit content for the button

The following example renders the `PlaceOrder` container on a checkout page providing different text for the Place Order button depending on the selected payment method.

```ts
// Checkout Dropin

// Order Dropin Modules

const $placeOrder = checkoutFragment.querySelector('.checkout__place-order');

CheckoutProvider.render(PlaceOrder, {
  handlePlaceOrder: async ({ cartId }) => {
    orderApi.placeOrder(cartId).catch(console.error);
  },
  slots: {
    Content: (ctx) => {
      const content = document.createElement('span');
      ctx.appendChild(content);

      function setContent(currentCtx) {
        switch (currentCtx.code) {
          case 'checkmo': {
            content.textContent = 'Pay Now';
            break;
          }
          case 'banktransfer': {
            content.textContent = 'Make a transfer';
            break;
          }
          default: {
            content.textContent = currentCtx.dictionary.Checkout.PlaceOrder.button;
          }
        }
      }

      setContent(ctx);
      ctx.onChange(setContent);
    },
  },
})($placeOrder),
```

---

# ServerError container

The `ServerError` container is designed to handle and display server error messages during the checkout process. You can configure it to display an error message and handle click events.

## ServerError configurations

The `ServerError` container provides the following configuration options:



These configuration options are implementing the `ServerErrorProps` interface:

### ServerErrorProps interface

The `ServerError` container receives an object as parameter which implements the `ServerErrorProps` interface with the following properties:

```ts
export interface ServerErrorProps {
  active?: boolean;
  autoScroll?: boolean;
  onRetry?: () => void;
  onServerError?: (error: string) => void;
}
```

- Set the `active` property to _true_ to have the container in reactive mode (it is visible and responds to system events). If it is set to _false_, the container is deactivated (it does not subscribe to system events and is not rendered).
- The `autoScroll` property is a boolean to indicate if the page should scroll to the element containing the error message and put the focus on it to be visible to the user.
- The `onRetry` property is a handler used to perform actions called when the retry button is clicked.
- The `onServerError` property is a handler used to perform actions called when there is a new error message.

## Example

The following example renders the `ServerError` container on a checkout page. It provides functionality to handle retry actions by removing an error class from the content element and to handle server errors by adding an error class to the content element. The page will scroll to the element containing the error message focusing on it.

```ts

const $serverError = checkoutFragment.querySelector(
  '.checkout__server-error'
);

CheckoutProvider.render(ServerError, {
  autoScroll: true,
  onRetry: () => {
    $content.classList.remove('checkout__content--error');
  },
  onServerError: () => {
    $content.classList.add('checkout__content--error');
  },
})($serverError),
```

---

# ShippingMethods container

The `ShippingMethods` container is designed to manage and display the selection of available shipping methods during the checkout process. You can configure it to handle the selection of shipping methods, display the available shipping methods, and manage the main slot for the shipping methods.

This container includes internal business logic to hide itself if the cart is empty or virtual.

Finally, if an error is thrown selecting a shipping method, a callback function is provided in order to handle that error in the integration layer; a rollback will be performed to the last valid shipping method selected by the user.

## ShippingMethods configurations

The `ShippingMethods` container provides the following configuration options:



(*) Properties inherited from `TitleProps`

These configuration options are implementing the `ShippingMethodsProps` interface:

### ShippingMethodsProps interface

The `ShippingMethods` container receives an object as a parameter which implements the `ShippingMethodsProps` interface with the following properties:

```ts
interface CartSyncError {
  method: ShippingMethod;
  error: Error;
}

export interface ShippingMethodsProps extends HTMLAttributes<HTMLDivElement>, TitleProps {
  active?: boolean;
  autoSync?: boolean;
  onCartSyncError?: (error: CartSyncError) => void;
  onSelectionChange?: (method: ShippingMethod) => void;
  UIComponentType?: UIComponentType;
}
```

- The `displayTitle (*)` property is inherited from the `TitleProps` interface. It is used to determine whether to display the title.
- Set the `active` property to _true_ to have the container in reactive mode (it is visible and responds to system events). If it is set to _false_, the container is deactivated (it does not subscribe to system events and is not rendered).
- Set the `autoSync` property to _true_ to automatically synchronize the container state changes with the backend via API calls. If it is set to _false_ the container does not automatically synchronize its state, but still maintains local updates.
- The `onCartSyncError` property is a handler used to perform actions called when a shipping method is selected and the setShippingMethodsOnCart() API throws an error. It could be used in the integration layer by the merchant to show errors.
-The `onSelectionChange` property is a handler used to perform actions called when a shipping method is selected.
- The `UIComponentType` property is a string containing the name of the UI component type to be used as a selector for each shipping method. The available UI components are: `ToggleButton` or `RadioButton`.
- The `slots (*)` property is inherited from the `TitleProps` interface. It is an object that contains the following properties:
  - Use the `Title (*)` property to render a custom title. This property is inherited from `TitleProps` interface.

## Example

The following example renders the `ShippingMethods` container on a checkout page. It includes configurations to hide the title, show a message if the chosen shipping method is `Best Way` (Table Rate), and show an error message in case there was an issue saving the selected shipping method to the backend.

```ts

const $delivery = checkoutFragment.querySelector('.checkout__delivery');

CheckoutProvider.render(ShippingMethods, {
  displayTitle: false,
  onCartSyncError: ({ method, error }) => {
    const shippingMsg = document.createElement('div');
    shippingMsg.style.color = 'red';
    shippingMsg.innerText = `Error selecting the Shipping Method ${method.code} for the carrier ${method.carrier.title}: ${error.message}`;
    $delivery.appendChild(shippingMsg);
  },
  onSelectionChange: (method) => {
    if (method.carrier.code === 'tablerate' && method.code === 'bestway') {
      const shippingMsg = document.createElement('div');
      shippingMsg.innerText = 'Shipping method not available for Canary Islands';
      $delivery.appendChild(shippingMsg);
    }
  },
})($delivery),
```

---

# TermsAndConditions container

The `TermsAndConditions` container displays a checkbox that users must select to agree to the terms and conditions of the sale before confirming their purchase.
During the checkout process, users must check all required agreements before placing an order. If an agreement is unchecked, a validation error appears when the user clicks the **Place Order** button.

> **Note:** <li>The `TermsAndConditions` container requires a store configuration to be enabled; so it won't be displayed if the component is not properly configured.</li>

Visit the [Terms & Conditions setup](https://experienceleague.adobe.com/developer/commerce/storefront/merchants/get-started/terms-and-conditions/) documentation for more information on how to enable the Terms and Conditions feature.

> **Note:** In order to use the `TermsAndConditions` container, the **Storefront Compatibility Package (SCP) 4.7.1-beta8** (or higher) module must be installed.
  The **SCP 4.7.1-beta8** added support for retrieving Terms and Conditions configuration setting via the _StoreConfig_ GraphQL query. This setting is required by `TermsAndConditions` container to allow frontend applications to dynamically enable and configure agreements by store-view in checkout page.

## TermsAndConditions configurations

The `TermsAndConditions` container provides the following configuration options:



These configuration options implement the `TermsAndConditionsProps` interface:

### TermsAndConditionsProps interface

The `TermsAndConditions` container receives an object as a parameter which implements the `TermsAndConditionsProps` interface with the following properties:

```ts
export interface TermsAndConditionsProps {
  active?: boolean;
  slots?: {
    Agreements?: SlotProps<{
      appendAgreement: SlotMethod<{
        name: string;
        mode: AgreementMode;
        text?: string;
        translationId?: string;
      }>;
    }>;
  };
}
```

- Set the `active` property to _true_ to have the container in reactive mode (it is visible and responds to system events). If it is set to _false_, the container is deactivated (it does not subscribe to system events and is not rendered).
- The `slots` property is an object containing the following properties:
  - The `Agreements` property is a handler used to render and configure the list of agreements. It provides a context by including the method `appendAgreement()` to add a new agreement:

  ```ts
  export type SlotProps<T = any> = (
    ctx: T & DefaultSlotContext<T>,
    element: HTMLDivElement | null
  ) => Promise<void> | void;

  export type SlotMethod<P = any> = (
    callback: (next: unknown, state: State) => P
  ) => void;

  export enum AgreementMode {
    MANUAL = 'manual',
    AUTO = 'auto',
  }

  . . .
    Agreements?: SlotProps<{
      appendAgreement: SlotMethod<{
        name: string;
        mode: AgreementMode;
        text?: string;
        translationId?: string;
      }>;
    }>;
. . .
```

The `appendAgreement` configuration is a callback function which accepts the following attributes to configure an agreement:

  - **`name`**
    The agreement identifier
  - **`mode`**
    Specifies the mode how the checkbox should appear:
    - 'manual': the user is required to manually check and accept the conditions to place an order
    - 'auto': the checkbox will appear checked by default, conditions are automatically accepted upon checkout
  - **`text`**
    Optional attribute that contains directly the text to show, and it accepts HTML with links to a specific page in EDS. In case this attribute is not provided, the `translationId` must to. Finally, if both `text` and `translationId` are provided, the `text` has more preference and its content will be shown
  - **`translationId`**
- This attribute references the translation label that contains the checkbox text. It first looks in the placeholders/checkout.json file for this label identifier, otherwise it looks up the entry in the dictionary. This attribute must be provided if it is not. As a reminder, if both `text` and `translationId` are provided, the `text` has more preference and its content will be shown.

## Example 1: Render a custom agreement

The following example renders the `TermsAndConditions` container on the checkout page, displaying a custom agreement that directly includes the label to show along with the link to the EDS page, within the element having the class `.checkout__terms-and-conditions`:

```ts
// Checkout Dropin

const $termsAndConditions = checkoutFragment.querySelector(
  '.checkout__terms-and-conditions',
);

CheckoutProvider.render(TermsAndConditions, {
  slots: {
    Agreements: (ctx) => {
      ctx.appendAgreement(() => ({
        name: 'custom',
        mode: 'auto',
        text: 'Custom terms and conditions Terms & Conditions.',
      }));
    },
  },
})($termsAndConditions),
```

## Example 2: Render three different agreements using the translations configured in EDS

The following example renders the `TermsAndConditions` container on the checkout page. The container displays three different agreements using the labels from the translations in the **`placeholders`** sheet, within the element with the class `.checkout__terms-and-conditions`:

```ts
// Checkout Dropin

const $termsAndConditions = checkoutFragment.querySelector(
  '.checkout__terms-and-conditions',
);

CheckoutProvider.render(TermsAndConditions, {
  slots: {
    Agreements: (ctx) => {
      ctx.appendAgreement(() => ({
        name: 'default',
        mode: 'auto',
        translationId: 'Checkout.TermsAndConditions.label',
      }));
      ctx.appendAgreement(() => ({
        name: 'terms',
        mode: 'manual',
        translationId: 'Checkout.TermsAndConditions.terms_label',
      }));
      ctx.appendAgreement(() => ({
        name: 'privacy',
        mode: 'auto',
        translationId: 'Checkout.TermsAndConditions.privacy_label',
      }));
    },
  },
})($termsAndConditions),
```

## Example 3: Render the available agreements configured in the Admin Panel

The following example renders the `TermsAndConditions` container on a checkout page, displaying the available agreements configured in the Admin Panel retrieved using the `getCheckoutAgreements()` API function, in the element with the class `.checkout__terms-and-conditions`:

```ts
// Checkout Dropin

const $termsAndConditions = checkoutFragment.querySelector(
  '.checkout__terms-and-conditions',
);

CheckoutProvider.render(TermsAndConditions, {
  slots: {
    Agreements: async (ctx) => {
      const agreements = await checkoutApi.getCheckoutAgreements();

      agreements.forEach((agreement) => {
        ctx.appendAgreement(() => ({
          name: agreement.name,
          mode: agreement.mode,
          text: agreement.text,
        }));
      });
    },
  },
})($termsAndConditions),
```

---

# Checkout dictionary

The default checkout dictionary file (`i18n/en_US.json`) contains the default values for all labels and text common to the checkout drop-in component.

## Default keys and values

---

# Error handling

Errors that occur during the checkout process must be caught and logged with clear context for quick resolution. This prevents unnecessary error propagation and provides better user experience and debugging capabilities. The checkout drop-in component must implement an error handling mechanism to improve observability and debugging capabilities.

It is critical to resolve errors promptly to avoid inconsistent states and clearly inform users about what occurred. This prevents data inconsistencies between the local application and the backend, which could result in incorrect orders.

## Generic strategy

Most issues arise from API call errors. The system must focus on how these errors propagate from API calls to the user interface and how they are presented to users in a friendly manner across different scenarios. Each container requires a centralized error handling system that captures errors as they occur, enabling control over error management and decision-making about subsequent actions.

## "Optimistic" UI updates with rollback pattern

The system implements optimistic UI updates with a rollback mechanism. This technique improves user experience by making the application feel more responsive to user interactions.

In an optimistic update, the UI behaves as though a change was successfully completed before receiving confirmation from the backend that it actually occurred. The system optimistically assumes it will eventually receive confirmation rather than an error. This approach allows for a more responsive user experience.

When a user performs an action that changes the state, the system immediately sends the information to the backend and optimistically updates the user interface (UI) to reflect the change. This process is called "optimistic" because the system updates the UI with the expectation that the backend will accept the state change. If the system waited for backend confirmation before updating the UI, the delay would negatively impact the user experience.

If the backend returns an error, the system performs a rollback to revert to the previous state (when possible) and displays an error message such as an inline alert. Additionally, the containers provide callback functions that merchants can use in the integration layer to display custom error messages.

---

# Event handling

The checkout drop-in component implements an event-driven architecture that uses the `@adobe-commerce/event-bus` package to facilitate communication between components. This event system enables containers to respond to application state changes, maintain loose coupling between components, and keep their state synchronized with the cart.

## Event system architecture

The system uses a publish-subscribe pattern where containers can:

1. Subscribe to specific events using `events.on()`
2. Emit events using `events.emit()`
3. Unsubscribe using `subscription.off()`

## Events declaration

The following code snippet shows the contracts that define the relationship between each event and its payload:

```js title='event-bus.d.ts'


declare module '@adobe-commerce/event-bus' {
  interface Events {
    'cart/initialized': CartModel | null;
    'cart/updated': CartModel | null;
    'cart/reset': void;
    'cart/merged': { oldCartItems: any[] };
    'checkout/initialized': CheckoutData | null;
    'checkout/updated': CheckoutData | null;
    'checkout/values': ValuesModel;
    'shipping/estimate': ShippingEstimate;
    authenticated: boolean;
    error: { source: string; type: string; error: Error };
  }

  interface Cart extends CartModel {}
}
```

## Event subscription

If a component wants to listen for an event fired in another component, the component must subscribe to that event.

### Subscription configuration

To subscribe to an event, you must provide the following information:

1. The name of the event.
2. The event handler, which is a callback function to be executed when a new event is fired (the payload is passed as a parameter).
3. Event subscriptions can include an additional configuration parameter:
    - `eager: true`: The handler executes immediately if the event has been emitted previously.
    - `eager: false`: The handler only responds to future emissions of the event.

```js
const subscription = events.on('event-name', handler, { eager: true/false });
```

### Events subscribed by containers

The following list shows the events subscribed by the checkout drop-in component containers:

#### (i) External

When the event is fired by external components:

- `authenticated`: Indicates that a user has authenticated.
- `cart/initialized`: Indicates that a new cart has been created and initialized.
- `cart/reset`: Indicates that the order has been placed and the cart is not active any more.
- `cart/updated`: Indicates that the cart data has been added or updated.
- `cart/merged`: Indicates that a guest cart (created during the anonymous checkout) has been merged with a customer cart (recovered from a previous checkout process).
- `cart/data`: Provides cart data.
- `locale`: Indicates that the locale has been changed.

#### (ii) Internal

When the event is fired by internal checkout drop-in components:

- `checkout/initialized`: Indicates that the checkout drop-in has been initialized with cart data.
- `checkout/updated`: Indicates that the checkout data has been added or updated.
- `shipping/estimate`: Provides shipping estimate based on shipping method selected within a shipping address.

### Example

Listen to the checkout initialization event:

```js
events.on('checkout/initialized', (data) => {
  // Handle checkout data
});
```

## Event emission

Each component can emit an event if it wants to share information with other components or drop-ins.

### Emission configuration

To emit an event, you must provide the following information:

1. The name of the event
2. The payload containing the data to be shared

```js
events.emit('event-name', payload);
```

### Events emitted by containers

The following list shows the events emitted by the checkout drop-in component containers:

- `checkout/initialized`: Indicates that the checkout drop-in has been initialized with cart data.
- `checkout/updated`: Indicates that the checkout data has been added or updated.
- `checkout/values`: Provides the local state values.
- `shipping/estimate`: Provides shipping estimate based on shipping method selected within a shipping address.
- `error`: Indicates that the system has received a network error type.

### Example

Emit the checkout values event:

```js
events.emit('checkout/values', data);
```

---

# Checkout Data & Events

{/*
  âš ï¸ TEMPLATE USAGE GUIDE âš ï¸
  
  This template is used by scripts/generate-events-docs.js to generate event documentation.
  
  WHAT THE SCRIPT USES FROM THIS TEMPLATE:
  - Section headings and descriptive text (used as-is)
  - Import statements
  - The REPEAT_FOR_EACH_EVENT block (replicated for each event)
  - Placeholders: Checkout, Checkout, EVENT_NAME, etc.
  
  WHAT THE SCRIPT GENERATES INDEPENDENTLY:
  - Table contents between START/END markers (example rows are for reference only)
  - Event-specific data (names, descriptions, payloads from source repos)
  
  TO CHANGE:
  - Section text/descriptions â†’ Edit this template
  - Table structure (columns, links, formatting) â†’ Edit scripts/generate-events-docs.js
  - Both template and script must be kept in sync for table structure changes
*/}


The **Checkout** drop-in uses the [event bus](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/) to emit and listen to events for communication between drop-ins and external integrations. For common events shared across multiple drop-ins (such as `locale`, `error`, `authenticated`, etc.), see the [Common events reference](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/#common-events-reference).


<strong>Version: 2.1.0</strong>


> **Note:** **New to drop-in events?** Learn about the [event system architecture](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/), including the publish-subscribe pattern, subscription configuration, and best practices for event handling.

## Events reference

{/* EVENTS_TABLE_START */}


| Event | Direction | Description |
|-------|-----------|-------------|
| [checkout/values](#checkoutvalues-emits) | Emits | Emitted when form or configuration values change |
| [cart/initialized](#cartinitialized-listens) | Listens | Fired by Cart (`cart`) when the component completes initialization |
| [cart/merged](#cartmerged-listens) | Listens | Fired by Cart (`cart`) when data is merged |
| [cart/reset](#cartreset-listens) | Listens | Fired by Cart (`cart`) when the component state is reset |
| [cart/data](#cartdata-emits-and-listens) | Emits and listens | Triggered when data is available or changes |
| [checkout/error](#checkouterror-emits-and-listens) | Emits and listens | Triggered when an error occurs |
| [checkout/initialized](#checkoutinitialized-emits-and-listens) | Emits and listens | Triggered when the component completes initialization |
| [checkout/updated](#checkoutupdated-emits-and-listens) | Emits and listens | Triggered when the component state is updated |
| [shipping/estimate](#shippingestimate-emits-and-listens) | Emits and listens | Triggered when an estimate is calculated |


{/* EVENTS_TABLE_END */}

## Event details

The following sections provide detailed information about each event, including its direction, data payload structure, and usage examples.


### `cart/data` (emits and listens)

Triggered when data is available or changes

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const cartDataListener = events.on('cart/data', (data) => {
  console.log('cart/data event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
cartDataListener.off();
```

### `cart/initialized` (listens)

Fired by Cart (`cart`) when the component completes initialization

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const cartInitializedListener = events.on('cart/initialized', (data) => {
  console.log('cart/initialized event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
cartInitializedListener.off();
```

### `cart/merged` (listens)

Fired by Cart (`cart`) when data is merged

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const cartMergedListener = events.on('cart/merged', (data) => {
  console.log('cart/merged event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
cartMergedListener.off();
```

### `cart/reset` (listens)

Fired by Cart (`cart`) when the component state is reset

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const cartResetListener = events.on('cart/reset', (data) => {
  console.log('cart/reset event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
cartResetListener.off();
```

### `checkout/error` (emits and listens)

Triggered when an error occurs

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const checkoutErrorListener = events.on('checkout/error', (data) => {
  console.log('checkout/error event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
checkoutErrorListener.off();
```

### `checkout/initialized` (emits and listens)

Triggered when the component completes initialization

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const checkoutInitializedListener = events.on('checkout/initialized', (data) => {
  console.log('checkout/initialized event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
checkoutInitializedListener.off();
```

### `checkout/updated` (emits and listens)

Triggered when the component state is updated

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const checkoutUpdatedListener = events.on('checkout/updated', (data) => {
  console.log('checkout/updated event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
checkoutUpdatedListener.off();
```

### `checkout/values` (emits)

Emitted when form or configuration values change

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const checkoutValuesListener = events.on('checkout/values', (data) => {
  console.log('checkout/values event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
checkoutValuesListener.off();
```

### `shipping/estimate` (emits and listens)

Triggered when an estimate is calculated

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const shippingEstimateListener = events.on('shipping/estimate', (data) => {
  console.log('shipping/estimate event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
shippingEstimateListener.off();
```

---

# Extending the checkout drop-in component

The checkout drop-in component follows the Adobe Commerce out-of-process extensibility (OOPE) pattern, which requires components to be flexible and extensible. When the checkout drop-in component lacks a specific feature, it provides mechanisms that allow developers to easily expand and customize its functionality.

## GraphQL API

To extend the data payload of the drop-in, developers must use the GraphQL Extensibility API. This API allows developers to extend existing GraphQL operations to meet additional data requirements without increasing code complexity or negatively impacting performance. The API provides a flexible and efficient way to customize GraphQL fragments by integrating build-time modifications into the storefront's development pipeline.

GraphQL fragments are reusable pieces of GraphQL that developers can use to extend or customize the API for a drop-in component. Drop-in components expose the list of fragments that can be extended in the `fragments.ts` file. If the drop-in component does not expose these fragments, the build process fails when you install the application because it cannot locate the fragment you want to extend.

The checkout drop-in component exposes the following fragments:

```js title='fragments.ts'
export {
  BILLING_CART_ADDRESS_FRAGMENT,
  SHIPPING_CART_ADDRESS_FRAGMENT,
} from '@/checkout/api/graphql/CartAddressFragment.graphql';
export {
  AVAILABLE_PAYMENT_METHOD_FRAGMENT,
  SELECTED_PAYMENT_METHOD_FRAGMENT,
} from '@/checkout/api/graphql/CartPaymentMethodFragment.graphql';
export { CHECKOUT_DATA_FRAGMENT } from '@/checkout/api/graphql/CheckoutDataFragment.graphql';
export { CUSTOMER_FRAGMENT } from '@/checkout/api/graphql/CustomerFragment.graphql';
```

### Extend or customize a fragment

To make GraphQL fragments extensible in the drop-in component, you must first update the GraphQL fragment that the drop-in uses to request the additional field. You accomplish this by modifying the `build.mjs` script located at the root of your storefront project.

The `build.mjs` script automatically generates a new GraphQL query for the checkout drop-in component when you run the install command. This generated query includes the additional data that you specified in your fragment extensions.

#### Example 1: Adding new information

The merchant wants to extend the customer information by adding the gender and date of birth data.

```js title='build.mjs'
/* eslint-disable import/no-extraneous-dependencies */

overrideGQLOperations([
  {
    npm: '@dropins/storefront-checkout',
    operations: [
      `
      fragment CUSTOMER_FRAGMENT on Customer {
        gender
        date_of_birth
      }
      `,
    ],
  },
]);
```

After extending the API, you must extend the models and transformers during the initialization phase if data transformation is required. You accomplish this by modifying the `/scripts/initializers/checkout.js` script.

```js title='/scripts/initializers/checkout.js'
// Initialize checkout
await initializeDropin(async () => {
  // Register the checkout component with models extensibility
  const models = {
    CustomerModel: {
      transformer: (data) => ({
        gender: ((gender) => {
          switch (gender) {
            case 1:
              return "Male";
            case 2:
              return "Female";
            case 3:
              return "Not Specified";
            default:
              return "";
          }
        })(data?.gender),
        dateOfBirth: data?.date_of_birth,
      }),
    },
  };

  // Register initializers
  return initializers.mountImmediately(initialize, {
    models
  });
})();
```

#### Example 2: Removing information

The merchant wants to remove the selected payment method data. 

```js title='build.mjs'
/* eslint-disable import/no-extraneous-dependencies */

overrideGQLOperations([
  {
    npm: '@dropins/storefront-checkout',
    skipFragments: ['SELECTED_PAYMENT_METHOD_FRAGMENT'],
    operations: [],
  },
]);
```

> **Note:** If the `build.mjs` script references a fragment that the drop-in component does not expose, the application build process fails.

> **Note:** See the [GraphQL Extensibility API](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/graphql/) and [Extending drop-in components](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/extending/) documentation to learn more about on how to extend the API for a drop-in component.

---

# Checkout functions

This topic provides the details and instructions you need to use the functions provided by the Checkout drop-in component.

## authenticateCustomer

The `authenticateCustomer` function manages the authentication state of a customer, either by fetching customer data using the [`getCustomer`](#getcustomer) function when authenticated or resetting the customer data when not authenticated.

```ts
export const authenticateCustomer = async (authenticated = false);
```



### Returns

The function does not return any value explicitly; it performs side effects by fetching data and logging errors.

### Usage

See the following example for usage details:

```ts
async function authenticate() {
  try {
    await authenticateCustomer(true);
    console.log('Customer authenticated successfully.');
  } catch (error) {
    console.error('Error authenticating customer:', error);
  }
}
```

## estimateShippingMethods

The `estimateShippingMethods` function fetches and displays available shipping methods based on a customer's address information. If no information is provided, it takes the default country configured by default. It can take a combination of fields as `input` criteria: country, region, region identifier, and postal code.

It uses a utility function to call an [`estimateShippingMethods`](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/estimate-shipping-methods/) mutation.

```ts
export interface ShippingEstimationCriteria {
  country_code: string;
  region_name?: string;
  region_id?: string | number;
  zip?: string;
}

export type EstimateShippingInput = {
  criteria: ShippingEstimationCriteria;
};

export const estimateShippingMethods = async (
  input?: EstimateShippingInput
): Promise<ShippingMethod[] | undefined>;
```



### Returns

Returns a promise that resolves to an array of `ShippingMethod` objects (or `undefined` if no shipping methods are available) fetched from the API.

```ts
export type ShippingMethod = {
  amount: Price;
  carrier: Carrier;
  code: Code;
  title: Title;
  value: string;
  amountExclTax?: Price;
  amountInclTax?: Price;
};
```

### Usage

See the following example for usage details:

```ts
// By country code and region name
const input = {
  criteria: {
    country_code: 'US',
    region_name: 'FL',
  },
};
const estimateShippingMethods = await estimateShippingMethods(input);

// By country code and region ID
const input = {
  criteria: {
    country_code: 'US',
    region_id: 18,
  },
};
const estimateShippingMethods = await estimateShippingMethods(input);

// By country code and postal code
const input = {
  criteria: {
    country_code: 'US',
    zip: '80000',
  },
};
const estimateShippingMethods = await estimateShippingMethods(input);

// By country code, region and postal code
const input = {
  criteria: {
    country_code: 'US',
    region_name: 'FL',
    zip: '80000',
  },
};
const estimateShippingMethods = await estimateShippingMethods(input);

// By country code, region, region id and postal code
// This scenario is specific for those regions which have more than a region ID
// associated (i.e. Armed Forces region 'AE' with some regions IDs); if the region has
// just a region ID,
const input = {
  criteria: {
    country_code: 'US',
    region_name: 'FL',
    region_id: 18,
    zip: '80000',
  },
};
const estimateShippingMethods = await estimateShippingMethods(input);
```

## getCart

The `getCart` function fetches the cart details for either a [guest user](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/queries/cart/) or an [authenticated customer](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/cart/).

```ts
export const getCart = async ();
```

### Returns

Returns a promise that resolves to the transformed cart data fetched from the API.

```ts
export interface Cart {
  availablePaymentMethods?: PaymentMethod[];
  billingAddress?: Address;
  email?: string;
  id: string;
  isEmpty: boolean;
  isGuest: boolean;
  isVirtual: boolean;
  selectedPaymentMethod?: PaymentMethod;
  shippingAddresses?: ShippingAddress[];
}
```

### Usage

See the following example for usage details:

```ts
async function fetchCartData() {
  try {
    const cartData = await getCart();
    console.log('Cart Data:', cartData);
  } catch (error) {
    console.error('Error fetching cart data:', error);
  }
}

// Call the function to fetch and log the cart data
fetchCartData();
```

## getCheckoutAgreements

The `getCheckoutAgreements` function fetches the list of terms and conditions configured in the Admin Panel using the [`checkoutAgreements`](https://developer.adobe.com/commerce/webapi/graphql/schema/checkout/queries/agreements/) query.

```ts
export const getCheckoutAgreements = async (): Promise<CheckoutAgreement[]>
```

### Returns

The function returns a promise that resolves to an array of checkout agreements or an empty array if none are enabled.

```ts
export enum AgreementMode {
  MANUAL = 'manual',
  AUTO = 'auto',
}

type AgreementContent = {
  value: string;
  html: boolean;
  height: string | null;
};

export interface CheckoutAgreement {
  content: AgreementContent;
  id: number;
  mode: AgreementMode;
  name: string;
  text: string;
}
```

### Usage

See the following example for usage details:

```ts
async function fetchAndLogTermsAndConditions() {
  try {
    const agreements = await getCheckoutAgreements();
    console.log('List of Terms and Conditions:', agreements);
  } catch (error) {
    console.error('Error fetching terms and conditions:', error);
  }
}

// Call the function to fetch and log the list of Terms and Conditions
fetchAndLogTermsAndConditions();
```

## getCustomer

The `getCustomer` function fetches customer details for an authenticated user using the [`customer`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/customer/) query.

```ts
export const getCustomer = async (): Promise<Customer | null>
```

### Returns

The function returns a promise that resolves to the transformed customer data fetched from the API or `null` if the user is not authenticated.

```ts
export interface Customer {
  firstName: string;
  lastName: string;
  email: string;
}
```

### Usage

See the following example for usage details:

```ts
async function fetchAndLogCustomer() {
  try {
    const customer = await getCustomer();
    if (customer) {
      console.log('Customer:', customer);
    } else {
      console.log('No customer data found.');
    }
  } catch (error) {
    console.error('Error fetching customer data:', error);
  }
}

// Call the function to fetch and log the customer data
fetchAndLogCustomer();
```

## getStoreConfig

The `getStoreConfig` function fetches information about a store's configuration settings using the [`storeConfig`](https://developer.adobe.com/commerce/webapi/graphql/schema/store/queries/store-config/) query.

You can query a non-default store by changing the header in your GraphQL request.

```ts
export const getStoreConfig = async ();
```

### Returns

The function returns a promise that resolves to the transformed store configuration data fetched from the API.

If the API call fails, it returns the default store configuration settings (`STORE_CONFIG_DEFAULTS`).

```ts
export interface StoreConfig {
  defaultCountry: string;
  agreementsEnabled: boolean;
  shoppingCartDisplaySetting: {
    shipping: TaxDisplay;
  };
}
```

### Usage

See the following example for usage details:

```ts
async function fetchAndLogStoreConfig() {
  try {
    const storeConfig = await getStoreConfig();
    console.log('Store Config:', storeConfig);
  } catch (error) {
    console.error('Error fetching store config:', error);
  }
}

// Call the function to fetch and log the store configuration
fetchAndLogStoreConfig();
```

## initializeCheckout

The `initializeCheckout` function initializes the checkout process by fetching necessary configuration and data from various Adobe Commerce GraphQL APIs using the following functions:

- `getStoreConfig`
- `getCart`
- `synchronizeCheckout`

```ts

export const initializeCheckout = async (cart: Cart | null): Promise<void>
```



### Returns

The function does not return any value explicitly; it performs some initializations and finally emits the `checkout/initialized` event containing the initial cart data.

### Usage

See the following example for usage details:

```ts
await initializeCheckout(null);
```

## isEmailAvailable

The `isEmailAvailable` function checks whether the specified email has already been used to create a customer account using the [`isEmailAvailable`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/is-email-available/) query.

A value of `true` indicates that the email address is available and the customer can use the email address to create an account. As of Adobe commerce 2.4.7, the default value is `true`.

```ts
export const isEmailAvailable = async (
  email: string
): Promise<EmailAvailability>
```



### Returns

A promise that resolves to an `EmailAvailability` object indicating whether the email is available.

```ts
export type EmailAvailability = boolean;
```

### Usage

See the following example for usage details:

```ts
await isEmailAvailable('test@example.com');
```

## resetCheckout

The `resetCheckout` function resets the checkout process to its initial state by clearing the cart data.

```ts
export const resetCheckout = ();
```

### Returns

The function does not return any value explicitly; it performs some initializations and finally emits the `checkout/updated` event containing null data.

### Usage

See the following example for usage details:

```ts
resetCheckout();
```

## setBillingAddress

The `setBillingAddress` function sets the billing address for a specific cart using the [`setBillingAddressOnCart`](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/set-billing-address/) Adobe Commerce GraphQL mutation.

```ts
export const setBillingAddress = async (input: BillingAddressInput);
```



The `input` parameter accepts a `BillingAddressInput` object with the following structure:

```ts
interface BillingAddressInput {
  address?: CartAddress;
  customerAddressId?: number;
  sameAsShipping?: boolean;
  useForShipping?: boolean;
}
```

Where `CartAddress` has the following properties:

```ts
interface CartAddress {
  city: string;
  company?: string;
  countryCode: string;
  customAttributes: CustomAttribute[];
  firstName: string;
  lastName: string;
  postcode?: string;
  region?: string;
  regionId?: number;
  saveInAddressBook?: boolean;
  street: string[];
  telephone?: string;
  vatId?: string;
  prefix?: string;
  suffix?: string;
  middleName?: string;
  fax?: string;
}
```

And `CustomAttribute` is defined as:

```ts
interface CustomAttribute {
  attribute_code: string;
  value: string;
}
```

### Returns

The function returns a promise that resolves to the transformed cart data fetched from the API.

```ts
export interface Cart {
  availablePaymentMethods?: PaymentMethod[];
  billingAddress?: Address;
  email?: string;
  id: string;
  isEmpty: boolean;
  isGuest: boolean;
  isVirtual: boolean;
  selectedPaymentMethod?: PaymentMethod;
  shippingAddresses?: ShippingAddress[];
}
```

### Usage

To set the billing address as the same as the shipping address:

```ts
await setBillingAddress({
  sameAsShipping: true,
});
```

To set a specific billing address:

```ts
await setBillingAddress({
  address: {
    firstName: 'John',
    lastName: 'Doe',
    street: ['123 Main St', 'Apt 1'],
    city: 'New York',
    postcode: '10001',
    countryCode: 'US',
    telephone: '555-555-5555',
  },
  sameAsShipping: false,
});
```

## setGuestEmailOnCart

The `setGuestEmailOnCart` function sets the email address for a guest user on the cart using the [`setGuestEmailOnCart`](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/set-guest-email/) mutation.

```ts
export const setGuestEmailOnCart = async (email: string);
```



### Returns

The function returns a promise that resolves to the transformed cart data fetched from the API.

```ts
export interface Cart {
  availablePaymentMethods?: PaymentMethod[];
  billingAddress?: Address;
  email?: string;
  id: string;
  isEmpty: boolean;
  isGuest: boolean;
  isVirtual: boolean;
  selectedPaymentMethod?: PaymentMethod;
  shippingAddresses?: ShippingAddress[];
}
```

### Usage

See the following example for usage details:

```ts
await setGuestEmailOnCart('test@example.com');
```

## setPaymentMethod

The `setPaymentMethod` function sets the provided payment method for the current cart using the [`setPaymentMethodOnCart`](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/set-payment-method/) mutation.

```ts
/** Defines the payment method. */
export type PaymentMethodInput = {
  /** The internal name for the payment method. */
  code: Scalars['String']['input'];
};

export const setPaymentMethod = async (paymentMethod: PaymentMethodInput);
```



### Returns

The function returns a promise that resolves to the transformed cart data fetched from the API.

```ts
export interface Cart {
  availablePaymentMethods?: PaymentMethod[];
  billingAddress?: Address;
  email?: string;
  id: string;
  isEmpty: boolean;
  isGuest: boolean;
  isVirtual: boolean;
  selectedPaymentMethod?: PaymentMethod;
  shippingAddresses?: ShippingAddress[];
}
```

### Usage

See the following example for usage details:

```ts
await setPaymentMethod({ code: 'braintree' });
```

## setShippingAddress

The `setShippingAddress` function sets the shipping address for a specific cart using the [`setShippingAddressesOnCart`](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/set-shipping-address/) mutation.

```ts
export const setShippingAddress = async (input: ShippingAddressInput);
```



The `input` parameter accepts a `ShippingAddressInput` object with the following structure:

```ts
interface ShippingAddressInput {
  address?: CartAddress;
  customerAddressId?: number;
  pickupLocationCode?: string;
}
```

Where `CartAddress` has the following properties:

```ts
interface CartAddress {
  city: string;
  company?: string;
  countryCode: string;
  customAttributes: CustomAttribute[];
  firstName: string;
  lastName: string;
  postcode?: string;
  region?: string;
  regionId?: number;
  saveInAddressBook?: boolean;
  street: string[];
  telephone?: string;
  vatId?: string;
  prefix?: string;
  suffix?: string;
  middleName?: string;
  fax?: string;
}
```

And `CustomAttribute` is defined as:

```ts
interface CustomAttribute {
  attribute_code: string;
  value: string;
}
```

### Returns

The function returns a promise that resolves to the transformed cart data fetched from the API.

```ts
export interface Cart {
  availablePaymentMethods?: PaymentMethod[];
  billingAddress?: Address;
  email?: string;
  id: string;
  isEmpty: boolean;
  isGuest: boolean;
  isVirtual: boolean;
  selectedPaymentMethod?: PaymentMethod;
  shippingAddresses?: ShippingAddress[];
}
```

### Usage

See the following example for usage details:

```ts
await setShippingAddress({
  address: {
    firstName: 'John',
    lastName: 'Doe',
    street: ['123 Main St', 'Apt 1'],
    city: 'New York',
    postcode: '10001',
    countryCode: 'US',
    telephone: '555-555-5555',
  },
});
```

## setShippingMethodsOnCart

The `setShippingMethodsOnCart` function sets the shipping methods for a specific cart using the [`setShippingMethodsOnCart`](https://developer.adobe.com/commerce/webapi/graphql/schema/cart/mutations/set-shipping-method/) mutation.

```ts
/** Defines the shipping carrier and method. */
export type ShippingMethodInput = {
  /** A string that identifies a commercial carrier or an offline delivery method. */
  carrier_code: Scalars['String']['input'];
  /** A string that indicates which service a commercial carrier will use to ship items. For offline delivery methods, this value is similar to the label displayed on the checkout page. */
  method_code: Scalars['String']['input'];
};

export const setShippingMethodsOnCart = async (
  shippingMethods: Array<InputMaybe<ShippingMethodInput>>
);
```



### Returns

The function returns a promise that resolves to the transformed cart data fetched from the API.

```ts
export interface Cart {
  availablePaymentMethods?: PaymentMethod[];
  billingAddress?: Address;
  email?: string;
  id: string;
  isEmpty: boolean;
  isGuest: boolean;
  isVirtual: boolean;
  selectedPaymentMethod?: PaymentMethod;
  shippingAddresses?: ShippingAddress[];
}
```

### Usage

See the following example for usage details:

```ts
const shippingMethod = {
  carrier_code: 'flatrate',
  method_code: 'flatrate',
};

await setShippingMethodsOnCart([shippingMethod]);
```

## synchronizeCheckout

The `synchronizeCheckout` function synchronizes the checkout state with the current cart information. It ensures that the checkout process is properly initialized, reset, or updated based on the cart data. It uses the following functions:

- `getCart`
- `initializeCheckout`

```ts

export const synchronizeCheckout = async (cart: Cart | null);
```



### Returns

The function does not return any value explicitly; it performs some initializations and finally emits the `checkout/updated` event containing the cart data.

### Usage

See the following example for usage details:

```ts
await synchronizeCheckout(cart);
```

---

# Checkout overview

The checkout drop-in component provides a variety of fully-customizable controls to help complete a purchase.

These controls include forms to introduce required information for contact details like email address, delivery and billing addresses, shipping options, and payment methods. Established customers who added items to the cart as a guest have the ability to sign in, automatically loading default addresses and contact details.

## Available resources

The checkout drop-in component includes the following resources:

- **[API Functions](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/functions/)** - Core functions for managing checkout operations like authentication, shipping methods, and order placement
- **[Utility Functions](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/utilities/)** - Helper functions for DOM manipulation, form handling, data transforms, and more
- **[Containers](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/)** - Pre-built UI components for checkout steps
- **[Event Handling](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/)** - Event-driven architecture for component communication

## Supported Commerce features

The following table provides an overview of the Adobe Commerce features that the checkout component supports:

| Feature                                                                            | Status                                    |
| ---------------------------------------------------------------------------------- | ----------------------------------------- |
| All product types                                                                  |   |
| Any checkout flow (BOPIS, one/two step)                                            |   |
| Any checkout layout                                                                |   |
| Apply coupons to the order                                                         |   |
| Apply gift cards to the order                                                      |   |
| Cart rules                                                                         |   |
| Create account after checkout                                                      |   |
| Custom customer address attributes                                                 |   |
| Customer address selection at checkout                                             |   |
| Customer checkout                                                                  |   |
| Customer segments                                                                  |   |
| Default customer shipping and billing applied at checkout                          |   |
| Extensibility for payment providers                                                |   |
| Guest checkout                                                                     |   |
| Log in during checkout                                                             |   |
| Low product stock alert                                                            |   |
| Out of stock/insufficient quantity products                                        |   |
| Taxes: Fixed                                                                       | |
| Taxes: Sales, VAT                                                                  |   |
| Terms and conditions consent                                                       |   |
| Zero subtotal checkout                                                             |   |
| Multi-step checkout                                                                |   |

---

# Checkout initialization

The checkout drop-in component initializer provides options for configuring language definitions and extending the default models with new fields and transformers.

## Configuration options

The checkout component initializer accepts the following configuration options:



These configuration options are implementing the `ConfigProps` type:

### ConfigProps type

The `Initializer` receives an object as a parameter which implements the `ConfigProps` type with the following properties:

```ts
export type ConfigProps = {
  langDefinitions?: Lang;
  models?: {
    CartModel?: Model<CartModel>;
    CustomerModel?: Model<CustomerModel>;
  };
};
```

### Example

The following code shows an example implementation of the checkout initializer configuration:

```ts
await initializeDropin(async () => {
  setFetchGraphQlHeaders(await getHeaders('checkout'));

  const labels = await fetchPlaceholders();
  const langDefinitions = {
    default: {
      ...labels,
    },
  };

  return initializers.mountImmediately(initialize, { langDefinitions });
})();
```

### Set language definitions

The `langDefinitions` property is used to fetch and register dictionary files for the checkout component. This allows you to provide localized text for different languages in your application.

```ts
// Initialize checkout
await initializeDropin(async () => {
  // Fetch the dictionary files for your application
  const en_US = await fetch('/i18n/en_US.json').then((res) => res.json());
  const fr_FR = await fetch('/i18n/fr_FR.json').then((res) => res.json());

  // Register the checkout component with language definitions
  const langDefinitions = {
    default: en_US,
    en_US,
    fr_FR,
  };

  // Register initializers
  return initializers.mountImmediately(initialize, {
    langDefinitions,
  });
})();
```

### Set models

You can extend the default models in the checkout component and provide transformers to process new fields.

The `models` property is an object that contains the default models that you might want to extend and the transformers to use to transform the data. By default, the checkout component initializer accepts the following models only:

- `CartModel`
- `CustomerModel`

The following example shows how to extend the default models with new fields and transformers:

```ts
// Initialize checkout
await initializeDropin(async () => {
  // Register the checkout component with models extensibility
  const models = {
    CustomerModel: {
      transformer: (data) => ({
        gender: ((gender) => {
          switch (gender) {
            case 1:
              return "Male";
            case 2:
              return "Female";
            case 3:
              return "Not Specified";
            default:
              return "";
          }
        })(data?.gender),
        dateOfBirth: data?.date_of_birth,
      }),
    },
    CartModel: {
      transformer: (data) => ({
        printedCardIncluded: data?.printed_card_included,
        giftReceiptIncluded: data?.gift_receipt_included,
      }),
    },
  };

  // Register initializers
  return initializers.mountImmediately(initialize, {
    models
  });
})();
```

---

# Checkout installation

The checkout drop-in component provides a customizable UI for the checkout process. The checkout component is designed to be integrated into your storefront and provides a seamless checkout experience for customers.

## Installation

Since the checkout component relies on containers from several other drop-in components, you must install and configure those components before you can use the checkout component.

The [Commerce boilerplate template](https://github.com/hlxsites/aem-boilerplate-commerce) includes all of the necessary drop-in components and configurations to help you get started quickly, so Adobe recommends relying on the boilerplate instead of installing, configuring, and integrating the drop-in components individually.

## Admin configuration

Before you can use the checkout component on your storefront, you must enable and configure [payment providers](https://experienceleague.adobe.com/en/docs/commerce-admin/stores-sales/payments/payments) and [checkout options](https://experienceleague.adobe.com/en/docs/commerce-admin/stores-sales/point-of-purchase/checkout/checkout-process) in the Adobe Commerce Admin.

:::note
The checkout [overview](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/) provides a summary of supported Adobe Commerce features.
:::

---

# Checkout slots

Learn about the slots provided in the checkout drop-in component.

[Extending drop-in components](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/extending/) describes the default properties available to all slots.

## Title slots

The `TitleProps` interface defines slots for the [`Title`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/#title-and-heading-customization) component. These slots enable you to customize the title content displayed in specific containers.

```ts
export interface TitleProps {
  displayTitle?: boolean;
  slots?: {
    Title?: SlotProps;
  };
}
```

### Title

The `Title` property is a callback function that renders custom title content. It receives the default context implementing the `DefaultSlotContext` interface:

```ts
interface DefaultSlotContext<T> extends PrivateContext<T> {
  dictionary: Lang;
  getSlotElement: (key: string) => SlotElement;
  replaceWith: MutateElement;
  appendChild: MutateElement;
  prependChild: MutateElement;
  appendSibling: MutateElement;
  prependSibling: MutateElement;
  onRender: (cb: (next: T & DefaultSlotContext<T>) => void) => void;
  onChange: (cb: (next: T & DefaultSlotContext<T>) => void) => void;
}

export type SlotProps<T = any> = (
  ctx: T & DefaultSlotContext<T>,
  element: HTMLDivElement | null
) => Promise<void> | void;
```

> **Note:** Some containers extend their props interface to use the `TitleProps` slot to customize the title content. You will find some examples on those specific containers.

## LoginForm slots

The LoginFormProps interface defines the available slots for the [`LoginForm`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/login-form/) container. The slots allow setting the heading content dynamically based on the user authentication status.

```ts
export interface LoginFormProps extends HTMLAttributes<HTMLFormElement>, TitleProps {
  . . .
  slots?: {
    Heading?: SlotProps<{
      authenticated: boolean;
    }>;
  } & TitleProps['slots'];
}
```

### Heading

The `Heading` property is a callback function that renders custom heading content based on the authentication status provided by the context. The `Heading` slot receives a boolean as a context indicating whether the user is authenticated.

> **Note:** See the [`LoginForm`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/login-form/) container to learn more about the properties and how to override the slots to configure and customize the login form.

## PaymentMethods slots

The slots for the [`PaymentMethods`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/payment-methods/) container are defined in the `PaymentMethodsProps` interface shown below. The slots allow you to customize the list of payment methods to show during the checkout process.

```ts
export interface PaymentMethodsProps extends HTMLAttributes<HTMLDivElement>, TitleProps {
  . . .
  slots?: {
    Methods?: PaymentMethodsSlot;
  } & TitleProps['slots'];
}
```

### Methods

The `Methods` property is an object which implements the `PaymentMethodsSlot` interface:

```ts
export interface PaymentMethodsSlot {
  [code: string]: PaymentMethodConfig;
}
```

It consists on a list of payment method codes providing a set of configurations to customize the payment method. Each payment method will have its own set of configurations implementing the `PaymentMethodConfig` interface:

```ts
export interface PaymentMethodConfig {
  displayLabel?: boolean;
  enabled?: boolean;
  icon?: string;
  autoSync?: boolean;
  render?: SlotProps<PaymentMethodRenderCtx>;
}
```

Finally the `render` property is a callback function used to render and configure the payment method in case of being selected. The `render` slot receives a context implementing the following `PaymentMethodRenderCtx` interface:

```ts
export type SlotProps<T = any> = (
  ctx: T & DefaultSlotContext<T>,
  element: HTMLDivElement | null
) => Promise<void> | void;

export interface PaymentMethodRenderCtx {
  cartId: string;
  replaceHTML: (domElement: HTMLElement) => void;
}
```

The context object passed to the `render` slot includes a _replaceHTML_ property that is a callback function and the _cartId_ got from the internal state.

> **Note:** Please visit the [`PaymentMethods`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/payment-methods/) container page to learn more about of the properties, and how to override the slots to configure and customize payment methods described on different examples.

> **Note:** See the [add payment method](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/tutorials/add-payment-method/) tutorial for more information on how to configure the Braintree payment method.

## PlaceOrder slots

The slots for the [`PlaceOrder`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/place-order/) container are defined in the `PlaceOrderProps` interface shown below. The slots allow you to set the container content dynamically based on the selected payment method.

```ts
export interface PlaceOrderProps extends HTMLAttributes<HTMLDivElement> {
  . . .
  slots?: {
    Content?: SlotProps<ContentSlotContext>;
  };
}
```

### Content

The `Content` property is a callback function used to render the container content. The `Content` slot receives a context implementing the following `ContentSlotContext` interface:

```ts
export type SlotProps<T = any> = (
  ctx: T & DefaultSlotContext<T>,
  element: HTMLDivElement | null
) => Promise<void> | void;

export interface ContentSlotContext {
  code: string;
}
```

The context object passed to the `Content` slot includes the _code_ got from the selected payment method.

> **Note:** Please visit the [`PlaceOrder`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/place-order/) container page to learn more about of the properties, and how to override the slots to configure and customize the place order button described on different examples.

## TermsAndConditions slots

The `TermsAndConditionsProps` interface defines the available slots for the [`TermsAndConditions`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/terms-and-conditions/) container. These slots enable you to specify terms and conditions that customers must accept before completing their order.

```ts
export interface TermsAndConditionsProps {
  slots?: {
    Agreements?: SlotProps<{
      appendAgreement: SlotMethod<{
        name: string;
        mode: AgreementMode;
        text?: string;
        translationId?: string;
      }>;
    }>;
  };
}
```

### Agreements

The `Agreements` property is a callback function that configures and renders a list of agreements. It provides context by including the `appendAgreement()` method to add a new agreement based on the `SlotMethod` type:

```ts
export type SlotMethod<P = any> = (
  callback: (next: unknown, state: State) => P
) => void;

export enum AgreementMode {
  MANUAL = 'manual',
  AUTO = 'auto',
}
```

The context object passed to the `appendAgreement` slot method includes the required information to configure an agreement.

> **Note:** See the [`TermsAndConditions`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/terms-and-conditions/) container to learn more about the properties and how to override the slots to configure and customize a list of agreements.

---

# Checkout styles

This topic introduces you to the CSS classes for each UI component used in the checkout drop-in component and shows you how to override these classes to customize the component's CSS styling to match your brand.

## Big Picture

The quickest way to override checkout CSS is to inspect the checkout UI from your browser's developer tools to discover the BEM class names you want to add to or override. This process is numbered in the image below.


  ![Find CSS classes to override](@images/dropins/findstylescheckout.png/)


{/* Use the `Callouts` control to describe the numbered annotations in the screenshot. */}



1. **Inspect the element** in the UI that you want to customize (right-click on the element and select "Inspect" from the menu).
1. **Identify the CSS class(es)** for the element. We use [BEM naming](https://getbem.com/naming/), which makes it easy to know which component you're changing (and which CSS file to use).
1. **Copy the CSS class names to override** to your custom CSS file.



## How to override the checkout styles



1. **Create a new CSS file** in your project for the checkout component. Name the file `custom-checkout.css`.
1. **Copy the BEM class names** displayed in the Element tab of the developer panel into your new file.
1. **Add your custom CSS rules** to the `custom-checkout.css` file to add or override the default styles.
1. **Import the custom CSS file** into the `commerce-checkout.css` file.

   ```css
   @import 'custom-checkout.css';
   ```

1. **Save the file** and refresh your browser to see the changes.



## Example CSS overrides

The following example shows how to override two of the many classes for the checkout1 component.

```css title="custom-checkout.css"
.checkout__heading {
  display: flex;
  justify-content: space-between;
}

.checkout__heading-title {
  line-height: 1.5;
  font-size: 1.5rem;
}
```

## Checkout CSS classes

The CSS classes for each checkout component are provided here.

---

# Add a payment method

To integrate third-party payment providers, you can use the extensibility features provided by the Checkout drop-in component. This component allows you to customize the list of payment methods shown during the checkout process using slots.

## Step-by-step

This tutorial walks you through integrating Braintree as a payment provider with the Commerce boilerplate template. While we use Braintree as an example, you can adapt these same steps for other payment providers.

> **Note:** Make sure that the payment provider you choose offers an SDK or API that you can use to integrate with the [slots](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/slots/) provided by the [`PaymentMethods`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/payment-methods/) container in the checkout drop-in component.

> **Note:** The `commerce-checkout.js` block is the only fully functional implementation that's up-to-date with the latest checkout drop-in component. 
Use these steps as a reference when developing your custom checkout experience.



<Task>
### Prerequisites

For this tutorial, you must configure the Braintree extension on your Adobe Commerce backend before integrating it with the Commerce boilerplate template. The Braintree extension is bundled with Adobe Commerce and can be [configured](https://experienceleague.adobe.com/en/docs/commerce-admin/stores-sales/payments/braintree) in the Admin.

If you choose to integrate with a different payment provider, consider the following:

- The provider must be supported by Adobe Commerce.
- The provider likely offers an extension that you must install and configure on your Adobe Commerce backend.
</Task>

<Task>
### Add the Braintree client SDK

To integrate the Braintree payment provider with the Commerce boilerplate template, you must add the Braintree client SDK to your project.

<Tabs>
  <TabItem label="HTML element" icon="seti:html">

  Use the following `script` tag to add the Braintree client SDK to an HTML file.

  ```html
  <script src="https://js.braintreegateway.com/web/dropin/1.43.0/js/dropin.min.js"></script>
  ```
  </TabItem>
  <TabItem label="Import declaration" icon="seti:javascript">

  Use the following `import` declaration to add the Braintree client SDK directly to the `commerce-checkout.js` block file.

  ```js
  import 'https://js.braintreegateway.com/web/dropin/1.43.0/js/dropin.min.js';
  ```
  </TabItem>
</Tabs>
</Task>

<Task>
### Define a custom handler

<Steps>
1. Create a `braintreeInstance` variable to manage the Braintree drop-in instance.

   ```js
   let braintreeInstance;
   ```

1. Update the [`PaymentMethods`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/payment-methods/) container to include a custom handler for the Braintree payment method. Set `autoSync` to `false` to prevent automatic calls to the [`setPaymentMethod`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/functions/#setpaymentmethod) function when the payment method changes.

   ```js
   CheckoutProvider.render(PaymentMethods, {
     slots: {
       Methods: {
         braintree: {
           autoSync: false,
           render: async (ctx) => {
             const container = document.createElement('div');

             window.braintree.dropin.create({
               authorization: 'sandbox_cstz6tw9_sbj9bzvx2ngq77n4',
               container,
             }, (err, dropinInstance) => {
               if (err) {
                 console.error(err);
               }

               braintreeInstance = dropinInstance;
             });

             ctx.replaceHTML(container);
           },
         },
       },
     },
   })($paymentMethods),
   ```
</Steps>
</Task>

<Task>
### Handle the payment method

Implement the Braintree payment logic within the `handlePlaceOrder` handler of the [`PlaceOrder`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/place-order/) container. This involves processing the payment using the Braintree [nonce](https://developer.paypal.com/braintree/docs/guides/payment-method-nonces).

```js
CheckoutProvider.render(PlaceOrder, {
  handlePlaceOrder: async ({ cartId, code }) => {
    await displayOverlaySpinner();
    try {
      switch (code) {
        case 'braintree': {
          braintreeInstance.requestPaymentMethod(async (err, payload) => {
            if (err) {
              removeOverlaySpinner();
              console.error(err);
              return;
            }

            await checkoutApi.setPaymentMethod({
              code: 'braintree',
              braintree: {
                is_active_payment_token_enabler: false,
                payment_method_nonce: payload.nonce,
              },
            });

            await orderApi.placeOrder(cartId);
          });

          break;
        }

        default: {
          // Place order
          await orderApi.placeOrder(cartId);
        }
      }
    } catch (error) {
      console.error(error);
      throw error;
    } finally {
      await removeOverlaySpinner();
    }
  },
})($placeOrder),
```
</Task>



## Example

See [`blocks/commerce-checkout-braintree`](https://github.com/hlxsites/aem-boilerplate-commerce/tree/demos/blocks/commerce-checkout-braintree) in the `demos` branch of the boilerplate repository for complete JS and CSS code for the Braintree payment method checkout flow.

---

# Integrate with a third-party address verification API

You might want to enhance the shopper experience by streamlining the process of populating and verifying the shipping address, thereby reducing the risk of user error. You can achieve this by implementing a third-party address lookup and autocomplete APIs, such as those provided by [Google Places](https://mapsplatform.google.com/maps-products/#places-section).

This tutorial describes how to override any field in a checkout address form and extend it to integrate with this service. The implementation supports backend-configurable validation and full form submission integration.

Upon successful completion of this tutorial, a form similar to the following will be displayed:


  ![Autocomplete shipping address](@images/dropins/checkout/address-lookup.png/)


## Step-by-step

The following steps describe how to integrate the Google Address Validation API with the Commerce boilerplate template using the provided address autocomplete implementation.

> **Note:** The `commerce-checkout.js` block is the only fully functional implementation that's up-to-date with the latest checkout drop-in component.
Use these steps as a reference when creating your own checkout experience.



<Task>
### Prerequisites

For this tutorial, you must have a valid Google API key. [Use API keys](https://developers.google.com/maps/documentation/javascript/get-api-key) describes the process to obtain and set up this key.

<Aside type="note">
The address autocomplete implementation includes a placeholder for the Google API key. You must replace `ADD-YOUR-GOOGLE-API-KEY-HERE` with your actual API key before using the implementation.
</Aside>

</Task>

<Task>
### Download and configure the address autocomplete implementation

1. **Download the implementation:**

   Copy the `address-autocomplete.js` file from `/public/samples/address-autocomplete.js` in this documentation repository to your project directory.

2. **Replace the API key placeholder:**

   Open the `address-autocomplete.js` file and replace `ADD-YOUR-GOOGLE-API-KEY-HERE` with your actual Google API key:

   ```javascript
   const CONFIG = {
       googleApiKey: 'YOUR_ACTUAL_GOOGLE_API_KEY',
       // ... rest of configuration
   };
   ```

</Task>

<Task>
### Import and initialize the autocomplete service

In your `commerce-checkout.js` file, make the following changes to enable address autocomplete:

1. **Import the autocomplete service:**

   ```javascript
   import { initializeAutocompleteWhenReady } from './address-autocomplete.js';
   ```

2. **Initialize the autocomplete in the `initializeCheckout` function:**

   ```javascript
   const initializeCheckout = async () => {
     // ... existing checkout initialization code ...

     // Initialize address autocomplete for shipping form
     const shippingContainer = document.querySelector('[data-commerce-checkout-shipping]');
     if (shippingContainer) {
       initializeAutocompleteWhenReady(shippingContainer, 'input[name="street"]');
     }

     // ... rest of initialization code ...
   };
   ```

The `initializeAutocompleteWhenReady` function automatically:
- Waits for the address form to be rendered
- Attaches autocomplete functionality to the street input field
- Handles form field population when an address is selected
- Manages Google Maps API loading and initialization

</Task>



## Example

The complete address autocomplete implementation is available in `/public/samples/address-autocomplete.js`. This implementation includes:

- **AddressAutocompleteService class**: Handles Google Places API integration
- **initializeAutocompleteWhenReady function**: Utility function for easy integration
- **Automatic form field population**: Populates street, city, country, and postal code fields
- **Keyboard navigation**: Arrow keys, Enter, and Escape support
- **Error handling**: Graceful fallback when Google Maps API is unavailable

For additional customization options and advanced usage, see the implementation comments in the sample file.

---

# Buy online, pickup in store

Buy online, pickup in store (BOPIS) is a popular fulfillment option that allows customers to purchase items online and pick them up in-store.

The Commerce boilerplate template does not include a BOPIS checkout flow by default, but you can easily implement one using Adobe's drop-in components.

## Step-by-step

The following steps describe how to modify the [commerce-checkout.js](https://github.com/hlxsites/aem-boilerplate-commerce/blob/main/blocks/commerce-checkout/commerce-checkout.js) block file in the boilerplate template to allow users to choose between delivery and in-store pickup during the checkout process.

> **Note:** The `commerce-checkout.js` block is the only fully functional implementation that's up-to-date with the latest checkout drop-in component.
Use these steps as a reference when creating your own checkout experience.



<Task>

### Prerequisites

Before you start, you must configure [in-store delivery](https://experienceleague.adobe.com/en/docs/commerce-admin/stores-sales/delivery/basic-methods/shipping-in-store-delivery) options in the Adobe Commerce Admin to define pickup locations. The [`fetchPickupLocations`](#fetch-pickup-locations) function retrieves the list of available pickup locations using a GraphQL query.

</Task>

<Task>

### Update content fragment

<Steps>
1. To create a new section for the delivery options, additional DOM elements are required. You can add these elements by modifying the content fragment.

   ```html
   <div class="checkout__block checkout__delivery-method">
     <h2 class="checkout__block checkout-delivery-method__title">Delivery Method</h2>
     <div class="checkout__block checkout-delivery-method__toggle-buttons">
       <div class="checkout__block checkout-delivery-method__delivery-button"></div>
       <div class="checkout__block checkout-delivery-method__in-store-pickup-button"></div>
     </div>
   </div>
   <div class="checkout__block checkout__in-store-pickup"></div>
   ```

1. You must also add new selectors to render the required components and content.

   ```javascript
   const $deliveryButton = checkoutFragment.querySelector('.checkout-delivery-method__delivery-button');
   const $inStorePickupButton = checkoutFragment.querySelector('. checkout-delivery-method__in-store-pickup-button');
   const $inStorePickup = checkoutFragment.querySelector('.checkout__in-store-pickup');
   ```

   ![Update content fragment](@images/dropins/checkout/bopis-content-fragment.png/)
</Steps>

</Task>

<Task>

### Add toggle buttons

During initialization, the code renders two buttons:

- Delivery
- In-store pickup

These buttons allow users to toggle between the two options.

```js
UI.render(ToggleButton, {
  label: 'Delivery',
  onChange: () => onToggle('delivery'),
})($deliveryButton),

UI.render(ToggleButton, {
  label: 'In-store Pickup',
  onChange: () => onToggle('in-store-pickup'),
})($inStorePickupButton),
```

![Toggle buttons](@images/dropins/checkout/bopis-toggle-buttons.png/)

</Task>

<Task>

### Toggle between options

The `onToggle` function manages switching between the delivery and in-store pickup options. It updates the selected state of the buttons and toggles the visibility of the corresponding forms.

```js
async function onToggle(type) {
  if (type === 'delivery') {
    deliveryButton.setProps((prev) => ({ ...prev, selected: true }));
    inStorePickupButton.setProps((prev) => ({ ...prev, selected: false }));
    $shippingForm.removeAttribute('hidden');
    $delivery.removeAttribute('hidden');
    $inStorePickup.setAttribute('hidden', '');
  } else {
    inStorePickupButton.setProps((prev) => ({ ...prev, selected: true }));
    deliveryButton.setProps((prev) => ({ ...prev, selected: false }));
    $shippingForm.setAttribute('hidden', '');
    $delivery.setAttribute('hidden', '');
    $inStorePickup.removeAttribute('hidden');
  }
}
```

</Task>

<Task>

### Fetch pickup locations

The `fetchPickupLocations` function retrieves the list of available pickup locations using a GraphQL query. Users can choose a location where they'd like to pick up their order.

```js
async function fetchPickupLocations() {
  return checkoutApi
    .fetchGraphQl(
      `query pickupLocations {
        pickupLocations {
          items {
            name
            pickup_location_code
          }
          total_count
        }
      }`,
      { method: 'GET', cache: 'no-cache' }
    )
    .then((res) => res.data.pickupLocations.items);
}
```

</Task>

<Task>

### Render location options

After the code fetches the pickup locations, it renders options as radio buttons. The user can select a location, which updates the shipping address with the corresponding pickup location code.

```js
const pickupLocations = await fetchPickupLocations();

pickupLocations.forEach((location) => {
  const { name, pickup_location_code } = location;
  const locationRadiobutton = document.createElement('div');

  UI.render(RadioButton, {
    label: name,
    name: 'pickup-location',
    value: name,
    onChange: () => {
      checkoutApi.setShippingAddress({
        address: {},
        pickupLocationCode: pickup_location_code,
      });
    },
  })(locationRadiobutton);

  $inStorePickup.appendChild(locationRadiobutton);
});
```

![Pick up location options](@images/dropins/checkout/bopis-render-pickup-locations.png/)

</Task>

<Task>

### Finalize the flow

After a user selects **In-store pickup** and chooses a location, the pickup form is shown, while the shipping form is hidden. This provides a clear and seamless way for users to choose how they want to receive their order.

</Task>



## Example

See [`blocks/commerce-checkout-bopis`](https://github.com/hlxsites/aem-boilerplate-commerce/tree/demos/blocks/commerce-checkout-bopis) in the `demos` branch of the boilerplate repository for complete JS and CSS code for the BOPIS checkout flow.

---

# Multi-step Checkout Implementation

This tutorial provides a customizable example to implement a comprehensive multi-step checkout in your Adobe Commerce storefront that supports **all user scenarios**: guest users, logged-in customers, and virtual products.

## Overview

This implementation provides a **complete multi-step checkout** for the Adobe Commerce boilerplate that handles:

- **Guest users** - Email capture and address entry
- **Logged-in customers** - Saved address selection and account integration  
- **Virtual products** - Automatic shipping step bypass
- **Mixed carts** - Physical + virtual product combinations
- **Modular architecture** - Event-driven step coordination

## Implementation Features

| Feature | Status |
|---------|--------|
| Guest users | âœ… |
| Logged-in customers | âœ… |
| Virtual products | âœ… |
| Mixed carts (physical + virtual products) | âœ… |
| Custom payment/shipping methods | ðŸ”§ |

## Multi-step Customization

Key areas specific to multi-step checkout customization:

- **Step progression logic** - Modify `steps.js` for custom user flows and step transitions
- **Individual step modules** - Customize step behavior in `steps/` folder
- **Step validation** - Control when users can advance between steps
- **Fragment management** - Adapt step-specific HTML fragments in `fragments.js`
- **Step visibility** - Customize CSS classes for active/inactive step states  
- **Manual synchronization** - Control when data is saved to the cart

## Architecture

### File Structure

The multi-step checkout implementation follows a modular architecture:

| File | Purpose | Key Features |
|------|---------|--------------|
| `commerce-checkout-multi-step.js` | Entry point and block decorator | Initializes the checkout system |
| `commerce-checkout-multi-step.css` | Step styling and visibility controls | Step progression, visual states, responsive design |
| `steps.js` | Main implementation | Step coordination and state management |
| `steps/shipping.js` | Shipping/contact step logic | Login detection, address forms, email validation |
| `steps/shipping-methods.js` | Delivery method selection | Shipping options, cost calculation |
| `steps/payment-methods.js` | Payment method selection | Payment provider integration |
| `steps/billing-address.js` | Billing address step | Conditional billing form rendering |
| `fragments.js` | HTML fragment creation | Step-specific DOM structure generation |
| `containers.js` | Container rendering functions | Drop-in container management |
| `components.js` | UI component functions | Reusable UI elements |
| `utils.js` | Utility functions and helpers | Virtual cart detection, validation |
| `constants.js` | Shared constants and configuration | CSS classes, form names, storage keys |

### Manual Synchronization Control

In multi-step checkout, containers use **`autoSync: false`** to disable automatic backend synchronization, allowing manual control over when data is saved:

```javascript
// Containers with manual sync control
const containers = [
  'LoginForm',        // Manual email/authentication handling
  'ShippingMethods',  // Manual shipping method selection  
  'PaymentMethods',   // Manual payment method selection
  'BillToShippingAddress' // Manual billing address control
];

// Example: ShippingMethods with manual sync
CheckoutProvider.render(ShippingMethods, {
  UIComponentType: 'ToggleButton', 
  autoSync: false,  // Disable automatic cart updates
})(container);
```

**AutoSync behavior:**
- **`autoSync: true` (default)** - Local changes automatically sync with backend via GraphQL mutations
- **`autoSync: false`** - Changes maintained locally only, no automatic API calls

**Why disable autoSync in multi-step:**
- **Controlled timing** - Save data only when step is completed and validated
- **Better UX** - Prevent partial/invalid data from being sent to cart
- **Step coordination** - Parent step manager controls when to persist data
- **Validation first** - Ensure all step requirements met before saving

**Manual sync example:**
```javascript
// Step completion with manual sync (triggered by continue button)
const continueFromStep = async () => {
  if (!validateStepData()) return;
  
  // Manual API call with error handling
  try {
    await checkoutApi.setShippingMethodsOnCart([{
      carrier_code: selectedMethod.carrier.code,
      method_code: selectedMethod.code,
    }]);
  } catch (error) {
    console.error('Failed to save step data:', error);
    return; // Don't proceed if API call fails
  }
  
  // Only continue if API call succeeded
  await displayStepSummary(selectedMethod);
  await continueToNextStep();
  
  events.emit('checkout/step/completed', null);
};
```

**Key patterns:**
- **Continue button trigger** - API calls happen when user clicks continue, not on selection
- **Try-catch wrapping** - All API calls must be wrapped for error handling
- **Early return on error** - If API fails, don't proceed to next step
- **Success-only progression** - Only move forward if data successfully saved

This approach ensures data integrity and provides smooth step transitions without premature backend updates.

### API Reference

Step modules rely on the checkout dropin's API functions for cart management. The complete API reference is available in the [Checkout functions](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/functions/) documentation.

**Key APIs for multi-step implementation:**

| Function | Purpose | Used In Step |
|----------|---------|--------------|
| `setGuestEmailOnCart()` | Set guest user email | Shipping (email capture) |
| `setShippingAddress()` | Set shipping address on cart | Shipping (address collection) |
| `setShippingMethodsOnCart()` | Set shipping methods on cart | Shipping Methods |
| `setPaymentMethod()` | Set payment method on cart | Payment Methods |
| `setBillingAddress()` | Set billing address on cart | Payment Methods, Billing Address |
| `isEmailAvailable()` | Check email availability | Order Header (account creation) |
| `getStoreConfigCache()` | Get cached store configuration | Address forms (default country) |
| `estimateShippingMethods()` | Estimate shipping costs | Address forms (cost calculation) |

All step completion logic should use these APIs with proper error handling as shown in the manual sync examples above.

**Note:** The implementation uses event-driven data (`events.lastPayload()`) instead of direct `getCart()` or `getCustomer()` calls for performance optimization and real-time state management.

### Component Registry Pattern

The `components.js` file implements a registry system specifically for **SDK components and external UI library components**:

```javascript
// components.js - Component registry (separate from containers)

const registry = new Map();

// Component IDs for UI elements
export const COMPONENT_IDS = {
  CHECKOUT_HEADER: 'checkoutHeader',
  SHIPPING_STEP_CONTINUE_BTN: 'shippingStepContinueBtn',
  PAYMENT_STEP_TITLE: 'paymentStepTitle',
  // ... more component IDs
};

// Core component methods
export const hasComponent = (id) => registry.has(id);
export const removeComponent = (id) => {
  const component = registry.get(id);
  if (component) {
    component.remove();
    registry.delete(id);
  }
};

// Render SDK components
export const renderCheckoutHeader = (container) => renderComponent(
  COMPONENT_IDS.CHECKOUT_HEADER,
  async () => UI.render(Header, {
    className: 'checkout-header',
    level: 1,
    size: 'large',
    title: 'Checkout',
  })(container)
);

export const renderStepContinueBtn = async (container, stepId, onClick) => 
  renderPrimaryButton(container, stepId, { children: 'Continue', onClick });
```

**Key distinction from containers:**

- **`containers.js`** - Manages **dropin containers** (LoginForm, AddressForm, ShippingMethods, etc.)
- **`components.js`** - Manages **SDK/UI library components** (Button, Header, ProgressSpinner, etc.)

**Usage guidelines:**

- **Use `components.js` for:** Headers, buttons, spinners, modals, and other UI elements from the SDK
- **Use `containers.js` for:** Checkout dropins, account dropins, cart dropins, and other business logic containers
- **Recommended approach:** Keep dropin containers and UI components in separate registries for better organization

This ensures clean architecture where `components.js` handles pure UI elements while `containers.js` manages complex business logic containers.

### Container Management

The `containers.js` file provides a complete system for managing **dropin containers** (LoginForm, AddressForm, ShippingMethods, etc.) with registry-based lifecycle management.

**Registry System:**

```javascript
// containers.js - Registry system for dropin containers
const registry = new Map();

// Core registry methods
export const hasContainer = (id) => registry.has(id);
export const getContainer = (id) => registry.get(id);
export const unmountContainer = (id) => {
  if (!registry.has(id)) return;
  const containerApi = registry.get(id);
  containerApi.remove();
  registry.delete(id);
};

// Helper to render or get existing container
const renderContainer = async (id, renderFn) => {
  if (registry.has(id)) {
    return registry.get(id); // Return existing
  }
  
  const container = await renderFn(); // Render new
  registry.set(id, container);
  return container;
};
```

**Container IDs and render functions:**

Each container is identified by a unique string ID and has a corresponding render function that handles the registry logic:

```javascript
// Predefined container identifiers
export const CONTAINERS = Object.freeze({
  LOGIN_FORM: 'loginForm',
  SHIPPING_ADDRESS_FORM: 'shippingAddressForm',
  SHIPPING_METHODS: 'shippingMethods',
  PAYMENT_METHODS: 'paymentMethods',
  // ... more containers
});

// Usage in container functions
export const renderLoginForm = async (container) => renderContainer(
  CONTAINERS.LOGIN_FORM,
  async () => CheckoutProvider.render(LoginForm, { /* config */ })(container)
);
```

**Key benefits of the container system:**

- **Centralized logic** - Complex container configuration in one place
- **Prevents duplicates** - Registry ensures same container isn't rendered multiple times
- **Memory management** - Automatic cleanup prevents memory leaks
- **State preservation** - Containers maintain state across step transitions

**Registry lifecycle:**
1. **Check existing** - `hasContainer()` / `getContainer()` to find existing instances
2. **Render once** - `renderContainer()` creates new containers only if needed
3. **Cleanup** - `unmountContainer()` removes containers and clears references

This comprehensive container management approach ensures efficient resource usage and prevents common issues like duplicate event listeners or memory leaks.

### Step Modules

The `steps/` folder contains individual step modules that handle specific checkout phases. Each step module implements a consistent interface and manages its own domain logic, UI rendering, and data validation.

**Step module structure:**

Each step file in the `steps/` folder follows the same architectural pattern:

```javascript
// steps/shipping.js - Example step module
export const createShippingStep = ({ getElement, api, events, ui }) => {
  return {
    async display(data) {
      // Render step UI using containers (LoginForm, AddressForm)
      // Handle different user types (guest vs logged-in)
      // Use manual sync patterns for form data
    },
    
    async displaySummary(data) {
      // Show completed step summary using fragment functions
      // Create edit functionality for step modifications
    },
    
    async continue() {
      // Validate step data and make API calls
      // Handle step progression logic
      // Emit completion events
    },
    
    isComplete(data) {
      // Validate step completion based on cart data
      // Handle virtual product logic
    },
    
    isActive() {
      // Check if step is currently active
    }
  };
};
```

**Available step modules:**

- **`shipping.js`** - Handles email capture (LoginForm) and shipping address collection (AddressForm)
- **`shipping-methods.js`** - Manages delivery method selection and shipping cost calculation
- **`payment-methods.js`** - Handles payment provider integration and method selection
- **`billing-address.js`** - Manages conditional billing address form rendering

**Step module responsibilities:**

- **UI rendering** - Uses container functions to render dropins
- **Data validation** - Validates step completion 
- **API integration** - Makes manual API calls with error handling
- **Event handling** - Responds to checkout events
- **Summary creation** - Generates read-only summaries with edit functionality

### Fragment Management

The `fragments.js` file is responsible for creating all DOM structure in the multi-step checkout. It provides a centralized system for generating HTML fragments, managing selectors, and creating reusable summary components.

**Core responsibilities:**

- **DOM Structure Creation** - Generates HTML fragments for each step and the main checkout layout
- **Selector Management** - Centralizes all CSS selectors in a frozen object for consistency
- **Summary Components** - Provides reusable functions for creating step summaries with edit functionality
- **Utility Functions** - Helper functions for fragment creation and DOM querying

**Fragment Creation Pattern:**

```javascript
// Step-specific fragment creation
function createShippingStepFragment() {
  return createFragment(`
    
    
    
    
    
  `);
}

// Main checkout structure
export function createCheckoutFragment() {
  const checkoutFragment = createFragment(`
    
      <div class="checkout__loader">
      
        <div class="checkout__main">
        
      </div>
    </div>
  `);
  // Append step fragments to main structure
  return checkoutFragment;
}
```

**Centralized Selector System:**

```javascript
// All selectors defined in one place
export const selectors = Object.freeze({
  checkout: {
    loginForm: '.checkout__login',
    shippingAddressForm: '.checkout__shipping-form',
    shippingStepContinueBtn: '.checkout__continue-to-shipping-methods',
    // ... more selectors
  }
});
```

**Summary Creation Functions:**

```javascript
// Reusable summary components with edit functionality
export const createLoginFormSummary = (email, onEditClick) => {
  const content = document.createElement('div');
  content.textContent = email;
  return createSummary(content, onEditClick);
};

export const createAddressSummary = (data, onEditClick) => {
  // Format address data into summary display
  return createSummary(formattedContent, onEditClick);
};
```

**Key benefits of fragment management:**

- **Consistent DOM structure** - All HTML is generated through standardized functions
- **CSS class coordination** - Selectors and fragments use the same class names
- **Reusable components** - Summary functions can be used across different steps
- **Maintainable markup** - All HTML structure defined in one centralized location

### Element Access Pattern

Step modules access DOM elements using the centralized selector system from `fragments.js`. Here's how step modules import and use those selectors:

```javascript
// steps/shipping.js - Element access in step modules

const { checkout } = selectors;

const elements = {
  $loginForm: getElement(checkout.loginForm),
  $loginFormSummary: getElement(checkout.loginFormSummary),
  $shippingAddressForm: getElement(checkout.shippingAddressForm),
  $shippingAddressFormSummary: getElement(checkout.shippingAddressFormSummary),
  $shippingStep: getElement(checkout.shippingStep),
  $shippingStepContinueBtn: getElement(checkout.shippingStepContinueBtn),
};
```

**Key benefits of this pattern:**
- **Centralized selectors** - All CSS classes defined in one location
- **Type safety** - Object structure prevents typos and missing selectors
- **Maintainability** - Easy to update selectors across the entire system
- **Consistency** - All step modules follow the same element access pattern
- **Fragment coordination** - Selectors match the structure created by fragments

This ensures that fragments create the DOM structure and steps access it through a consistent, maintainable selector system.

### Summary and Edit Pattern

When users complete a step by clicking the continue button and validation succeeds, the step transitions to **summary mode**:

```javascript
// Step completion flow
async function continueFromStep() {
  // 1. Validate step data
  if (!validateStep()) return;
  
  // 2. Save data to cart
  await api.setStepData(formData);
  
  // 3. Hide step content, show summary
  await displayStepSummary(data);
  
  // 4. Move to next step
  await displayNextStep();
}
```

**Summary features:**
- **Read-only display** - Shows completed step information in condensed format
- **Edit functionality** - "Edit" link allows users to return and modify data
- **Visual state** - Different styling indicates step completion
- **Persistent data** - Summary reflects the actual saved cart data

**Edit flow:**
```javascript
// Edit button functionality
const handleEdit = async () => {
  await displayStep(true); // Reactivate step
  // Previous data automatically pre-fills forms
};
```

This pattern ensures users can review their choices and make changes at any point without losing progress.

### Place Order Button Enablement

The **Place Order** button is disabled by default and only becomes enabled when all required steps are completed:

```javascript
// Place order button management
async function updatePlaceOrderButton(data) {
  const allStepsComplete = steps.shipping.isComplete(data) &&
    (!isVirtualCart(data) ? steps.shippingMethods.isComplete(data) : true) &&
    steps.paymentMethods.isComplete(data) &&
    steps.billingAddress.isComplete(data);

  if (allStepsComplete) {
    placeOrderButton.setProps({ disabled: false });
  } else {
    placeOrderButton.setProps({ disabled: true });
  }
}
```

**Progressive enablement features:**
- **Disabled by default** - Prevents incomplete order submissions
- **Step validation** - Checks each step's completion status
- **Virtual product logic** - Skips shipping validation for virtual carts
- **Real-time updates** - Button state updates as users complete steps
- **Visual feedback** - Users can see their progress toward completion

## Implementation Guide

The following sections demonstrate how to build a **production-ready multi-step checkout** using Adobe's drop-in components. This implementation replaces the regular one-step checkout in the boilerplate template with a sophisticated, modular system.

> **Note:** The _**commerce-checkout.js**_ block is the only one that is fully functional and up-to-date with the latest version of the checkout drop-in component.
Use the following guidelines just as a reference when creating a new checkout experience.



<Task>
### Create the entry point and main structure

Create the main block file `commerce-checkout.js` and set up the modular architecture:

```javascript
// Initializers

// Block-level utils

// Fragments

export default async function decorate(block) {
  setMetaTags('Checkout');
  document.title = 'Checkout';

  block.replaceChildren(createCheckoutFragment());

  const stepsManager = createStepsManager(block);
  await stepsManager.init();
}
```

Create `fragments.js` for the main HTML structure:

```javascript
export function createCheckoutFragment() {
  return document.createRange().createContextualFragment(`
    <div class="checkout__wrapper">
      <div class="checkout__heading"></div>
      <div class="checkout__empty-cart"></div>
      <div class="checkout__content">
        <div class="checkout__main"></div>
        <div class="checkout__aside"></div>
      </div>
    </div>
  `);
}
```

This modular approach separates concerns: the entry point coordinates everything, fragments handle HTML creation, and the steps manager handles step logic.
</Task>

<Task>
### Step fragments and HTML structure

Create the step-specific fragments in `fragments.js`. Each checkout step gets its own fragment with specific containers and CSS classes:

```javascript

/**
 * Creates the shipping address fragment for the checkout.
 * Includes login form and address form containers.
 */
function createShippingStepFragment() {
  return document.createRange().createContextualFragment(`
    <div class="checkout__login ${CHECKOUT_BLOCK} ${CHECKOUT_STEP_CONTENT}"></div>
    <div class="checkout__login-form-summary ${CHECKOUT_BLOCK} ${CHECKOUT_STEP_SUMMARY}"></div>
    <div class="checkout__shipping-form ${CHECKOUT_BLOCK} ${CHECKOUT_STEP_CONTENT}"></div>
    <div class="checkout__shipping-form-summary ${CHECKOUT_BLOCK} ${CHECKOUT_STEP_SUMMARY}"></div>
    <div class="checkout__continue-to-shipping-methods ${CHECKOUT_BLOCK} ${CHECKOUT_STEP_CONTENT} ${CHECKOUT_STEP_BUTTON}"></div>
  `);
}

/**
 * Creates the shipping methods fragment for the checkout.
 */
function createShippingMethodsStepFragment() {
  return document.createRange().createContextualFragment(`
    <div class="checkout__shipping-methods-title ${CHECKOUT_BLOCK} ${CHECKOUT_STEP_TITLE}"></div>
    <div class="checkout__shipping-methods-list ${CHECKOUT_BLOCK} ${CHECKOUT_STEP_CONTENT}"></div>
    <div class="checkout__shipping-methods-summary ${CHECKOUT_BLOCK} ${CHECKOUT_STEP_SUMMARY}"></div>
    <div class="checkout__continue-to-payment ${CHECKOUT_BLOCK} ${CHECKOUT_STEP_CONTENT} ${CHECKOUT_STEP_BUTTON}"></div>
  `);
}
```

**Key fragment concepts:**

- **CHECKOUT_STEP_CONTENT** - Shows containers when step is active (editable mode)
- **CHECKOUT_STEP_SUMMARY** - Shows completed step information (read-only mode)  
- **CHECKOUT_STEP_BUTTON** - Continue buttons for step progression
- **Multiple containers per step** - Each fragment can contain multiple containers with their own summary versions
- **CSS-driven visibility** - No DOM manipulation, just class-based show/hide

The shipping step includes **both login and address containers** because guests need both email capture (via LoginForm) and shipping address entry (via AddressForm).
</Task>

<Task>
### Create step modules

Create individual step modules that implement the universal step interface. Each step module follows the pattern described in the [Step Modules architecture section](#step-modules).

**Required step files:**
- **`steps/shipping.js`** - Email capture (LoginForm) and shipping address collection (AddressForm)
- **`steps/shipping-methods.js`** - Delivery method selection and cost calculation
- **`steps/payment-methods.js`** - Payment provider integration and method selection  
- **`steps/billing-address.js`** - Conditional billing address form rendering

**Implementation reference:**

For complete implementations of these step modules, see the sample files in the [demo repository](https://github.com/hlxsites/aem-boilerplate-commerce/tree/demos/blocks/commerce-checkout-multi-step/steps). Each file demonstrates the full step interface implementation with proper error handling, user flow logic, and integration with containers and APIs.
</Task>

<Task>
### Implement the steps manager

Create `steps.js` to coordinate all step logic and manage the checkout flow. Build this step by step:

<Steps>
1. **Set up the basic structure** with imports and function signature:

   ```javascript
   import { createShippingStep } from './steps/shipping.js';
   import { createShippingMethodsStep } from './steps/shipping-methods.js';
   import { createPaymentMethodsStep } from './steps/payment-methods.js';
   import { createBillingAddressStep } from './steps/billing-address.js';

   export default function createStepsManager(block) {
     // Implementation will go here
   }
   ```

2. **Create step instances** by gathering dependencies and instantiating each step module:

   ```javascript
   export default function createStepsManager(block) {
     const elements = getElements(block);
     const dependencies = { elements, api, events, ui };
     
     const steps = {
       shipping: createShippingStep(dependencies),
       shippingMethods: createShippingMethodsStep(dependencies),
       paymentMethods: createPaymentMethodsStep(dependencies),
       billingAddress: createBillingAddressStep(dependencies)
     };
   }
   ```

3. **Implement step coordination logic** that determines which step to show based on completion status:

   ```javascript
   async function handleCheckoutUpdated(data) {
     // Step 1: Shipping - always required
     if (!steps.shipping.isComplete(data)) {
       await steps.shipping.display(data);
       return;
     }
     await steps.shipping.displaySummary(data);

     // Step 2: Shipping Methods (skip for virtual products)
     if (!isVirtualCart(data)) {
       if (!steps.shippingMethods.isComplete(data)) {
         await steps.shippingMethods.display(data);
         return;
       }
       await steps.shippingMethods.displaySummary(data);
     }

     // Step 3: Payment Methods
     if (!steps.paymentMethods.isComplete(data)) {
       await steps.paymentMethods.display(data);
       return;
     }
     await steps.paymentMethods.displaySummary(data);

     // Step 4: Billing Address (if needed)
     if (!steps.billingAddress.isComplete(data)) {
       await steps.billingAddress.display(data);
       return;
     }
     await steps.billingAddress.displaySummary(data);
   }
   ```

4. **Wire up event handling** to respond to checkout state changes:

   ```javascript
   return {
     async init() {
       events.on('checkout/initialized', handleCheckoutUpdated);
       events.on('checkout/updated', handleCheckoutUpdated);
     }
   };
   ```
</Steps>

The steps manager uses the **early return pattern** - if a step is incomplete, it displays that step and exits. Only when all previous steps are complete does it move to the next step. This ensures proper linear progression through the checkout flow.
</Task>

<Task>
### Add CSS styling for step controls

Create the CSS that controls step visibility and progression. Add this to your `commerce-checkout-multi-step.css` file:

<Steps>
1. **Step visibility controls** - Define the core classes that show/hide step content:

   ```css
   /* Hide all step content by default */
   .checkout-step-content {
     display: none;
   }

   /* Show content when step is active */
   .checkout-step-active .checkout-step-content {
     display: block;
   }

   /* Hide summaries by default */
   .checkout-step-summary {
     display: none;
   }

   /* Show summaries when step is completed (not active) */
   .checkout-step:not(.checkout-step-active) .checkout-step-summary {
     display: block;
   }

   /* Hide continue buttons when step is completed */
   .checkout-step:not(.checkout-step-active) .checkout-step-button {
     display: none;
   }
   ```

2. **Step progression styling** - For complete visual styling (borders, colors, animations, etc.), see [`commerce-checkout-multi-step.css`](https://github.com/hlxsites/aem-boilerplate-commerce/tree/demos/blocks/commerce-checkout-multi-step/commerce-checkout-multi-step.css) in the demo repository.
</Steps>

These CSS rules create the core multi-step behavior: **content shows when active**, **summaries show when completed**, and **step progression controls** guide users through the checkout flow.
</Task>



## Example

See [`blocks/commerce-checkout-multi-step`](https://github.com/hlxsites/aem-boilerplate-commerce/tree/demos/blocks/commerce-checkout-multi-step) in the `demos` branch of the boilerplate repository for complete JS and CSS code for the multi-step checkout flow.

---

# Validate shipping address

Use the `AddressValidation` container to present both the original and suggested addresses from your verification service, letting shoppers choose before placing their order.

This tutorial shows how to integrate the container in the `commerce-checkout` block.


  ![Autocomplete shipping address](@images/dropins/checkout/address-validation.png/)


## Overview

At a high level:

- Call your address verification service before placing the order.
- If it returns a suggestion, open a modal and render `AddressValidation`.
- If the shopper selects the suggestion, persist it as the shipping address; otherwise, use the original address.

> **Note:** Code snippets reference boilerplate utilities like `showModal`, `removeModal`, and `renderAddressForm`. Adapt these to your application.

## Integration

```javascript
// in commerce-checkout.js block

// Handler passed to the PlaceOrder container
const handlePlaceOrder = async ({ cartId, code }) => {
  await displayOverlaySpinner(loaderRef, $loader);
  try {
    // Payment Services credit card
    if (code === PaymentMethodCode.CREDIT_CARD) {
      if (!creditCardFormRef.current) {
        console.error('Credit card form not rendered.');
        return;
      }
      if (!creditCardFormRef.current.validate()) {
        // Credit card form invalid; abort order placement
        return;
      }
      // Submit Payment Services credit card form
      await creditCardFormRef.current.submit();
    }

    // Address validation
    const suggestion = await validateAddress();
    if (suggestion) {
      const container = document.createElement('div');
      await showModal(container);
      await renderAddressValidation(container, {
        suggestedAddress: suggestion,
        handleSelectedAddress: async ({ selection, address }) => {
          if (selection === 'suggested') {
            await checkoutApi.setShippingAddress({ address });
            const latest = events.lastPayload('checkout/updated');
            // Unmount shipping address form and render again with latest checkout data
            unmountContainer(CONTAINERS.SHIPPING_ADDRESS_FORM);
            await renderAddressForm($shippingForm, shippingFormRef, latest, placeOrder, 'shipping');
          } else {
            // Place order
            await orderApi.placeOrder(cartId);
          }
          removeModal();
        },
      });
    } else {
      // Place order
      await orderApi.placeOrder(cartId);
    }
  } catch (error) {
    console.error(error);
    throw error;
  } finally {
    removeOverlaySpinner(loaderRef, $loader);
  }
};
```

```javascript
// in containers.js

/**
 * Renders the AddressValidation container in its own host element
 * @param {HTMLElement} container - DOM element to render into
 */
export const renderAddressValidation = async (
  container,
  { suggestedAddress, handleSelectedAddress },
) =>
  CheckoutProvider.render(AddressValidation, {
    suggestedAddress,
    handleSelectedAddress,
  })(container);
```

```javascript
// in utils.js (example stub)
export const validateAddress = async () => {
  // Hereâ€™s where your API call goes

  return {
    city: 'Bainbridge Island',
    countryCode: 'US',
    postcode: '98110-2450',
    region: 'CA',
    street: ['123 Winslow Way E'],
  };
};
```

Finally, add some padding for better appearance:

```css
/* commerce-checkout.css */
.modal-content .checkout-address-validation {
  padding: var(--spacing-big);
}
```

## Next steps

- See the [`AddressValidation` container](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/address-validation/) container for props and behaviors.
- Ensure your suggestion matches the `CartAddressInput` format.

---

# Checkout utility functions

This topic provides details and instructions for using the utility functions available in the checkout drop-in component. These functions were moved from the integration layer and are now publicly accessible within the checkout block from `@dropins/storefront-checkout/lib/utils.js`.

> **Note:** These utility functions are lightweight, performant, and easy to integrate into your checkout implementation. They handle common tasks including DOM manipulation, event handling, cart data processing, form validation, and address transformations.

### Quick imports

```ts
```

## API Functions

### setAddressOnCart

The `setAddressOnCart` function creates a debounced handler for setting shipping or billing addresses on the cart, preventing excessive API calls when address data changes frequently.

```ts
export function setAddressOnCart({
  type = 'shipping',
  debounceMs = 0,
  placeOrderBtn,
}: {
  type?: 'shipping' | 'billing';
  debounceMs?: number;
  placeOrderBtn?: RenderAPI;
}): (change: AddressFormChange) => void;
```



### Returns

Returns a function that accepts address form changes and updates the cart accordingly.

> **Note:** - The **Place Order** button is disabled during debounced address updates and re-enabled when the last pending call completes.

### Usage

```ts

// Set up debounced shipping address handler
const handleShippingChange = setAddressOnCart({
  type: 'shipping',
  debounceMs: 500,
  placeOrderBtn: placeOrderButtonAPI
});

// Use with form change events
shippingForm.addEventListener('input', (event) => {
  const formData = getFormValues(event.target.form);
  const isValid = validateForm(event.target.form);
  
  handleShippingChange({
    data: formData,
    isDataValid: isValid
  });
});
```

### estimateShippingCost

The `estimateShippingCost` function creates a debounced handler for estimating shipping costs based on address information.

```ts
export function estimateShippingCost({ debounceMs = 0 }): (change: AddressFormChange) => void;
```



### Returns

Returns a function that estimates shipping costs when address data changes.

> **Note:** - When the form becomes valid, the handler returns early without triggering estimation.
- Estimation only fires when country, region (code/id), or postcode values change from the previous estimation.

### Usage

```ts

// Set up shipping cost estimation
const handleEstimateShipping = estimateShippingCost({ debounceMs: 300 });

// Use with address form changes
addressForm.addEventListener('input', (event) => {
  const formData = getFormValues(event.target.form);
  const isValid = validateForm(event.target.form);
  
  handleEstimateShipping({
    data: formData,
    isDataValid: isValid
  });
});
```

## Cart Data Functions

### isVirtualCart

The `isVirtualCart` function checks if a cart contains only virtual products (no shipping required). If no argument is provided, it reads the latest checkout data.

```ts
export function isVirtualCart(data?: Cart | null): boolean;
```



### Returns

Returns `true` if the cart is virtual, `false` otherwise.

### Usage

```ts

// Check if shipping is required using explicit data
const cartData = await getCart();
const skipShipping = isVirtualCart(cartData);

// Or check using the latest checkout data
const skipShippingFromState = isVirtualCart();

if (skipShipping) {
  // Hide shipping-related UI
  document.querySelector('.shipping-section').style.display = 'none';
}
```

### isEmptyCart

The `isEmptyCart` function checks if a cart is empty or null.

```ts
export function isEmptyCart(data: Cart | null): boolean;
```



### Returns

Returns `true` if the cart is empty or null, `false` otherwise.

### Usage

```ts

const cartData = await getCart();

if (isEmptyCart(cartData)) {
  // Show empty cart message
  showEmptyCartMessage();
  return;
}

// Proceed with checkout
proceedToCheckout(cartData);
```

### getCartShippingMethod

The `getCartShippingMethod` function retrieves the selected shipping method from cart data.

```ts
export function getCartShippingMethod(data: Cart | null): ShippingMethod | null;
```



### Returns

Returns the selected shipping method object or `null` if none is selected.

### Usage

```ts

const cartData = await getCart();
const shippingMethod = getCartShippingMethod(cartData);

if (shippingMethod) {
  console.log(`Shipping: ${shippingMethod.title} - $${shippingMethod.amount.value}`);
}
```

### getCartAddress

The `getCartAddress` function retrieves shipping or billing address from cart data.

```ts
export function getCartAddress(
  data: Cart | null,
  type: 'shipping' | 'billing' = 'shipping'
): Record<string, any> | null;
```



### Returns

Returns the address object or `null` if no address is set.

### Usage

```ts

const cartData = await getCart();
const shippingAddress = getCartAddress(cartData, 'shipping');
const billingAddress = getCartAddress(cartData, 'billing');

if (shippingAddress) {
  populateAddressForm(shippingAddress);
}
```

### getCartPaymentMethod

The `getCartPaymentMethod` function retrieves the selected payment method from cart data.

```ts
export function getCartPaymentMethod(data: Cart | null): PaymentMethod | null;
```



### Returns

Returns the selected payment method object or `null` if none is selected.

### Usage

```ts

const cartData = await getCart();
const paymentMethod = getCartPaymentMethod(cartData);

if (paymentMethod) {
  console.log(`Payment method: ${paymentMethod.code}`);
}
```

## DOM and Fragment Functions

### createFragment

The `createFragment` function creates a `DocumentFragment` from an HTML string.

```ts
export function createFragment(html: string): DocumentFragment;
```



### Returns

Returns a DocumentFragment containing the parsed HTML.

### Usage

```ts

const html = `
  
    <h2>Payment Information</h2>
    <form class="payment-form">
      <!-- form fields -->
    </form>
  
`;

const fragment = createFragment(html);
document.querySelector('.checkout-container').appendChild(fragment);
```

### createScopedSelector

The `createScopedSelector` function creates a scoped `querySelector` function for a DocumentFragment.

```ts
export function createScopedSelector(
  fragment: DocumentFragment
): (selector: string) => HTMLElement | null;
```



### Returns

Returns a function that queries elements within the given fragment.

### Usage

```ts

const html = `
  
    <button class="next-btn">Next</button>
    <button class="prev-btn">Previous</button>
  
`;

const fragment = createFragment(html);
const $ = createScopedSelector(fragment);

// Query within the fragment only
const nextButton = $('.next-btn');
const prevButton = $('.prev-btn');

nextButton?.addEventListener('click', handleNext);
```

## Form Functions

### validateForm

The `validateForm` function validates a form by name using form references.

```ts
export function validateForm(
  formName: string,
  formRef: RefObject<FormRef>
): boolean;
```

<OptionsTable
  compact
  options={[
    ['Parameter', 'Type', 'Req?', 'Description'],
    ['formName', 'string', 'Yes', 'The name attribute of the form to validate.'],
    ['formRef', 'RefObject<FormRef>', 'Yes', 'Reference object to the form component.'],
  ]}
/>

### Returns

Returns `true` if the form is valid, `false` otherwise.

### Usage

```ts

// Validate checkout form before submission
const isShippingValid = validateForm('shipping-form', shippingFormRef);
const isBillingValid = validateForm('billing-form', billingFormRef);

if (isShippingValid && isBillingValid) {
  proceedToPayment();
} else {
  showValidationErrors();
}
```

## Meta Functions

### createMetaTag

The `createMetaTag` function creates or updates meta tags in the document head.

```ts
export function createMetaTag(property: string, content: string, type: string): void;
```



### Returns

The function does not return a value; it modifies the document head.

### Usage

```ts

// Set checkout-specific meta tags
createMetaTag('description', 'Complete your purchase securely', 'name');
createMetaTag('og:title', 'Checkout - Your Store', 'property');
```

### setMetaTags

The `setMetaTags` function sets standard meta tags for a drop-in component.

```ts
export function setMetaTags(dropin: string): void;
```



### Returns

The function does not return a value; it sets multiple meta tags.

### Usage

```ts

// Set meta tags for checkout page
setMetaTags('Checkout');
```

## Utility Functions

### scrollToElement

The `scrollToElement` function smoothly scrolls to and focuses on an HTML element.

```ts
export function scrollToElement(element: HTMLElement): void;
```



### Returns

The function does not return a value; it performs scrolling and focusing.

### Usage

```ts

// Scroll to error field
const errorField = document.querySelector('.field-error');
if (errorField) {
  scrollToElement(errorField);
}

// Scroll to next checkout step
const nextStep = document.querySelector('.checkout-step.active');
scrollToElement(nextStep);
```

## Data Transformer Functions

### transformAddressFormValuesToCartAddressInput

The `transformAddressFormValuesToCartAddressInput` function converts form data to cart address input format.

```ts
export const transformAddressFormValuesToCartAddressInput = (
  data: Record<string, any>
): ShippingAddressInput | BillingAddressInput;
```

<OptionsTable
  compact
  options={[
    ['Parameter', 'Type', 'Req?', 'Description'],
    ['data', 'Record<string, any>', 'Yes', 'Form data object containing address information.'],
  ]}
/>

### Returns

Returns a formatted address input object for cart API calls.

### Usage

```ts

// Transform form data for API
const formData = getFormValues(addressForm);
const addressInput = transformAddressFormValuesToCartAddressInput(formData);

// Send to cart API
await setShippingAddress(addressInput);
```

### transformCartAddressToFormValues

The `transformCartAddressToFormValues` function converts cart address data to the form values format.

```ts
export const transformCartAddressToFormValues = (
  address: CartAddress
): Record<string, any>;
```



### Returns

Returns a form-compatible object with address data.

### Usage

```ts

// Pre-populate form with existing address
const cartData = await getCart();
const shippingAddress = getCartAddress(cartData, 'shipping');

if (shippingAddress) {
  const formValues = transformCartAddressToFormValues(shippingAddress);
  populateForm(shippingForm, formValues);
}
```

## Common Usage Patterns

These utility functions work together to create robust checkout experiences:

### Complete Address Handling

```ts

// Set up address form handling
const handleAddressChange = setAddressOnCart({
  type: 'shipping',
  debounceMs: 500,
  placeOrderBtn: placeOrderAPI
});

// Pre-populate form with existing data
const cartData = await getCart();
const existingAddress = getCartAddress(cartData, 'shipping');
if (existingAddress) {
  const formValues = transformCartAddressToFormValues(existingAddress);
  populateAddressForm(formValues);
}

// Handle form changes
addressForm.addEventListener('input', (event) => {
  const formData = getFormValues(event.target.form);
  const isValid = validateForm('shipping-address', formRef);
  
  handleAddressChange({ data: formData, isDataValid: isValid });
});
```

### Cart State Management

```ts

function updateCheckoutUI(cartData) {
  // Handle empty cart
  if (isEmptyCart(cartData)) {
    showEmptyCartMessage();
    return;
  }
  
  // Handle virtual cart (no shipping)
  if (isVirtualCart(cartData)) {
    hideShippingSection();
  } else {
    const shippingMethod = getCartShippingMethod(cartData);
    updateShippingDisplay(shippingMethod);
  }
  
  // Update payment display
  const paymentMethod = getCartPaymentMethod(cartData);
  updatePaymentDisplay(paymentMethod);
}
```

### Dynamic Content Creation

```ts

function createCheckoutStep(stepHtml, stepName) {
  const fragment = createFragment(stepHtml);
  const $ = createScopedSelector(fragment);
  
  // Set up step-specific interactions
  const nextButton = $('.next-step');
  const prevButton = $('.prev-step');
  
  nextButton?.addEventListener('click', () => {
    if (validateCurrentStep()) {
      proceedToNextStep();
    } else {
      const errorField = $('.field-error');
      if (errorField) scrollToElement(errorField);
    }
  });
  
  return fragment;
}
```

---

# OrderStatus container

The `OrderStatus` container displays the current order status and a service message about the orderâ€™s condition. It supports three actions: Return, Cancel, and Reorder. The availability of these actions is defined by the backend, based on the order status, individual items, and global configurations.

To display all information, you must enable the following features:

- [Returns](https://experienceleague.adobe.com/en/docs/commerce-admin/stores-sales/order-management/returns/rma-configure)
- [Allow reorders](https://experienceleague.adobe.com/en/docs/commerce-admin/stores-sales/shopper-tools/reorders-allow)
- [Allow order cancellations](https://experienceleague.adobe.com/en/docs/commerce-admin/stores-sales/shopper-tools/cancel-allow)


  ![OrderStatus  container](@images/dropins/order/order-status.png/)


## Configurations

The `OrderStatus` container provides the following configuration options:



## Example

The following example demonstrates how to render the `OrderStatus` container:

```javascript
export default async function decorate(block) {
  await orderRenderer.render(OrderStatus, {
    routeCreateReturn: ({ token, number: orderNumber }) => {
      const isAuthenticated = checkIsAuthenticated();

      const { searchParams } = new URL(window.location.href);
      const orderRefFromUrl = searchParams.get('orderRef');
      const newOrderRef = isAuthenticated ? orderNumber : token;

      const encodedOrderRef = encodeURIComponent(orderRefFromUrl || newOrderRef);

      return checkIsAuthenticated() ? `${CUSTOMER_CREATE_RETURN_PATH}?orderRef=${encodedOrderRef}` : `${CREATE_RETURN_PATH}?orderRef=${encodedOrderRef}`;
    },
    routeOnSuccess: () => '/cart',
  })(block);
}
```

---

# CreateReturn container

The `CreateReturn` container manages the creation of return requests. It supports custom return attributes and configurable validation through the Adobe Commerce Admin. This container consists of three sequential screens that guide users through the item return process:

1. **Select Items.** The first screen displays a list of items eligible for return. The user can select items by checking the boxes next to them and specifying the quantity of each item they wish to return. Once the selection is complete, the user can click the **Continue** button to proceed to the next step.

  
  ![CreateReturn  container](@images/dropins/order/create-return1.png/)
  

1. **Return Reasons.** The second screen shows the selected items. Below each item, an additional form is displayed that allows the customer can specify the reason for the return. This step helps gather information on why each item is being returned, which can be valuable for analytics and improving customer experience.

  
  ![  container](@images/dropins/order/create-return2.png/)
  

1. **Success Screen.** The final screen displays a success message confirming the return process. It also includes a customizable button that allows redirection to any specified page on the website.

  
  ![  container](@images/dropins/order/create-return3.png/)
  

## Prerequisites

- [Returns must be enabled](https://experienceleague.adobe.com/en/docs/commerce-admin/stores-sales/order-management/returns/rma-configure). The **Stores** > Configuration > **Sales** > **Sales** > **RMA Settings** in the Adobe Commerce Admin.

- If you need to add custom return attributes, add them at **Stores** > **Attributes** > **Returns**. You can optionally use the Input Validation field to define custom validation rules.

## Configurations

The `CreateReturn` container provides the following configuration options:



## Example

The following example demonstrates how to render the `CreateReturn` container:

```javascript
export default async function decorate(block) {
  await orderRenderer.render(CreateReturn, {
    routeReturnSuccess: (orderData) =>
      checkIsAuthenticated()
        ? `${CUSTOMER_ORDER_DETAILS_PATH}?orderRef=${orderData.number}`
        : `${ORDER_DETAILS_PATH}?orderRef=${orderData.token}`,
  })(block);
}
```

---

# CustomerDetails container

The `CustomerDetails` container organizes customer and order information into the following sections:

- Contact details
- Shipping address
- Billing address
- Shipping method
- Payment method
- Return details:

The return details section is available exclusively on return pages. It provides information about the return.


  ![CustomerDetails  container](@images/dropins/order/customer-details.png/)


## Configurations

The `CustomerDetails` container provides the following configuration options:



## Example

The following example demonstrates how to integrate the `CustomerDetails` container:

```javascript
export default async function decorate(block) {
  await orderRenderer.render(CustomerDetails, {})(block);
}
```

---

# Order containers

Order containers display order history, shipment tracking, and returns. The following containers provide the building blocks for complete order management experiences.



| Container | Description |
|-----------|-------------|
| [CreateReturn](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/order/containers/create-return/) | Initiate return requests for eligible items. |
| [CustomerDetails](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/order/containers/customer-details/) | Customer information for the order. |
| [OrderCancelForm](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/order/containers/order-cancel-form/) | Request order cancellation. |
| [OrderCostSummary](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/order/containers/order-cost-summary/) | Pricing breakdown: subtotal, shipping, taxes, and total. |
| [OrderProductList](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/order/containers/order-product-list/) | Products in order with quantities and pricing. |
| [OrderReturns](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/order/containers/order-returns/) | Order returns and refund status. |
| [OrderSearch](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/order/containers/order-search/) | Search and find order history. |
| [ReturnsList](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/order/containers/returns-list/) | Return requests with status and details. |
| [ShippingStatus](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/order/containers/shipping-status/) | Shipping and delivery information with tracking. |

---

# OrderCancelForm container

The `OrderCancelForm` container provides a cancellation form that allows users to select reasons for canceling an order and perform the cancellation operation.


  ![OrderCancelForm container](@images/dropins/order/order-cancel-form.png/)


## Configurations

The `OrderCancelForm container provides the following configuration options:



## Example

The `OrderCancelForm` container is not directly integrated within the boilerplate, but it is delivered as part of the `OrderStatus` container. However, the `OrderCancelForm` container can also be used independently to create custom implementations.

Hereâ€™s an integration example from the drop-in component development environment:

```javascript
provider.render(OrderCancelForm, {
 orderRef: "",
 pickerProps: {} <PickerProps>,
 submitButtonProps: {} <ButtonProps>,
 cancelReasons: [] <PickerOption[]>,
})(containerWrapper);
```

---

# OrderCostSummary container

The `OrderCostSummary` container displays detailed order costs on the Order Details and Return Details pages. It includes the following sections:

- **Subtotal**: Displays the total cost of all items in the order before applying discounts, taxes, or additional charges.
- **Shipping**: Displays the shipping cost, which depends on the shipping method, location, and weight of the order.
- **Discount**: Displays any applicable discounts, such as promotional or volume-based offers, subtracted from the subtotal.
- **Coupon**: Displays the value of any applied coupons and their impact on the final cost.
- **Tax**: Displays the tax amount added to the order, calculated based on jurisdiction and item type.
- **Total**: Displays the final payable amount, including all adjustments such as discounts, shipping, and taxes.

If a value is not provided for any section (such as no discount or coupons are applied), the corresponding line is hidden. This ensures the container only displays relevant information.

The settings for displaying tax amounts can be configured at **Stores** > Configuration > **Sales** > **Tax** > **Order, Invoices, Credit Memos Display Settings**.


  ![OrderCostSummary  container](@images/dropins/order/order-cost-summary.png/)


## Configurations

The `OrderCostSummary` container provides the following configuration options:



## Example

The following example demonstrates how to render the `OrderCostSummary` container:

```javascript
export default async function decorate(block) {
  await orderRenderer.render(OrderCostSummary, {})(block);
}
```

---

# OrderProductList container

The `OrderProductList` container displays a list of products associated with a specific order or return. Each item in the list is represented by a product card containing details such as the price, applied discounts, tax information, final amount, and product attributes.

The settings for displaying tax amounts can be configured at **Stores** > Configuration > **Sales** > **Tax** > **Order, Invoices, Credit Memos Display Settings**.


  ![OrderProductList  container](@images/dropins/order/order-product-list.png/)


## Configurations

The `OrderProductList` container provides the following configuration options:



## Example

The following example demonstrates how to render the `OrderProductList` container:

```javascript
export default async function decorate(block) {
  await orderRenderer.render(OrderProductList, {
    routeProductDetails: (product) => `/products/${product.productUrlKey}/${product.product.sku}`,
  })(block);
}
```

---

# OrderReturns container

The `OrderReturns` container displays the list of returns associated with a specific order. Each return is presented with relevant details, such as return status and associated items. If no returns have been created for the order, the container is not rendered, ensuring that the interface remains clean and free of unnecessary placeholders.


  ![OrderReturns  container](@images/dropins/order/order-returns.png/)


## Configurations

The `OrderReturns` container provides the following configuration options:



## Example

The following example demonstrates how to render the `OrderReturns` container:

```javascript
export default async function decorate(block) {
  const isAuthenticated = checkIsAuthenticated();
  const returnDetailsPath = isAuthenticated
    ? CUSTOMER_RETURN_DETAILS_PATH
    : RETURN_DETAILS_PATH;

  await orderRenderer.render(OrderReturns, {
    routeTracking: ({ carrier, number }) => {
      if (carrier?.toLowerCase() === 'ups') {
        return `${UPS_TRACKING_URL}?tracknum=${number}`;
      }
      return '';
    },
    routeReturnDetails: ({ orderNumber, returnNumber, token }) => {
      const { searchParams } = new URL(window.location.href);
      const orderRefFromUrl = searchParams.get('orderRef');
      const newOrderRef = isAuthenticated ? orderNumber : token;

      const encodedOrderRef = encodeURIComponent(orderRefFromUrl || newOrderRef);

      return `${returnDetailsPath}?orderRef=${encodedOrderRef}&returnRef=${returnNumber}`;
    },
    routeProductDetails: (productData) => (productData ? `/products/${productData.product.urlKey}/${productData.product.sku}` : '#'),
  })(block);
}
```

---

# OrderSearch container

The `OrderSearch` container enables order searches using email, last name, and order number. It is available to both guest and registered users for quick access to order details.


  ![OrderSearch  container](@images/dropins/order/order-search.png/)


## Configurations

The `OrderSearch` container provides the following configuration options:



## Example

The following example demonstrates how to render the `OrderSearch` container:

```javascript
const renderSignIn = async (element, email, orderNumber) => authRenderer.render(SignIn, {
  initialEmailValue: email,
  renderSignUpLink: false,
  labels: {
    formTitleText: email
      ? 'Enter your password to view order details'
      : 'Sign in to view order details',
    primaryButtonText: 'View order',
  },
  routeForgotPassword: () => 'reset-password.html',
  routeRedirectOnSignIn: () => `${CUSTOMER_ORDER_DETAILS_PATH}?orderRef=${orderNumber}`,
})(element);

export default async function decorate(block) {
  block.innerHTML = '';

  events.on('order/data', async (order) => {
    if (!order) return;

    block.innerHTML = '';

    await orderRenderer.render(OrderSearch, {
      isAuth: checkIsAuthenticated(),
      renderSignIn: async ({ render, formValues }) => {
        if (render) {
          renderSignIn(
            block,
            formValues?.email ?? '',
            formValues?.number ?? '',
          );

          return false;
        }
        return true;
      },
      routeCustomerOrder: () => CUSTOMER_ORDER_DETAILS_PATH,
      routeGuestOrder: () => ORDER_DETAILS_PATH,
      onError: async (errorInformation) => {
        console.info('errorInformation', errorInformation);
      },
    })(block);
  });

  await orderRenderer.render(OrderSearch, {
    isAuth: checkIsAuthenticated(),
    renderSignIn: async ({ render, formValues }) => {
      if (render) {
        renderSignIn(block, formValues?.email ?? '', formValues?.number ?? '');

        return false;
      }

      return true;
    },
    routeCustomerOrder: () => CUSTOMER_ORDER_DETAILS_PATH,
    routeGuestOrder: () => ORDER_DETAILS_PATH,
    onError: async (errorInformation) => {
      console.info('errorInformation', errorInformation);
    },
  })(block);
}
```

---

# ReturnsList container

The `ReturnsList` container displays a complete list of all created returns available to the user. Each return card follows the same structure as the `OrderReturns` container, allowing consistent presentation of return details. It provides an overview of all return requests, enabling users to manage and track their status in one place.



  ![ReturnsList  container](@images/dropins/order/returns-list.png/)


## Configurations

The `ReturnsList` container provides the following configuration options:



## Example

The following example demonstrates how to render the `ReturnsList` container:

```javascript
export default async function decorate(block) {
  const {
    'minified-view': minifiedViewConfig = 'false',
  } = readBlockConfig(block);

  if (!checkIsAuthenticated()) {
    window.location.href = CUSTOMER_LOGIN_PATH;
  } else {
    await orderRenderer.render(ReturnsList, {
      minifiedView: minifiedViewConfig === 'true',
      routeTracking: ({ carrier, number }) => {
        if (carrier?.toLowerCase() === 'ups') {
          return `${UPS_TRACKING_URL}?tracknum=${number}`;
        }
        return '';
      },
      routeReturnDetails: ({ orderNumber, returnNumber }) => `${CUSTOMER_RETURN_DETAILS_PATH}?orderRef=${orderNumber}&returnRef=${returnNumber}`,
      routeOrderDetails: ({ orderNumber }) => `${CUSTOMER_ORDER_DETAILS_PATH}?orderRef=${orderNumber}`,
      routeReturnsList: () => CUSTOMER_RETURNS_PATH,
      routeProductDetails: (productData) => (productData ? `/products/${productData.product.urlKey}/${productData.product.sku}` : '#'),
    })(block);
  }
}
```

---

# ShippingStatus container

The `ShippingStatus` container displays information about shipments, including product images, the delivery service used, and tracking numbers. A separate block is rendered for each shipment created for the order. It also lists products that have not yet been shipped, providing a clear overview of the shipping status for all items.


  ![ShippingStatus  container](@images/dropins/order/shipping-status.png/)


## Configurations

The `ShippingStatus` container provides the following configuration options:



## Example

The following example demonstrates how to render the `ShippingStatus` container:

```javascript
export default async function decorate(block) {
  await orderRenderer.render(ShippingStatus, {
    routeTracking: ({ carrier, number }) => {
      if (carrier?.toLowerCase() === 'ups') {
        return `${UPS_TRACKING_URL}?tracknum=${number}`;
      }
      return '';
    },
    routeProductDetails: (data) => {
      if (data?.orderItem) {
        return `/products/${data?.orderItem?.productUrlKey}/${data?.orderItem?.product?.sku}`;
      }
      if (data?.product) {
        return `/products/${data?.product?.urlKey}/${data?.product?.sku}`;
      }
      return '#';
    },
  })(block);
}
```

---

# Order Dictionary

The default order dictionary file (`i18n/en_US.json`) contains the default values for all labels and text common to the order drop-in component.

## Default keys and values

---

# Order Data & Events

{/*
  âš ï¸ TEMPLATE USAGE GUIDE âš ï¸
  
  This template is used by scripts/generate-events-docs.js to generate event documentation.
  
  WHAT THE SCRIPT USES FROM THIS TEMPLATE:
  - Section headings and descriptive text (used as-is)
  - Import statements
  - The REPEAT_FOR_EACH_EVENT block (replicated for each event)
  - Placeholders: Order, Order, EVENT_NAME, etc.
  
  WHAT THE SCRIPT GENERATES INDEPENDENTLY:
  - Table contents between START/END markers (example rows are for reference only)
  - Event-specific data (names, descriptions, payloads from source repos)
  
  TO CHANGE:
  - Section text/descriptions â†’ Edit this template
  - Table structure (columns, links, formatting) â†’ Edit scripts/generate-events-docs.js
  - Both template and script must be kept in sync for table structure changes
*/}


The **Order** drop-in uses the [event bus](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/) to emit and listen to events for communication between drop-ins and external integrations. For common events shared across multiple drop-ins (such as `locale`, `error`, `authenticated`, etc.), see the [Common events reference](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/#common-events-reference).


<strong>Version: 1.4.0</strong>


> **Note:** **New to drop-in events?** Learn about the [event system architecture](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/), including the publish-subscribe pattern, subscription configuration, and best practices for event handling.

## Events reference

{/* EVENTS_TABLE_START */}


| Event | Direction | Description |
|-------|-----------|-------------|
| [cart/reset](#cartreset-emits) | Emits | Emitted when the component state is reset |
| [order/error](#ordererror-emits) | Emits | Emitted when an error occurs |
| [order/placed](#orderplaced-emits) | Emits | Emitted when an order is placed |
| [order/data](#orderdata-emits-and-listens) | Emits and listens | Triggered when data is available or changes |


{/* EVENTS_TABLE_END */}

## Event details

The following sections provide detailed information about each event, including its direction, data payload structure, and usage examples.


### `cart/reset` (emits)

Emitted when the component state is reset

#### Data payload

```typescript
void
```



#### Usage

Listen to this event in your storefront:

```javascript

const cartResetListener = events.on('cart/reset', (data) => {
  console.log('cart/reset event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
cartResetListener.off();
```

### `order/data` (emits and listens)

Triggered when data is available or changes

#### Data payload

```typescript
OrderDataModel
```



#### Usage

Listen to this event in your storefront:

```javascript

const orderDataListener = events.on('order/data', (data) => {
  console.log('order/data event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
orderDataListener.off();
```

### `order/error` (emits)

Emitted when an error occurs

#### Data payload

```typescript
{ source: string; type: string; error: Error | string }
```

| Property | Type | Description |
|----------|------|-------------|
| `source` | `string` | See type definition in source code |
| `type` | `string` | See type definition in source code |
| `error` | `Error \| string` | See type definition in source code |


#### Usage

Listen to this event in your storefront:

```javascript

const orderErrorListener = events.on('order/error', (data) => {
  console.log('order/error event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
orderErrorListener.off();
```

### `order/placed` (emits)

Emitted when an order is placed

#### Data payload

```typescript
OrderDataModel
```



#### Usage

Listen to this event in your storefront:

```javascript

const orderPlacedListener = events.on('order/placed', (data) => {
  console.log('order/placed event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
orderPlacedListener.off();
```

---

# Order functions

The Order drop-in component provides the following API endpoints, allowing developers to perform various account-related operations and create custom implementations:

## cancelOrder

The `cancelOrder` function is a wrapper for the [`cancelOrder`](https://developer.adobe.com/commerce/webapi/graphql/schema/orders/mutations/cancel-order/) mutation. You must pass an order ID and reason,

```ts
export const cancelOrder = async (
  orderId: string,
  reason: string,
  onSuccess: Function,
  onError: Function
): Promise<void | null | undefined>
```



### Returns

Returns a promise that resolves to a void, null, or undefined value.

### Usage

```js
cancelOrder(
  {
    orderId: '12345',;
    reason: 'I don't like the color;
  }
)
```

## confirmCancelOrder 

The `confirmCancelOrder` function confirms the cancellation of an order after the guest user clicks on a URL provided in an order cancellation confirmation email. The confirmation key is generated when the guest requests to cancel an order.

```ts
confirmCancelOrder(
    orderId: string,
    confirmationKey: string
): Promise<OrderDataModel>;
```



### Returns

Returns a promise that resolves to an `OrderDataModel` object.



### Usage

```js

const orderId = '12345';
const confirmationKey = 'abcde12345';

confirmCancelOrder(orderId, confirmationKey)
  .then(response => {
    console.log('Order cancellation confirmed:', response);
  })
  .catch(error => {
    console.error('Error confirming order cancellation:', error);
  });
```

## getAttributesForm 

The `getAttributesForm` function is a wrapper for the [`attributesForm`](https://developer.adobe.com/commerce/webapi/graphql/schema/attributes/queries/attributes-form/) query. You must pass an attribute code to retrieve the form.

```ts
export const getAttributesForm = async (
  formCode: string
): Promise<AttributesFormModel[]>
```



### Returns

Returns a promise that resolves to an array of `AttributesFormModel` objects.

```ts
export interface AttributesFormItemsProps {
  code?: string;
  name?: string;
  id?: string;
  required?: boolean;
  label?: string;
  options?: { is_default: boolean; label: string; value: string }[];
  entityType?: string;
  className?: string;
  defaultValue?: string | boolean | number;
  fieldType?: FieldEnumList;
  multilineCount?: number;
  isUnique?: boolean;
  orderNumber: number;
  isHidden?: boolean;
  customUpperCode: string;
  validateRules: Record<string, string>[];
}

export interface AttributesFormModel extends AttributesFormItemsProps {}
```

### Usage

```ts
getAttributesForm(formCode: 'customer_address_edit');
```

## getAttributesList

The `getAttributesList` function is a wrapper for the [`attributesList`](https://developer.adobe.com/commerce/webapi/graphql/schema/attributes/queries/attributes-list/) query. You must pass an attribute code to retrieve the list. The system default values are `CUSTOMER`, `CUSTOMER_ADDRESS`, `CATALOG_PRODUCT` and `RMA_ITEM`.

```ts
export const getAttributesList = async (
  entityType: string
): Promise<AttributesFormModel[] | []>
```



### Returns

Returns a promise that resolves to an array of `AttributesFormModel` objects or an empty array.

```ts
export interface AttributesFormItemsProps {
  code?: string;
  name?: string;
  id?: string;
  required?: boolean;
  label?: string;
  options?: { is_default: boolean; label: string; value: string }[];
  entityType?: string;
  className?: string;
  defaultValue?: string | boolean | number;
  fieldType?: FieldEnumList;
  multilineCount?: number;
  isUnique?: boolean;
  orderNumber: number;
  isHidden?: boolean;
  customUpperCode: string;
  validateRules: Record<string, string>[];
}

export interface AttributesFormModel extends AttributesFormItemsProps {}
```

### Usage

```ts
getAttributesList(entityType: 'RMA_ITEM');
```

## getCustomer

The `getCustomer` function is a wrapper for the [`customer`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/customer/) query. You must pass a customer ID to retrieve the customer data.

```ts
export const getCustomer = async (): Promise<CustomerDataModelShort>
```
### Returns

Returns a promise that resolves to a `CustomerDataModelShort` object.

```ts
export interface CustomerDataModelShort {
  firstname: string;
  lastname: string;
  email: string;
}
```

### Usage

```ts
getCustomer();
```
## getCustomerOrdersReturn

The `getCustomerOrdersReturn` function returns details about the returns a customer has requested. It is a wrapper for the [`customer`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/customer/) query.

```ts
export const getCustomerOrdersReturn = async (
  pageSize = 10
): Promise<CustomerOrdersReturnModel | null>
```



### Returns

Returns a promise that resolves to a `CustomerOrdersReturnModel` object or null.

```ts 
export interface CustomerOrdersReturnModel {
  ordersReturn: OrdersReturnPropsModel[];
  pageInfo?: PageInfoProps;
}

export interface OrdersReturnItemsPropsModel extends OrderItemModel {
  quantity: number;
  requestQuantity: number;
  status: string;
  uid: string;
}

export interface PageInfoProps {
  pageSize: number;
  totalPages: number;
  currentPage: number;
}
```

### Usage

The following example demonstrates how to retrieve a customer's return orders:

```ts
getCustomerOrdersReturn();
```

## getGuestOrder

The `getGuestOrder` function is a wrapper for the [`guestOrder`](https://developer.adobe.com/commerce/webapi/graphql/schema/orders/queries/guest-order/) query.

```ts
export const getGuestOrder = async (form: {
  number: string;
  email: string;
  lastname: string;
}): Promise<OrderDataModel | null>
```



### Returns

Returns a promise that resolves to an `OrderDataModel` object or null.



### Usage

The following example demonstrates how to retrieve a guest order:

```ts
getGuestOrder({
  number: '12345',
  email: 'jdoe@example.com',
  lastname: 'Doe'
});
```

## getOrderDetailsById

The `getOrderDetailsById` function is a wrapper for the [`customer`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/customer/) query. You must pass an order ID to retrieve the order details.

```ts
export const getOrderDetailsById = async <T extends QueryType>({
  orderId,
  returnRef,
  queryType,
  returnsPageSize = 50,
}: GetOrderDetailsByIdProps): Promise<TransformedData<T>>
```



### Returns

Returns a promise that resolves to a `TransformedData` object.

### Usage

type QueryType = 'orderData';

```ts
getOrderDetailsById(
  orderId?: string;
  queryType: QueryType;
);
```

## getStoreConfig

The `getStoreConfig` function returns information about the storefront configuration. It is a wrapper for the [`storeConfig`](https://developer.adobe.com/commerce/webapi/graphql/schema/store/queries/store-config/) query.

```ts
export const getStoreConfig = async (): Promise<StoreConfigModel | null>
```

### Returns

Returns a promise that resolves to a `StoreConfigModel` object or null.

```ts
type StoreConfigModel = {
  order_cancellation_enabled: boolean;
  order_cancellation_reasons: {
    description: string;
  };
};
```

### Usage

The following example demonstrates how to retrieve the store configuration:

```ts
getStoreConfig();
```

## guestOrderByToken

The `guestOrderByToken` function retrieves a guest order using a token generated by Adobe Commerce. It is a wrapper for the `guestOrderByToken` query.

```ts
export const guestOrderByToken = async (
  token?: string,
  returnRef?: string
): Promise<OrderDataModel | null>
```



### Returns

Returns a promise that resolves to an `OrderDataModel` object or null.



### Usage

```ts
guestOrderByToken(token:'abcde12345');
```

## reorderItems

The `reorderItems` function allows a logged-in customer to add all the products from a previous order into their cart. It is a wrapper for the [`reorderItems`](https://developer.adobe.com/commerce/webapi/graphql/schema/orders/mutations/reorder-items/) mutation.

```ts
export const reorderItems = async (
  orderNumber: string
): Promise<ReorderItemsProps>
```



### Returns

Returns a promise that resolves to a `ReorderItemsProps` object.

```ts
export interface ReorderItemsResponse {
  data: {
    reorderItems: {
      cart: {
        itemsV2: {
          items: { uid: string }[];
        };
      };
      userInputErrors: UserInputErrorProps[];
    };
  };

  errors?: {
    message: string;
  }[];
}
```

### Usage

The following example demonstrates how to reorder items from a previous order:

```ts
reorderItems(orderNumber: string);
```

## requestGuestOrderCancel

The `requestGuestOrderCancel` function is simmilar to the `cancelOrder` function, but it is used for guest orders.
The token is a unique value generated using guest's email, order number and postcode

```ts
export const requestGuestOrderCancel = async (
  token: string,
  reason: string,
  onSuccess: Function,
  onError: Function
): Promise<void> 
```



### Returns

Returns a promise that resolves to a boolean value.

### Usage

```ts
requestGuestOrderCancel(
  {
    token: `abcde12345`,;
    reason: `It is too big`;
  }
): boolean
```

## requestReturn

The `requestReturn` function takes the `RequestReturnProps` form as an argument and initiates the process of returning items from an order. It is a wrapper for the [`requestReturn`](https://developer.adobe.com/commerce/webapi/graphql/schema/orders/mutations/request-return/) mutation.

```ts
export const requestReturn = async (
  form: RequestReturnProps
): Promise<{
  uid: string;
  number: string;
  status: string;
  createdAt: string;
}>
```



The `RequestReturnProps` object has the following properties:

```ts
export interface RequestReturnProps {
  orderUid: string;
  contactEmail: string;
  items: {
    orderItemUid: string;
    quantityToReturn: number;
    selectedCustomAttributes?: { attribute_code: string; value: string }[];
    enteredCustomAttributes?: { attribute_code: string; value: string }[];
  }[];
}
```

### Returns

Returns a promise that resolves to an object containing the return request details.

### Usage

```ts
requestReturn(token:'abcde12345');
```

---

# Order overview

The order drop-in component provides a comprehensive set of tools and containers designed to manage and display order-related data across various pages and scenarios. It simplifies the implementation of order management functionality and supports seamless integration with both customer accounts and guest user workflows.

## Architecture

The order drop-in component consists of multiple containers that display order details on different pages, such as:

- Order data containers display order details within the customer account, guest user areas, and on the order confirmation page.
- Returned merchandise authorization (RMA) containers guide users through the return process and display a list of created return requests.
- The `OrderSearch` container enables guest users to locate their orders using a combination of email, ZIP code, and order number. This ensures easy access to order details even for users without an account. (Logged-in customers can also use this form.)

The component's initialization process helps manage data retrieval and event emission, ensuring that containers receive the necessary data without individual fetching.

This modular architecture allows for efficient, reusable, and highly customizable implementations of order and return workflows, making it ideal for both standard and advanced e-commerce use cases. In addition, the order/return details pages implementation includes elements like the headers, which are implemented at the boilerplate level rather than provided directly by the drop-in containers. These elements, including `commerce-order-header` and `commerce-return-header` blocks, are covered as part of the overall framework for order/return details layouts, but are distinct from the drop-in container set.

The following diagrams provide a visual composition of the order details and return details pages:


  ![Order details containers](@images/dropins/order/order-details-containers.png/)



  ![Return details containers](@images/dropins/order/return-details-containers.png/)


## Supported Commerce features

The following table provides an overview of the Adobe Commerce guest user features that the order component supports:

| Feature                                                          | Status                                     |
| ---------------------------------------------------------------- | ------------------------------------------ |
| Cancel order (with email confirmation)                           |    |
| Create a return                                                  |    |
| Filter orders by time of purchase                                |    |
| Reorder                                                          |    |
| Search orders                                                    |  |
| View list of orders on the account                               |    |
| View order status                                                |    |
| View return status                                               |    |

---

# Order initialization

The order drop-in component initializer provides options for configuring language definitions and extending the default models with new fields and transformers.

The initialization code is located in the `/scripts/initializers/order.js` file of the boilerplate.

## Configuration options

The initialization process relies on several key parameters to handle automated redirects and initialize components under different conditions, such as handling errors during order data fetching. Containers within the order drop-in DO NOT fetch data themselves. Instead, they listen for the `order/data` event and use the received order data for initialization. This applies to both order and return pages.



The following code shows an example implementation of the order initializer configuration:

```js
await initializers.mountImmediately(initialize, {
    langDefinitions,
    orderRef,
    returnRef,
});
```
## Redirection

The following outlines the current redirect behaviors handled within initialization code. The constants referenced below are defined in the `/scripts/constants.js` file within the boilerplate setup:

### Page loads

The authentication status of the user factors into how the page is loaded.

#### Authenticated users

If the user is authenticated and no `orderRef` URL parameter is provided, redirect to CUSTOMER_ORDERS_PATH.

Otherwise, the type of page determines the redirect behavior.

On an account page (the `pathname` includes `CUSTOMER_PATH`):

- If the `orderRef` URL parameter is provided with a valid token, redirect to `${ORDER_DETAILS_PATH}?orderRef={orderRef}`.

- If no valid token is provided in the `orderRef` URL parameter, proceed without a redirect.

On all other pages:

- If an `orderRef` URL parameter is provided with a valid token, proceed without a redirect.

- If a valid token is not provided in the `orderRef` URL parameter, redirect to `${CUSTOMER_ORDER_DETAILS_PATH}?orderRef={orderRef}`.

#### Unauthenticated users

If the user is not authenticated:

- If the `orderRef` URL parameter is provided, proceed without a redirect.

- If no `orderRef` URL parameter is provided, redirect to ORDER_STATUS_PATH.

### Error handling

An `order/error` event is emitted when an error occurs during order data fetching. The event listener redirects the user based on the following conditions:

- If the user is authenticated, redirect to CUSTOMER_ORDERS_PATH.

- If the user is not authenticated, then the behavior depends on the presence of an `orderRef` URL parameter:

  - If it is present, along with a valid order token, redirect to ORDER_STATUS_PATH.
  - Otherwise, redirect to ORDER_STATUS_PATH with the `orderRef` parameter from the current URL.

## Initialization example

Import /scripts/initializers/order.js into the appropriate file, as shown in the initialization of the `commerce-order-product-list` block:

```js
/* eslint-disable import/no-unresolved */
/* eslint-disable import/no-extraneous-dependencies */

// Initialize

export default async function decorate(block) {
 await orderRenderer.render(OrderProductList, {
   routeProductDetails: (product) => `/products/${product.productUrlKey}/${product.product.sku}`,
 })(block);
}
```

---

# Order slots

This topic describes the slots that are provided in the order drop-in component.

[Extending drop-in components](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/extending/) describes the default properties available to all slots.

## CreateReturn slots

The `CreateReturn` container provides slots for customizing the process of initiating a return.

### ReturnOrderItem

The `ReturnOrderItem` slot renders additional information for return items.

```js
slots: {
 ReturnOrderItem: (ctx) => {
   const container = document.createElement('div');
   container.insertAdjacentHTML(
     'afterbegin',
     `
       
         <h2 class="info-heading">Product Details</h2>
         <ul class="info-list">
           <li class="info-item">Detail 1: Placeholder information about the product.</li>
           <li class="info-item">Detail 2: Additional placeholder information about the product.</li>
         </ul>
       
     `
   );
   ctx.appendChild(container);
 }
}
```

### ReturnFormActions

The `ReturnFormActions` slot renders custom return form actions.

```js
slots: {
 ReturnFormActions: (ctx) => {
   const container = document.createElement('div');

   provider.render(Button, {
     variant: 'secondary',
     children: 'Get a Better Offer',
     onClick: () => alert('Custom event listener!'),
   })(container);
   ctx.appendChild(container);
 },
}
```

## CustomerDetails slots

The `CustomerDetails` container provides slots for customizing the customer details section on the order details page.

### OrderReturnInformation slot

The `OrderReturnInformation` slot renders custom elements in the return information section on the return details page.

```js
slots: {
 OrderReturnInformation: (ctx) => {
   const container = document.createElement('div');

   provider.render(TextArea, {
     children: 'Custom Action Button',
     required: true,
     name: 'custom_text_area',
     label: 'Custom User information',
     disabled: true,
     onChange: (event) => {
       console.log('event', event);
     },
   })(container);

   ctx.appendChild(container);
 }
}
```

### PaymentMethodIcon

The `PaymentMethodIcon` slot renders custom elements based on the selected payment method on the order details page.

```js
slots: {
 PaymentMethodIcon: (ctx) => {
   const { selectedPaymentMethodCode } = ctx;

   const container = document.createElement('div');

   let iconMarkup = '';
   switch (selectedPaymentMethodCode) {
     case 'credit_card':
       iconMarkup = `Credit Card Icon`;
       break;
     case 'paypal':
       iconMarkup = `PayPal Icon`;
       break;
     case 'bank_transfer':
       iconMarkup = `Bank Transfer Icon`;
       break;
     default:
       iconMarkup = `Default Icon`;
   }

   container.insertAdjacentHTML(
     'afterbegin',
     `
       
         ${iconMarkup}
       
     `
   );

   ctx.appendChild(container);
 }
}
```

## OrderReturns slots

The `OrderReturns` container provides slots that customize elements in the order returns section on the order details page.

### DetailsActionParams slot

The `DetailsActionParams` slot renders custom actions for each return in the order returns section of the order details page.

```js
slots: {
 DetailsActionParams: (ctx) => {
   const {
     returnOrderItem: { returnNumber },
   } = ctx;

   const container = document.createElement('div');

   container.insertAdjacentHTML(
     'afterbegin',
     `
       
         <a
           href="https://example.com/returns/${returnNumber}"
           class="details-link"
         >Return Details</a>
         <button
           class="cancel-return-button"
           onclick="console.log('Cancel return callback placeholder')"
         >Cancel Return</button>
       
     `
   );

   ctx.appendChild(container);
 }
}
```

### ReturnItemsDetails slot

The `ReturnItemsDetails` slot renders additional details for each return in the order returns section of the order details page.

```js
slots: {
 ReturnItemsDetails: (ctx) => {
   const { items } = ctx;
   const container = document.createElement('div');

   const itemStatus = items?.[0]?.customStatus || 'No status available';

   container.innerHTML = `Custom return status: ${itemStatus}`;
   ctx.appendChild(container);
 }
}
```

### OrderStatus slot

The `OrderStatus` slot renders custom order status elements on the order details page.

## DeliveryTimeLine

The `DeliveryTimeLine` slot renders a custom stepper to track delivery progress.

```js
slots: {
 DeliveryTimeLine: (ctx) => {
   const container = document.createElement('div');

   container.insertAdjacentHTML(
     'afterbegin',
     `
      
        <div class="step">
          <div class="step-marker">
          Order Placed
        </div>
        
          <div class="step-marker">
          Shipped
        </div>
        
          <div class="step-marker">
          Out for Delivery
        </div>
        
          <div class="step-marker">
          Delivered
        </div>
      </div>
    `
   );

   ctx.appendChild(container);
 }
}
```

### DeliveryTrackActions slot

The `DeliveryTrackActions` slot renders custom delivery tracking actions.

```js
slots: {
 DeliveryTrackActions: (ctx) => {
   const {
     trackInformation: { number, title },
   } = ctx;

   const container = document.createElement('div');

   container.insertAdjacentHTML(
     'afterbegin',
     `
       
         ${title}
       
     `
   );

   ctx.appendChild(container);
 }
}
```

### ReturnItemsDetails

The `ReturnItemsDetails` slot renders additional return details in the shipping status container on the return details page.
  
  ```js
slots: {
 ReturnItemsDetails: (ctx) => {
   const { items } = ctx;
   const container = document.createElement('div');
   container.classList.add('return-items-details');

   items.forEach(({ quantity, requestQuantity, status, uid }) => {
     const html = `
       
         <h3 class="return-status">${status}</h3>
         <p class="return-request-quantity">Requested: ${requestQuantity}</p>
         <p class="return-quantity">Quantity: ${quantity}</p>
         <a href="#" class="return-info-link">More information about the return</a>
       
     `;
     container.insertAdjacentHTML('beforeend', html);
   });

   ctx.appendChild(container);
 }
}
```

---

# Order styles

The CSS classes for each UI component that provides the order drop-in component with its UI are provided here. Override these classes and add new classes to customize the look and feel of your cart to match your specific style requirements.

[Styling drop-in components](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/styling/) describes how to inspect the drop-in component in your browser's developer tools to discover the BEM class names to be extended.

## Example CSS overrides

Here's an example of adding CSS class overrides to your default order CSS files:

```css title="order.css"
.order-return-order-message .order-return-order-message__title {
  font: var(--type-headline-2-font);
  letter-spacing: var(--type-headline-2-letter-spacing);
}

.order-return-reason-form .dropin-cart-item {
  margin-bottom: var(--spacing-small);
}

.order-return-reason-form form .dropin-field {
  margin-bottom: var(--spacing-small);
}
```

## Order component CSS

The CSS classes for each order component are provided here.

---

# Order Cancellation

The order drop-in component enables both logged in and guest users to cancel an order.

## Big picture

The order cancellation workflow is as follows:



1. The shopper selects an order to cancel. Guest users must use the order search form to locate the order. Logged-in customers can select an order from their order history or use the search form.

1. The shopper submits the cancellation form after selecting a cancellation reason.

1. If the shopper is a logged-in customer, the order is `Canceled` immediately. Otherwise, the order status remains `Pending` until the guest clicks a link in a confirmation email.



## Prerequisites

Adobe Commerce must be configured to allow order cancellations. In the Admin, go to **Stores** > Configuration > **Sales** > **Sales** > **Order Cancellation** and set the following options:




  ![Order cancellation configuration options](@images/dropins/order/cancellation-prerequisites.png/)


## Step-by-step

The following steps describe how to implement the order cancellation workflow for both logged in customers and guests.



<Task>

### Display the order history (logged-in customers only)

The workflow for logged-in customers is straightforward. An order can be canceled only if it has a status of `Received`, `Pending`, or `Processing`.

<Aside>
  The logged-in customer can also use the order search form to locate the order. See [Search for the order](#search-for-the-order) for this use case.
</Aside>

The customer selects an active order from their order history to cancel.

<Diagram caption="Order history">
  ![Order history](@images/dropins/order/cancellation-order-history.png/)
</Diagram>

The order history page uses the `OrderProductListContent` component to render the list of orders that the customer previously placed. It iterates over the list of orders and uses the `CartSummaryItem` component to render each order item. The order item is an instance of the `OrderItemModel`, which contains all the necessary properties of an order item.

The following example shows an implementation of the `OrderProductListContent` component:

```jsx
...
<ul className="order-order-product-list-content__items">
  {item.list?.map((product: OrderItemModel) => (
    <li
      data-testid="order-product-list-content-item"
      key={product.id}
    >
      
    </li>
  ))}
</ul>
...
```

</Task>

<Task>

### Search for the order

A guest user does not have access to the order history page. Therefore, the only way to access an order is by using the Order Search form. The search order form retrieves the order that matches the specified email address, last name, and order name, as shown below:

<Diagram caption="Order cancellation form">
  ![Order cancellation form](@images/dropins/order/cancellation-form.png/)
</Diagram>

The `OrderSearchForm` component is responsible for rendering the form to search for an order.
It receives the following parameters:


See the following code for an example of the implementation:

```jsx
...
{inLineAlert.text ? (
  }
  />
) : null}

<Form
  className={'order-order-search-form__wrapper'}
  name="orderSearchForm"
  loading={loading}
  fieldsConfig={fieldsConfig}
  onSubmit={onSubmit}
>
  <div className="order-order-search-form__button-container">
    <Button
      className={'order-order-search-form__button'}
      size={'medium'}
      variant={'primary'}
      key={'logIn'}
      type={'submit'}
      disabled={loading}
    >
      
    </Button>
  </div>
</Form>
...
```

</Task>

<Task>

### Render and submit the cancellation form

The cancellation form allows the customer to select a cancellation reason and submit the form.

<Diagram caption="Order cancellation form">
  ![Order cancellation form](@images/dropins/order/cancellation-form.png/)
</Diagram>

The `OrderCancel` component renders the `OrderCancelForm` container inside a modal.
This modal receives two parameters:



For example:

```jsx
...
<Modal
  centered={true}
  size="medium"
  onClose={handleClose}
  className={'order-order-cancel__modal'}
  title={
    <h2 className={'order-order-cancel__title'}>
      
    </h2>
  }
  data-testid="order-cancellation-reasons-modal"
>

</Modal>
...
```

The `OrderCancelForm` component is responsible for:

- Rendering the form with multiple cancellation reasons and a submission button.
- Handling the form submission.
- Showing the appropriate error messages if a failure occurs after submitting the form.

```jsx
...
{isErrorVisible && (
  
)}
<div className="order-order-cancel-reasons-form__text">
  
</div>

<div className="order-order-cancel-reasons-form__button-container">
  <Button
    variant="primary"
    data-testid="order-cancel-submit-button"
    {...submitButtonProps}
  >
    
  </Button>
</div>
...
```

</Task>

<Task>

### Display the confirmation notice

When a logged-in customer submits the cancellation form, Commerce immediately sets the status of the order to `Canceled` and the drop-in displays a confirmation notice.

<Diagram caption="Confirmation for logged-in users.">
  ![Confirmation for logged-in users](@images/dropins/order/cancellation-performed.png/)
</Diagram>

If the shopper is a guest user, the drop-in displays the following dialog:

<Diagram caption="Guest user is notified that cancellation has been requested.">
  ![Cancellation has been requested for a guest user](@images/dropins/order/cancellation-requested.png/)
</Diagram>

The order status remains `Pending` until the shopper clicks the link in an email similar to the following to confirm the cancellation.

<Aside type="choose" title="Confirm Your Main Website Store Order Cancellation">
It seems that you'd like to cancel your order #000000001. If this is correct, please _click here_ to confirm your cancellation request.

If you have questions about your order, you can email us at _support@example.com_.

</Aside>

Once clicked, the order becomes `Canceled` and the order status page is updated accordingly.

The order status page uses the `OrderStatusContent` component to render the order with all its properties and the available actions.

See the following code for an example of the `OrderStatusContent` implementation below:

```jsx
...
<Card className="order-order-status-content" variant="secondary">
  
  <div className="order-order-status-content__wrapper">
    <div
      className={classes([
        'order-order-status-content__wrapper-description',
        [
          'order-order-status-content__wrapper-description--actions-slot',
          !!slots?.OrderActions,
        ],
      ])}
    >
      <p>{isReturnPage ? returnMessage : orderMessage}</p>
    </div>
    
  </div>
</Card>
...
```

After performing any action, the order status page is re-rendered, so that it reflects the new status and the available actions. The appropriate message is shown to the user, depending on the action performed.

</Task>

---

# CreditCard container

The `CreditCard` container allows a shopper to enter credit card details during the checkout process. You can configure it to manage and display the credit card fields.

## CreditCard configurations

The `CreditCard` container provides the following configuration options:

<OptionsTable
  compact
  options={[
    ['Option', 'Type', 'Req?', 'Description'],
    ['apiUrl', 'string', 'Yes', 'The URL to the Adobe Commerce GraphQL endpoint, such as "https://example.com/graphql".'],
    ['getCartId', 'function', 'Yes', 'Should return a promise that resolves to the shopper`s cart ID.'],
    ['getCustomerToken', 'function', 'Yes', 'The credit card container may send GraphQL requests on behalf of the shopper. This requires GraphQL authorization, which can be performed using authorization tokens or session cookies. For token-based authorization, the "getCustomerToken" function should return a customer token as a string, or null for guest checkouts. For session-based authorization, the "getCustomerToken" property must explicitly be set to "null".'],
    ['creditCardFormRef', 'object', 'Yes', 'Credit card form reference. Initially, { current: null } should be passed. Once rendered, the credit card container will set the "current" property to an { validate: () => boolean; submit: () => Promise<void> } object, which parent containers can use to (programmatically) validate and submit the credit card form.'],
    ['onSuccess', 'function', 'No', 'Called when the payment flow finishes successfully. This function is not passed any arguments.'],
    ['onError', 'function', 'No', 'Called when the payment flow was aborted due to an error. The function receives a single argument, {message: string}, containing the reason of error.'],
  ]}
/>

## Example

The following example shows how to render and submit a credit card form.

```js

const commerceCoreEndpoint = await getConfigValue('commerce-core-endpoint');
const $content = document.createElement('div');
const creditCardFormRef = { current: null };
const placeOrderButton = document.getElementById('place-order');

PaymentServices.render(CreditCard, {
  apiUrl: commerceCoreEndpoint,
  getCustomerToken: getUserTokenCookie,
  getCartId: () => 'ozGi7uLI74etDYyMijoI2cla5CmGIBch',
  creditCardFormRef: creditCardFormRef,
})($content);

placeOrderButton.onclick = () => {
  if (creditCardFormRef.current) {
    if (creditCardFormRef.current.validate() {
      const future = creditCardFormRef.current.submit()
      future.catch(console.error)
    }
  }
}
```

---

# Payment Services containers

Payment Services containers handle secure payment processing with Adobe Commerce Payment Services. The following container provides PCI-compliant payment collection with tokenization support.



| Container | Description |
|-----------|-------------|
| [CreditCard](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/payment-services/containers/credit-card/) | Secure payment form with PCI-compliant card collection. |

---

# Payment Services dictionary

The default Payment Services dictionary file (`i18n/en_US.json`) contains the default values for all labels and text common to the Payment Services drop-in component.

## Default keys and values

---

# Payment Services Data & Events

The **Payment Services** drop-in uses the [event bus](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/events/) for communication between drop-ins and external integrations.


<strong>Version: 1.0.2</strong>


## Events

This drop-in does not emit or listen to any drop-in-specific events. This drop-in focuses on UI presentation and data display, relying on function calls rather than event-driven communication for its core functionality. It uses only common events for standard cross-component functionality like localization and error handling.

For information about common events like `locale`, `error`, and `authenticated`, see the [common events reference](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/#common-events-reference).

---

# Payment Services overview

The Payment Services drop-in component renders the credit card form, allowing shoppers to efficiently enter their payment details. The drop-in currently supports credit/debit cards only.

## Supported payment methods

The following table provides an overview of the Payment Services payment methods that the Payment Services drop-in supports. The "Payment method code" column lists the `PaymentMethodCode` enum value for each method:

| Payment method    | Payment method code          | Status                                     |
|-------------------|------------------------------|--------------------------------------------|
| ApplevPay         | `APPLE_PAY`                  |  |
| Credit/debit card | `CREDIT_CARD`                |    |
| Google Pay        | `GOOGLE_PAY`                 |  |
| PayPal Fastlane   | `FASTLANE`                   |  |
| PayPal buttons    | `SMART_BUTTONS`              |  |

Use the `PaymentMethodCode` enum from the API import:

```ts
```

## Available containers

The Payment Services drop-in component uses one container, `CreditCard`:

- **Credit card container**: The [`CreditCard`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/payment-services/containers/credit-card/) container is designed to allow placing an order with the credit card details during the checkout process.

## Additional resources

- [Payment Service API documentation](https://developer.adobe.com/commerce/webapi/graphql/payment-services-extension/)
- [Integration workflow examples](https://developer.adobe.com/commerce/webapi/graphql/payment-services-extension/workflows/)
- [Support](https://experienceleague.adobe.com/en/docs/commerce/payment-services/guide-overview#support)

For more detailed information, please refer to the specific service documentation linked above.

---

# Payment Services installation

Before you can use the Payment Services component on your storefront, you must [configure the Services Connector](https://experienceleague.adobe.com/en/docs/commerce-learn/tutorials/admin/adobe-commerce-services/configure-adobe-commerce-services-connector) and [onboard](https://experienceleague.adobe.com/en/docs/commerce/payment-services/get-started/onboard) the Payment Services extension in the Adobe Commerce Admin.

:::note
The Payment Services drop-in component requires the [Payment Services extension](https://experienceleague.adobe.com/en/docs/commerce/payment-services/release-notes#v2100) version 2.10.0 or higher.
:::

## Installation

The Payment Services component relies on containers from several other drop-in components, you must install and configure those components before you can use the Payment Services component to place an order.

The [Commerce boilerplate template](https://github.com/hlxsites/aem-boilerplate-commerce) includes all of the necessary drop-in components and configurations to help you get started quickly, so Adobe recommends relying on the boilerplate instead of installing, configuring, and integrating the drop-in components individually.

---

# Personalization containers

Personalization containers deliver targeted content using Adobe Target. The following container provides personalized experiences based on customer segments and targeting rules.



| Container | Description |
|-----------|-------------|
| [TargetedBlock](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/personalization/containers/targeted-block/) | Personalized content blocks based on customer segments. |

---

# TargetedBlock container

The `TargetedBlock` container wraps the conditional content.

## Configurations

The `TargetedBlock` container provides the following configuration options:



## Example

The following example demonstrates how to integrate the `TargetedBlock` container:

```javascript
export default async function decorate(block) {
  const blockConfig = readBlockConfig(block);

  const {
    fragment,
    type,
    segments,
    groups,
    cartRules,
  } = blockConfig;

  const content = (blockConfig.fragment !== undefined)
    ? await loadFragment(fragment)
    : block.children[block.children.length - 1];

  render.render(TargetedBlock, {
    type,
    personalizationData: {
      segments,
      groups,
      cartRules,
    },
    slots: {
      Content: (ctx) => {
        const container = document.createElement('div');
        container.append(content);
        ctx.replaceWith(container);
      },
    },
  })(block);
}
```

---

# Personalization functions

The personalization drop-in component provides the following API endpoints.

## fetchPersonalizationData

The `fetchPersonalizationData` can be used to request the customer group, applied segments, and cart rules from Adobe Commerce based on the cart ID.

```ts
export const fetchPersonalizationData = async (
    cartId: string
): Promise<PersonalizationData | null>
```

### Parameters



### Returns

Returns a promise that resolves to the `PersonalizationData` object containing the IDs of groups, segments, and cart price rules.

```ts
export interface PersonalizationData {
    segments: string[],
    groups: string[],
    cartRules: string[]
}
```

### Usage

The following example demonstrates how to request the personalization data:

```ts
const {
  groups,
  segments,
  cartRules
} = await fetchPersonalizationData(cartId);
```

## savePersonalizationData

The `savePersonalizationData` function saves the personalization data to a cookie and emits the `personalization/updated` event.

```ts
export const savePersonalizationData = async (
    data: PersonalizationData
): Promise<void>
```

### Parameters



### Returns

Returns a promise that resolves to a void.

### Usage

The following example demonstrates how to save the personalization data:

```js
savePersonalizationData({
    segments: ['MQ==', 'Mg=='],
    groups: ['Mw=='],
    cartRules: ['NA==', 'NQ==']
});
```

## getPersonalizationData

The `getPersonalizationData` function retrieves the saved personalization data from a cookie.

```ts
export const getPersonalizationData = (): PersonalizationData
```

### Returns

Returns a `PersonalizationData` object.

```ts
export interface PersonalizationData {
    segments: string[],
    groups: string[],
    cartRules: string[]
}
```

### Usage

The following example demonstrates how to retrieve the personalization data:

```ts
const {
  groups,
  segments,
  cartRules
} = getPersonalizationData();
```

## getStoreConfig

The `getStoreConfig` function returns information about the store configuration related to personalization.

```ts
export const getStoreConfig = async (): Promise<StoreConfigModel | null>
```

### Returns

Returns a promise that resolves to a `StoreConfigModel` object or null.

```ts
export interface StoreConfigModel {
  shareActiveSegments: boolean;
  shareCustomerGroup: boolean;
  shareAppliedCartRule: boolean;
  customerAccessTokenLifetime: number;
}
```

### Usage

The following example demonstrates how to retrieve the store configuration:

```ts
const {
  shareActiveSegments,
  shareCustomerGroup,
  shareAppliedCartRule,
  customerAccessTokenLifetime
} = await getStoreConfig();
```

---

# Personalization overview

The personalization drop-in component provides a set of tools and containers designed to display content conditionally, based on Adobe Commerce customer groups, segments, and cart price rules.

## Overview

The personalization drop-in component provides the [`TargetedBlock`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/personalization/containers/targeted-block/) container, which requires you to specify the content (or a path to a fragment containing the content) and optionally specify the block type, Adobe Commerce customer groups, segments, and cart rules that determine which customers can view the content.

The component's initialization sets up event listeners that respond to changes in authentication state and cart state.

These listeners request the currently applied customer groups, segments, and cart price rules from Adobe Commerce and save them to a cookie.

When you add a `TargetedBlock` container to a page, it displays only when the customer groups, segments, and cart price rules specified in the block configuration match the groups, segments, and rules stored in the cookie.

When you specify a block type for a `TargetedBlock`, only the first targeted block of that type is rendered on the page. This behavior enables you to create a fallback chain of targeted blocks.

---

# Personalization initialization

You must include the personalization initializer on all pages by adding it to the `header.js` file.

The initialization code resides in the `/scripts/initializers/personalization.js` file within the boilerplate.

## Functionality

The initialization sets up the following listeners:



## Initialization example

Add the following line to the `blocks/header/header.js` file in the boilerplate (or any other file included for all pages):

```js
```

---

# Product Details containers

Product Details containers display product information, images, pricing, and purchase options. The following containers provide the building blocks for complete product detail pages.



| Container | Description |
|-----------|-------------|
| [ProductAttributes](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/containers/product-attributes/) | Specifications, technical details, and attributes. |
| [ProductDescription](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/containers/product-description/) | Full product descriptions with rich content. |
| [ProductGallery](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/containers/product-gallery/) | Product images and media with zoom, thumbnails, and navigation. |
| [ProductGiftCardOptions](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/containers/product-giftcard-options/) | Customize gift cards with amounts and messages. |
| [ProductHeader](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/containers/product-header/) | Product name, SKU, and key identifiers. |
| [ProductOptions](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/containers/product-options/) | Select variants like size, color, and configurable options. |
| [ProductPrice](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/containers/product-price/) | Pricing including special prices, tier pricing, and discounts. |
| [ProductQuantity](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/containers/product-quantity/) | Quantity selector for adding to cart. |
| [ProductShortDescription](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/containers/product-short-description/) | Concise product summary for quick overview. |

---

# ProductAttributes

The `ProductAttributes` container displays a list of attributes for a product on the product details page.

The container receives initial product data during [initialization](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/initialization/) to preload the component and, being event-driven, updates with data emitted to `pdp/data` within the event scope.

## ProductAttributes configurations

The `ProductAttributes` container provides the following configuration options:



## Example

The following example demonstrates how to configure the `ProductAttributes` container:

```js
return productRenderer.render(ProductAttributes, {
  scope: 'modal', // optional
});
```

---

# ProductDescription

The `ProductDescription` container displays the detailed description of a product on the product details page.

The container receives initial product data during [initialization](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/initialization/) to preload the component and, being event-driven, updates with data emitted to `pdp/data` within the event scope.

## ProductDescription configurations

The `ProductDescription` container provides the following configuration options:



## Example

The following example demonstrates how to configure the `ProductDescription` container:

```js
return productRenderer.render(ProductDescription, {
  scope: 'modal', // optional
});
```

---

# ProductGallery

The `ProductGallery` container displays a gallery of product images on the product details page.

The container receives initial product data during [initialization](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/initialization/) to preload the component and, being event-driven, updates with data emitted to `pdp/data` within the event scope.

## ProductGallery configurations

The `ProductGallery` container provides the following configuration options:



## Example

The following example demonstrates how to configure the `ProductGallery` container:

```js
return productRenderer.render(ProductDetails, {
  controls: 'thumbnailsRow',
  loop: true,
  peak: false,
  gap: 'medium',
  arrows: true,
  imageParams: {
    width: 800,
    height: 800,
  },
  thumbnailParams: {
    width: 150,
    height: 150,
  },
  zoom: {
    closeButton: true,
  },
});
```

---

# ProductGiftCardOptions

The `ProductGiftCardOptions` container manages and displays gift card-specific options on the product details page.

The container receives initial product data during [initialization](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/initialization/) to preload the component. Once loaded, it operates in an event-driven manner, updating with data emitted to `pdp/data` within the event scope. Additionally, it listens to `pdp/values` to keep its displayed state in sync with the currently selected configuration. As shoppers interact with the gift card fields, the container updates the global PDP configuration values and validity.

:::note
- Rendering is conditional. The container renders only when the product includes the `ac_giftcard` attribute containing a JSON string with the shape `{ "options": Option[] }` that defines the UI fields.
- User interactions are tracked. As shoppers edit fields, the container writes selected values to the PDP configuration (`enteredOptions`) and updates validity to enable actions like **Add to Cart**.
- Additionally, the container passes the currency of the product to the `GiftCardOptions` component so it can format and display the currency correctly.
:::

## Container rendering


  ![ProductGiftCardOptions container](https://experienceleague.adobe.com/developer/commerce/storefront/images/ProductGiftCardOptions.webp/)


## ProductGiftCardOptions configurations

The `ProductGiftCardOptions` container provides the following configuration options:



## Example

The following example demonstrates how to configure and render the `ProductGiftCardOptions` container:

```js
return productRenderer.render(ProductGiftCardOptions, {
  scope: 'modal', // optional
  className: 'pdp-gift-card-options--custom',
});
```

---

# ProductHeader

The `ProductHeader` container is designed to display the header information of a product on the product details page.

The container receives initial product data during [initialization](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/initialization/) to preload the component and, being event-driven, updates with data emitted to `pdp/data` within the event scope.

## ProductHeader configurations

The `ProductHeader` container provides the following configuration options:



## Example

The following example demonstrates how to configure the `ProductHeader` container:

```js
render(ProductHeader, {
  hideSku: false,
});
```

---

# ProductOptions

The `ProductOptions` container manages and displays product options on the product details page.

The container receives initial product data during [initialization](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/initialization/) to preload the component and, being event-driven, updates with data emitted to `pdp/data` within the event scope.

## ProductOptions configurations

The `ProductOptions` container provides the following configuration options:



## Example

The following example demonstrates how to configure the `ProductOptions` container:

```js
return productRenderer.render(ProductOptions, {
  slots: {
    Swatches: (ctx) => {
      const size = ctx.getSlotElement('product-swatch--fashion_size');

      // Add link to Sizes
      if (size) {
        // Create Size Link
        const link = document.createElement('a');
        link.href = '#';
        link.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('Size Chart');
        });
        // append inside size
        size.appendChild(link);
      }
    },
  },
});
```

---

# ProductPrice

The `ProductPrice` container displays the price of a product on the product details page. It includes special prices and regular prices if they are available and visible.

The container receives initial product data during [initialization](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/initialization/) to preload the component and, being event-driven, updates with data emitted to `pdp/data` within the event scope.

## ProductPrice configurations

The `ProductPrice` container provides the following configuration options:



## Example

The following example demonstrates how to configure the `ProductPrice` container:

```js
return productRenderer.render(ProductPrice, {
  scope: 'modal', // optional
});
```

---

# ProductQuantity

The `ProductQuantity` container manages and displays the quantity of a product that a shopper wants to purchase on the product details page.

The container receives initial product data during [initialization](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/initialization/) to preload the component and, being event-driven, updates with data emitted to `pdp/data` within the event scope.

## ProductQuantity configurations

The `ProductQuantity` container provides the following configuration options:



## Example

The following example demonstrates how to configure the `ProductQuantity` container:

```js
return productRenderer.render(ProductDetails, {
  onValue: (value) => console.log(value),
});
```

---

# ProductShortDescription

The `ProductShortDescription` container displays a short description of a product on the product details page.

The container receives initial product data during [initialization](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/initialization/) to preload the component and, being event-driven, updates with data emitted to `pdp/data` within the event scope.

## ProductShortDescription configurations

The `ProductShortDescription` container provides the following configuration options:



## Example

The following example demonstrates how to configure the `ProductShortDescription` container:

```js
return productRenderer.render(ProductShortDescription, {
  scope: 'modal', // optional
});
```

---

# Product details page dictionary

The product details page (PDP) dictionary file (`i18n/en_US.json`) contains the default values for all labels and text common to the PDP drop-in component.

## Default keys and values

---

# Product Details Data & Events

{/*
  âš ï¸ TEMPLATE USAGE GUIDE âš ï¸
  
  This template is used by scripts/generate-events-docs.js to generate event documentation.
  
  WHAT THE SCRIPT USES FROM THIS TEMPLATE:
  - Section headings and descriptive text (used as-is)
  - Import statements
  - The REPEAT_FOR_EACH_EVENT block (replicated for each event)
  - Placeholders: Product Details, Product Details, EVENT_NAME, etc.
  
  WHAT THE SCRIPT GENERATES INDEPENDENTLY:
  - Table contents between START/END markers (example rows are for reference only)
  - Event-specific data (names, descriptions, payloads from source repos)
  
  TO CHANGE:
  - Section text/descriptions â†’ Edit this template
  - Table structure (columns, links, formatting) â†’ Edit scripts/generate-events-docs.js
  - Both template and script must be kept in sync for table structure changes
*/}


The **Product Details** drop-in uses the [event bus](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/) to emit and listen to events for communication between drop-ins and external integrations. For common events shared across multiple drop-ins (such as `locale`, `error`, `authenticated`, etc.), see the [Common events reference](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/#common-events-reference).


<strong>Version: 1.3.5</strong>


> **Note:** **New to drop-in events?** Learn about the [event system architecture](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/), including the publish-subscribe pattern, subscription configuration, and best practices for event handling.

## Events reference

{/* EVENTS_TABLE_START */}


| Event | Direction | Description |
|-------|-----------|-------------|
| [pdp/valid](#pdpvalid-emits) | Emits | Emitted when validation state changes |
| [pdp/setValues](#pdpsetvalues-listens) | Listens | Fired by Pdp (`pdp`) when values are set programmatically |
| [pdp/data](#pdpdata-emits-and-listens) | Emits and listens | Triggered when data is available or changes |
| [pdp/values](#pdpvalues-emits-and-listens) | Emits and listens | Triggered when form or configuration values change |


{/* EVENTS_TABLE_END */}

## Event details

The following sections provide detailed information about each event, including its direction, data payload structure, and usage examples.


### `pdp/data` (emits and listens)

Triggered when data is available or changes

#### Data payload

```typescript
ProductModel | null
```



#### Usage

Listen to this event in your storefront:

```javascript

const pdpDataListener = events.on('pdp/data', (data) => {
  console.log('pdp/data event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
pdpDataListener.off();
```

### `pdp/setValues` (listens)

Fired by Pdp (`pdp`) when values are set programmatically

#### Data payload

This event's data payload structure is not documented in the source code.



#### Usage

Listen to this event in your storefront:

```javascript

const pdpSetValuesListener = events.on('pdp/setValues', (data) => {
  console.log('pdp/setValues event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
pdpSetValuesListener.off();
```

### `pdp/valid` (emits)

Emitted when validation state changes

#### Data payload

```typescript
boolean
```



#### Usage

Listen to this event in your storefront:

```javascript

const pdpValidListener = events.on('pdp/valid', (data) => {
  console.log('pdp/valid event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
pdpValidListener.off();
```

### `pdp/values` (emits and listens)

Triggered when form or configuration values change

#### Data payload

```typescript
ValuesModel
```



#### Usage

Listen to this event in your storefront:

```javascript

const pdpValuesListener = events.on('pdp/values', (data) => {
  console.log('pdp/values event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
pdpValuesListener.off();
```

---

# PDP functions

The product details page (PDP) drop-in component provides two functions for retrieving the product details data to display: `getProductData` and `getRefinedProduct`.

## getProductData

This function returns the product data for a given product `sku`. It takes `sku` as a parameter.

```javascript

getProductData(sku: string);
```

## getRefinedProduct

A function that returns refined product's data. It takes `sku`, `optionUIDs`, and `isBundle?` as parameters.

```js

getRefinedProduct(sku: string, optionUIDs: string, isBundle?: boolean[]);
```

## Example usage


  <div style="width:100%;padding-bottom:59%">
  
</div>

---

# Product details page overview

The product details page (PDP) drop-in component renders detailed information about your products, including descriptions, specifications, options, pricing, and images.

The practical application of rendering different product types is to provide a consistent user experience across different products. For example, a simple product can be rendered with a single price and quantity, while a complex product can be rendered with multiple options; their combination resulting in product variants. This flexibility allows you to showcase a wide range of products in a consistent and user-friendly manner. These product types allow you to cater to diverse customer needs, streamline operations, and enhance the shopping experience.

All containers in the product-details drop-in support **scoped contexts**, allowing multiple independent PDP instances to run on the same page and enabling features like product comparison, related products, and quick product previews without conflicts.

## Use cases

The PDP component provides a variety of fully-customizable controls to showcase your products according to your brand's aesthetics and build interactive experiences that engage customers. Use cases include:

- **Image Carousel**: Display multiple product images in a carousel format, allowing users to view different angles and details of the product.
- **Product Information**: Showcase detailed product information, including pricing, descriptions, and specifications.
- **Product Variants**: Display different product variants, such as colors, sizes, and styles, allowing users to select the option that best fits their needs.
- **Product Reviews**: Include user reviews and ratings to provide social proof and help users make informed purchasing decisions.
- **Customization Options**: Customize the appearance and behavior of the drop-in component to align with your brand's design aesthetic and user experience goals.

## Supported Commerce features

The following table provides an overview of the Adobe Commerce features that the PdP drop-in component supports:

| Feature                         | Status                                       |
| ------------------------------- | -------------------------------------------- |
| Bundle product type             |  |
| Configurable product type       |  |
| Image gallery                   |  |
| Grouped products                |       |
| Product details                 |  |
| Simple product type             |  |
| Virtual product type            |       |
| Zoom                            |  |

## Render product types

The PDP component supports rendering different product types configured in your Adobe Commerce instance by default using data provided by the [Catalog Service GraphQL API](https://developer.adobe.com/commerce/webapi/graphql/schema/catalog-service/). Adobe Commerce supports seven product types, but the Catalog Service GraphQL API schema maps these to two types:

- _Simple products_ are products that are defined with a single price and quantity. Catalog Service maps the simple, virtual, downloadable, and gift card product types to [`simpleProductViews`](https://developer.adobe.com/commerce/webapi/graphql/schema/catalog-service/queries/products/#return-details-about-a-simple-product).
- _Complex products_ are comprised of multiple simple products. The component simple products can have different prices. A complex product can also be defined so that the shopper can specify the quantity of component simple products. Catalog Service maps the configurable, bundle, and grouped product types to [`complexProductViews`](https://developer.adobe.com/commerce/webapi/graphql/schema/catalog-service/queries/products/#return-details-about-a-complex-product).

  > **Note:** Go to the [Commerce APIs
    Playground](https://experienceleague.adobe.com/developer/commerce/storefront/playgrounds/commerce-services/)
    and run the `product` query to see the product data structure for different product types.

## Product metadata and SEO

Generating product metadata is crucial for optimizing search engine visibility, enhancing user experience, integrating with social media, supporting ecommerce functionality, ensuring compliance, and enabling data-driven decision-making.

The Commerce boilerplate provides a [metadata generation script](https://experienceleague.adobe.com/developer/commerce/storefront/setup/seo/metadata/#generate-metadata) that fetches product data from the Catalog Service GraphQL API and generates meta tags and structured data in JSON-LD format. The script writes the metadata to an Excel file, which you can upload to Edge Delivery Services.

---

# PDP initialization

Customizing the product details page (PDP) drop-in component initializers can help you meet your project requirements and use cases.

## Configuration options

The PDP drop-in component initializers allow you to define the language definitions, default locale, and models that your project will use.



:::note
Models are used to define the data structure and initial data for the PDP drop-in. The `initialData` object contains product details, options, and attributes.
:::

## Example

The following code shows the default implementation of the PDP drop-in component initializer in the Commerce boilerplate:

```typescript
// Define the models object with a ProductDetails property
const models = {
  ProductDetails: {
    initialData: { ...product },
  },
};

// Initialize drop-in components
initializers.mountImmediately(initialize, {
  langDefinitions,
  models,
});
```

## Scope Configuration

The `scope` option enables **scoped contexts** for the PDP drop-in. When provided, the component runs in an isolated context. This allows multiple independent PDP instances on the same page without conflicts.

**Use cases for scoped PDP initialization:**
- **Product Comparison**: Initialize multiple PDP instances for side-by-side product comparison
- **Quick View**: Initialize PDP instances for modal or overlay product previews

### Example

The following example demonstrates how to initialize multiple scoped PDP instances:

```ts
// Initialize PDP
initializers.mountImmediately(initialize, {
  sku: 'SKU-001',
  langDefinitions,
});

// Initialize PDP with different scope
initializers.mountImmediately(initialize, {
  sku: 'SKU-002',
  langDefinitions,
  scope: 'modal',
});
```

## Set default product options

When a user navigates to the product detail page (PDP) on your site, you can set certain options as preselected defaults for complex products. This use case allows merchandisers to set default options through the Adobe Commerce Admin, which provides a more customized and streamlined shopping experience.

Default option selection is _not_ supported out-of-the-box for complex products. Instead, you must use [product attributes](https://experienceleague.adobe.com/en/docs/commerce-admin/catalog/product-attributes/product-attributes) and customize the PDP drop-in component initializers to define which attribute and value is used by default.



1. Log in to the Adobe Commerce Admin.

1. Create a custom attribute (`default_options`) to define default options for each product.

   :::note
   Be sure to set **Visible on Catalog Pages on Storefront** to _Yes_.
   :::

1. Ensure that the `default_options` attribute has been [exported](https://experienceleague.adobe.com/en/docs/commerce/saas-data-export/overview) to the Catalog Service _and_ that the attribute's `roles` field includes `visible_in_pdp`. See the [`ProductViewAttribute`](https://developer.adobe.com/commerce/webapi/graphql/schema/catalog-service/queries/products/#productviewattribute-type) type documentation for details.

1. Use the [`products`](https://developer.adobe.com/commerce/webapi/graphql/schema/catalog-service/queries/products/#return-details-about-a-complex-product) query to find the `id` of the `default_options` attribute for each product.

1. Add the `id` of the `default_options` attribute to the `initialData` object for each complex product.

1. Use the `id` to set the `optionsUIDs` in the `initialData` object.

   ```ts
   // Define the models object with a ProductDetails property
   const models = {
     ProductDetails: {
       initialData: {
         ...initialData,
         // Set the optionsUIDs for each product
         optionsUIDs: [
           '<id>', // Use the id of the default_options attribute for product 1
           '<id>', // Use the id of the default_options attribute for product 2
         ],
       },
     },
   };

   // Register Initializers
   initializers.mountImmediately(initialize, {
     langDefinitions,
     models,
   });
   ```

---

# PDP installation

Our drop-in components are designed for the browser's JavaScript run-time without the need for a bundler. But they can also be installed and executed in a build-time environment with bundlers like Webpack and Vite. The installation steps for both run-time and build-time environments are the same after the initial drop-in component package imports.

## Prerequisites

Before you install the product details page (PDP) drop-in component, ensure you have the following prerequisites:

## Workflow

The steps for installing the PDP drop-in component are as follows:

![PDP Installation](@images/pdp/pdp-installation.svg/)

## Step-by-step

The following steps show how to install the product details component into your site.



<Task>

### Install the packages

Use a CDN or NPM (recommended for performance) to install the drop-in component tools (`@dropins/tools`) and product details (`@dropins/storefront-pdp`) packages.

<Tabs>
  <TabItem label="NPM" icon="seti:npm">

    ```bash frame="none"
    npm install @dropins/tools @dropins/storefront-pdp
    ```

  </TabItem>
  <TabItem label="CDN" icon="external">

    ```html title="index.html" del={"Replace with actual URLs":5-7}
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Your Storefront</title>

      <script src="https://cdn.jsdelivr.net/npm/@dropins/tools@latest"></script>
      <script src="https://cdn.jsdelivr.net/npm/@dropins/storefront-pdp@latest"></script>
    </head>
    ```

  </TabItem>
</Tabs>

:::note[Install @dropins/tools]
All drop-in components require the `@dropins/tools` package. This package contains the libraries that drop-in components need to initialize and communicate, including `fetch-graphql`, `event-bus`, and `initializer` utilities.
:::

</Task>

<Task>
### Map the packages

In the `<head>` tag of your `index.html` or `head.html` file, use an `importmap` pointed to the `node_modules` directory, a **custom local directory**, or **CDN** (for run-time environments).

<Tabs>
<TabItem label="node_modules" icon="seti:npm">
    This example shows an `importmap` added to a `head.html` The `importmap` points both packages to the local `node_modules` directory that contains your installed drop-in component files from the drop-in component tools (@dropins/tools) and the PDP drop-in component (@dropins/storefront-pdp):

  ```html title="head.html"
  <script type="importmap">
    {
      "imports": {
        "@dropins/tools/": "/node_modules/@dropins/tools/",
        "@dropins/storefront-pdp/": "/node_modules/@dropins/storefront-pdp/",
      }
    }
  </script>
  <script src="/scripts/scripts.js" type="module"></script>
    ```
  </TabItem>
    <TabItem label="custom" icon="seti:folder">
    This example shows an `importmap` added to a `head.html` The `importmap` points both packages to local directories that contain all the optimized/minified files from the drop-in component tools (@dropins/tools) and the product details component (@dropins/storefront-pdp):

    ```html title="head.html"
    <script type="importmap">
      {
        "imports": {
          "@dropins/tools/": "/scripts/__dropins__/tools/",
          "@dropins/storefront-pdp/": "/scripts/__dropins__/storefront-pdp/",
        }
      }
    </script>
    <script src="/scripts/scripts.js" type="module"></script>
    ```

  </TabItem>
  <TabItem label="CDN" icon="external">
    This example shows an `importmap` pointing both packages to a CDN for the drop-in component tools (@dropins/tools) and the product details component (@dropins/storefront-pdp):

    ```html title="index.html" {"Replace CDN URLs with correct URLs":5-7} del='https://cdn.jsdelivr.net/npm/'
    <head>
      <script type="importmap">
        {
          "imports": {

            "@dropins/tools/": "https://cdn.jsdelivr.net/npm/@dropins/tools@latest",
            "@dropins/storefront-pdp/": "https://cdn.jsdelivr.net/npm/@dropins/storefront-pdp@latest",
          }
        }
      </script>
    </head>
    ```

  </TabItem>

</Tabs>

With the `importmap` defined for both run-time and build-time environments, you can now **import the required files** from these packages into your PDP drop-in component JavaScript file as described in the next step.

</Task>

<Task>
### Import the required files

Import the required files from the drop-in components tools (`@dropin/tools/initializers.js`) and the product details component (`@dropins/storefront-pdp`) into a JavaScript file for your PDP drop-in. In this example, we'll call this file `product-details.js`. See the [boilerplate code](https://github.com/hlxsites/aem-boilerplate-commerce/blob/main/blocks/product-details/product-details.js) for a list of the default imports.

</Task>

<Task>
### Connect to the endpoint

Connect your product details component to the Catalog Service GraphQL endpoint and set the required headers as shown in the example below. Replace the endpoint URL and header placeholder values with the actual values from your Commerce backend services:

```js title="product-details.js"
// Set endpoint configuration
product.setEndpoint('https://<catalog-service-endpoint>/graphql');

product.setFetchGraphQlHeaders({
  // Environment required headers
  'Magento-Environment-Id': 'your-environment-id',
  'Magento-Store-View-Code': 'your-store-view-code',
  'Magento-Website-Code': 'your-website-code',
  'x-api-key': 'your-api-key',
  'Magento-Store-Code': 'main_website_store',
  'Magento-Customer-Group': 'your-customer-group',
  'Content-Type': 'application/json',
});
```

</Task>

<Task>
### Register and load the drop-in

The code below shows how to register the product details component, load it (mount), and enable the logger for debugging purposes. You can add these functions within a `<script>` tag in your product details HTML page as shown here:

```html title="index.html" ins={"1":5} ins={"2":8}
<script type="module">
  // more code above...

  // Register and load the product details component
  initializers.mountImmediately(pdp.initialize);
</script>
```

<Callouts square color="var(--sl-color-green)">

1. This function registers the product details component to be loaded on the page by the `initializers.mount` function.
1. This event handler triggers the initializers.mount function to load the product details component after the page has loaded.

</Callouts>

</Task>

<Task>
### Create templates and render the drop-in

Render the product details components on the page. The example below provides the minimal configuration options required to render the default product details components:

```js title="product-details.js"
  const fragment = document.createRange().createContextualFragment(`
    <div class="product-details__wrapper">
      <div class="product-details__alert"></div>
      <div class="product-details__left-column">
        <div class="product-details__gallery"></div>
      </div>
      <div class="product-details__right-column">
        <div class="product-details__header"></div>
        <div class="product-details__price"></div>
        <div class="product-details__gallery"></div>
        <div class="product-details__short-description"></div>
        <div class="product-details__configuration">
          <div class="product-details__options"></div>
          <div class="product-details__quantity"></div>
          <div class="product-details__buttons">
            <div class="product-details__buttons__add-to-cart"></div>
            <div class="product-details__buttons__add-to-wishlist"></div>
          </div>
        </div>
        <div class="product-details__description"></div>
        <div class="product-details__attributes"></div>
      </div>
    </div>
  `);

  const $alert = fragment.querySelector('.product-details__alert');
  const $gallery = fragment.querySelector('.product-details__gallery');
  const $header = fragment.querySelector('.product-details__header');
  const $price = fragment.querySelector('.product-details__price');
  const $galleryMobile = fragment.querySelector('.product-details__right-column .product-details__gallery');
  const $shortDescription = fragment.querySelector('.product-details__short-description');
  const $options = fragment.querySelector('.product-details__options');
  const $quantity = fragment.querySelector('.product-details__quantity');
  const $addToCart = fragment.querySelector('.product-details__buttons__add-to-cart');
  const $addToWishlist = fragment.querySelector('.product-details__buttons__add-to-wishlist');
  const $description = fragment.querySelector('.product-details__description');
  const $attributes = fragment.querySelector('.product-details__attributes');
```

Test the product details component by viewing your PDP page in a browser, or running your local dev or build server. If you see the product details components rendered in the browser, congrats!, you have a successful installation. If not, check the console for any errors and verify that you have followed all the steps correctly.

</Task>



## Summary

The installation of all drop-in components follows the same pattern demonstrated by installing the PDP drop-in: Install, Map, Import, Connect, Register, and Render. We like to call the process `iMICRR` for short, pronounced `eye-mike-er`. Actually, we don't call it that, but if it helps...Enjoy!

---

# PDP styles

The CSS classes for each UI component that provides the product details page (PDP) drop-in component with its UI are provided here. Override these classes and add new classes to customize the look and feel of your PDP drop-in component to match your specific style requirements.

## Customizing your PDP styles

The quickest way to override Product details CSS is to inspect the PDP UI from your browser's developer tools.


  ![Find CSS classes to override](@images/dropins/findstyles.webp/)




1. **Inspect the element** in the UI that you want to customize (right-click on the element and select "Inspect" from the menu).
1. **Identify the CSS class(es)** for the element. We use [BEM naming](https://getbem.com/naming/), which makes it easy to know which component you're changing (and which CSS file to use). This class styles the `Product` component, so use your `product.css` file.
1. **Copy the CSS class** to your `product.css` file to override the existing rules or add new rules to the class. But wait! Look closely ðŸ§ at the `.pdp-product__title` class. It's using two **design tokens**. And when you see a design token within a CSS rule, don't remove the token. Instead, change the token's value (where it's defined) OR create a new token along-side this existing one to ensure maintenance and updates continue to benefit from global design token usage.



## Example CSS overrides

Here's an example of adding CSS class overrides to your `product.css` file:

```css title="product.css"
.pdp-product__options {
  grid-column: 1 / span 3;
}

.pdp-product__quantity {
  grid-column: 1 / span 3;
}

.pdp-product__buttons {
  grid-gap: 0.5rem;
}
```

## PDP Component CSS

The CSS classes for each PDP Component are provided here.















## Summary

You can customize the product details component by overriding the CSS classes provided for each component. Create a CSS file for each component to make it easier to maintain and update your PDP CSS. Use the BEM naming convention and your browser's dev tools to identify and copy the class to your corresponding component CSS file and override it as needed. Happy styling! ðŸŽ¨

---

# Facets container

The Facets container lists and manages search filters (facets) to refine product search results.

## Import

```javascript
```

## Configurations

The `Facets` container provides the following configuration options:



## Basic Usage

```javascript
// Basic facets container
await provider.render(Facets)($container);

// With scope and callback
await provider.render(Facets, {
  scope: 'popover',
  onFilterChange: (filters) => {
    console.log('Filters changed:', filters);
  }
})($container);
```

## Slots

The `Facets` container supports several customization slots. For detailed information about available slots and their usage, see [Product Discovery Slots](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/slots/).

### Example Slot Usage

```javascript
slots: {
  FacetBucketLabel: (ctx) => {
    // Here we are overriding the default Facet labels.
    const $label = document.createElement('span');
    $label.innerText = `${ctx.data.name ?? ctx.data.title} (${ctx.data.count})`;

    // If the facet has an icon, add it to the label
    if (ctx.data.icon) {
      const $icon = document.createElement('img');
      $icon.className = 'facet-bucket-label__icon';
      $icon.src = ctx.data.icon;
      $label.prepend($icon);
    }

    ctx.replaceWith($label);
  },
}
```

### Real-time Updates

The container automatically updates when search events are received:

1. **Search Results**: Updates available facets based on results
2. **Filter Changes**: Automatically triggers new searches with updated filters

### Scope Support

The Facets container supports isolated instances through scope configuration:

```javascript
// Global scope (default) Listens to all search events
await provider.render(Facets)($container);

// Only listens to events with scope: 'popover'
await provider.render(Facets, { scope: 'popover' })($container);
```

### Selected Filters Display

- Shows all currently selected filters as removable buttons
- Displays filter labels with appropriate formatting (including currency for price ranges)
- Provides individual remove functionality for each selected filter

### Clear All Functionality

- "Clear All" button to remove all selected filters at once
- Automatically triggers a new search with no filters applied

## Integration Examples

### Basic PLP Setup

```javascript
await provider.render(Facets)($facetsContainer);
```

### Category-Based Filtering

```javascript
await provider.render(Facets, {
  onFilterChange: (filters) => {
    console.log('Electronics filters changed:', filters);
  }
})($electronicsFacets);
```

### Scoped Facets

```javascript
await provider.render(Facets, {
  scope: 'popover',
  onFilterChange: (filters) => {
    // Quick search filters
    console.log('Popover filters:', filters);
  }
})($popoverFacets);
```

## Best Practices

1. **Scope Management**: Use unique scope identifiers for multiple instances
2. **Scope Configuration**: Use appropriate scope identifiers for multiple instances
3. **Filter Callbacks**: Use `onFilterChange` for custom filter handling
4. **Real-time Updates**: Let the container handle updates automatically
5. **Performance**: Use scoping to limit unnecessary updates
6. **Slot Customization**: Use slots for merchant-specific facet styling

## Troubleshooting

### Common Issues

1. **Container Not Updating**: Check scope configuration and event handling
2. **Slots Not Rendering**: Ensure the element is added to the slot using `ctx.appendChild()`, `ctx.replaceWith()`, etc.
3. **Performance Issues**: Use proper scoping to limit unnecessary updates
4. **Styling Conflicts**: Use specific CSS classes to avoid conflicts

### Facet Selection Behavior

- **Dynamic Facets**: Facets are automatically generated based on search results and available product attributes.
- **Category-Relative Filtering**: If a `categoryPath` is provided in the search, facet selections will automatically include the categoryPath to ensure filters are relative to the current category.

---

# Product Discovery containers

Product Discovery containers display search results, category listings, and product listing pages. The following containers provide the building blocks for complete search and discovery experiences.



| Container | Description |
|-----------|-------------|
| [SearchResults](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/containers/search-results/) | Product search results with configurable layouts and product information. |
| [Facets](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/containers/facets/) | Filtering options to refine search results by attributes and categories. |
| [SortBy](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/containers/sort-by/) | Sort product results by price, name, relevance, and other criteria. |
| [Pagination](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/containers/pagination/) | Navigate multiple pages of product results with pagination controls. |

---

# Pagination container

The `Pagination` container handles paging for search results. It shows next, previous, and page number controls and keeps the page in sync with the results.

## Import

```javascript
```

## Configurations

The `Pagination` container provides the following configuration options:



## Basic Usage

```javascript
await provider.render(Pagination)($container);
```

## Features

### Automatic Page Management

- **Page State**: Automatically tracks current page and total pages from search results
- **Page Info**: Extracts pagination data from `pageInfo.currentPage` and `pageInfo.totalPages`
- **Conditional Rendering**: Only renders when pagination data is available
- **Search Integration**: Page changes trigger new search calls with updated page parameters

### Navigation Controls

- **Page Numbers**: Direct navigation to specific pages
- **Current Page Display**: Shows current page position
- **Total Pages**: Displays total number of available pages
- **Responsive Design**: Adapts to different screen sizes

### Scope Support

The Pagination container supports isolated instances through scope configuration:

```javascript
// Global scope (default) Listens to all search events
await provider.render(Pagination)($container);

// Only listens to events with scope: 'popover'
await provider.render(Pagination, { scope: 'popover' })($container);
```

## Real-time Updates

The container automatically updates when search events are received:

1. **Search Results**: Updates pagination based on `pageInfo` from results
2. **Page Changes**: Automatically triggers new searches with updated page

## Integration Examples

### Basic PLP Setup

```javascript
await provider.render(Pagination, {
  onPageChange: (page) => {
    // scroll to the top of the page after changing pages
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
})($paginationContainer);
```

## Best Practices

1. **Scope Management**: Use unique scope identifiers for multiple instances
2. **Page Callbacks**: Use `onPageChange` for custom page handling
3. **Real-time Updates**: Let the container handle updates automatically

## Troubleshooting

### Common Issues

1. **Container Not Updating**: Check scope configuration and event handling
2. **Page Not Changing**: Verify search API is being called with correct page
3. **Container Not Rendering**: Ensure search results include `pageInfo` data
4. **Styling Conflicts**: Use specific CSS classes to avoid conflicts

### Pagination Behavior

- **Conditional Rendering**: Container only renders when `currentPage` and `totalPages` are available
- **Search Integration**: Page changes automatically trigger new search calls
- **State Management**: Page state is maintained through search variables

---

# SearchResults container

The SearchResults container shows products from a search. You can customize it with slots, run separate instances, and it takes care of loading, errors, and real-time updates.

## Import

```javascript
```

## Configurations

The `SearchResults` container provides the following configuration options:



## Basic Usage

```javascript
// Basic search results container
await provider.render(SearchResults, {
  skeletonCount: 12,
  routeProduct: (product) => `/product/${product.sku}`
})($container);

// With scope for isolated instance
await provider.render(SearchResults, {
  skeletonCount: 6,
  scope: 'popover',
  routeProduct: (product) => `/product/${product.sku}`
})($container);

// With callback for custom handling
await provider.render(SearchResults, {
  skeletonCount: 12,
  onSearchResult: (products) => {
    console.log('Received', products.length, 'results');
  }
})($container);
```

## Slots

The `SearchResults` container supports several customization slots. For detailed information about available slots and their usage, see [Product Discovery Slots](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/slots/).

### Example Slot Usage

```javascript
slots: {
  Header: (ctx) => {
    const header = document.createElement('div');
    header.innerHTML = `
      Search Results
      Found ${ctx.products.length} products
    `;
    ctx.appendChild(header);
  },
  
  ProductActions: (ctx) => {
    const actions = document.createElement('div');
    
    const addToCartBtn = document.createElement('button');
    addToCartBtn.textContent = 'Add to Cart';
    addToCartBtn.onclick = () => addToCart(ctx.product);
    
    const quickViewBtn = document.createElement('button');
    quickViewBtn.textContent = 'Quick View';
    quickViewBtn.onclick = () => openQuickView(ctx.product);
    
    actions.appendChild(addToCartBtn);
    actions.appendChild(quickViewBtn);
    
    ctx.appendChild(actions);
  }
}
```

## Features

### Automatic Loading States

- **Skeleton Loading**: Configurable skeleton items while fetching results
- **Loading Indicators**: Automatic loading state management
- **Error Handling**: Graceful error display with user-friendly messages
- **Empty States**: Appropriate messaging when no results are found

### Real-time Updates

The container automatically updates when search events are received:

1. **Search Start**: Shows loading state with skeleton items
2. **Search Results**: Updates with new product data
3. **Search Complete**: Removes loading state
4. **Error Handling**: Displays error state if applicable

### Product Routing

Customize how products link to their detail pages:

```javascript
// Basic product routing
routeProduct: (product) => `/product/${product.sku}`
```

## Integration Examples

### Basic PLP Setup

```javascript
await provider.render(SearchResults, {
  skeletonCount: 12,
  routeProduct: (product) => `/product/${product.sku}`
})($searchResults);
```

### Quick Search Popover

```javascript
await render.render(SearchResults, {
  skeletonCount: pageSize,
  scope: 'popover',
  routeProduct: ({ urlKey, sku }) => rootLink(`/products/${urlKey}/${sku}`),
  onSearchResult: (results) => {
    searchResult.style.display = results.length > 0 ? 'block' : 'none';
  },
  slots: {
    Footer: async (ctx) => {
      // View all results button
      const viewAllResultsWrapper = document.createElement('div');

      const viewAllResultsButton = await UI.render(Button, {
        children: labels.Global?.SearchViewAll,
        variant: 'secondary',
        href: rootLink('/search'),
      })(viewAllResultsWrapper);

      ctx.appendChild(viewAllResultsWrapper);

      ctx.onChange((next) => {
        viewAllResultsButton?.setProps((prev) => ({
          ...prev,
          href: `${rootLink('/search')}?q=${encodeURIComponent(next.variables?.phrase || '')}`,
        }));
      });
    },
  },
})(searchResult);
```

### Search Results Integration

```javascript
await provider.render(SearchResults, {
  routeProduct: (product) => rootLink(`/products/${product.urlKey}/${product.sku}`),
  slots: {
    ProductActions: (ctx) => {
      // Wrapper
      const wrapper = document.createElement('div');
      wrapper.className = 'product-discovery-product-actions';
      
      // Add to Cart Button
      const addToCartBtn = document.createElement('button');
      addToCartBtn.className = 'product-discovery-product-actions__add-to-cart';
      addToCartBtn.innerText = placeholders.Global.AddToCartLabel;
      addToCartBtn.addEventListener('click', () => console.log(ctx.product));

      // Append element to Slot
      ctx.appendChild(addToCartBtn);
    },
  },
})($productList);
```

## Best Practices

1. **Scope Management**: Use unique scope identifiers for multiple instances
2. **Slot Customization**: Use slots for merchant-specific customization
3. **Performance**: Use lazy loading for off-screen containers
4. **Error Handling**: Let the container handle errors automatically
5. **Real-time Updates**: Let the container handle updates automatically

## Troubleshooting

### Common Issues

1. **Container Not Updating**: Check scope configuration and event handling
2. **Slots Not Rendering**: Ensure the element is added to the slot using `ctx.appendChild()`, `ctx.replaceWith()`, etc.
3. **Styling Conflicts**: Use specific CSS classes to avoid conflicts

---

# SortBy container

The SortBy container manages sorting for search results, offers customizable criteria, and automatically maintains sort state for both default and custom options.

## Import

```javascript
```

## Configurations

The `SortBy` container provides the following configuration options:



## Basic Usage

```javascript
// Basic sort by container
await provider.render(SortBy)($container);

// With sort change callback
await provider.render(SortBy, {
  onSortChange: (value) => {
    console.log('Sort changed:', value);
  }
})($container);

// With scope
await provider.render(SortBy, {
  scope: 'popover',
  onSortChange: (value) => {
    console.log('Sort changed:', value);
  }
})($container);
```

## Features

### Sort Options

The container's sort options are dynamically driven by Adobe Commerce rules and option labels:

- **Dynamic Population**: Sort options are automatically populated from search metadata
- **Commerce Rules**: Available sort attributes are determined by Adobe Commerce configuration
- **Option Labels**: Display text comes from Commerce system labels and translations
- **Context-Aware**: Sort options may vary based on category, product type, or search context

### Sort State Management

- **Automatic Updates**: Sort state updates automatically with search parameters
- **Search Integration**: Sort changes trigger new search calls with updated parameters
- **State Persistence**: Sort preferences maintained across search requests

### Scope Support

The SortBy container supports isolated instances through scope configuration:

```javascript
// Global scope (default) Listens to all search events
await provider.render(SortBy)($container);

// Only listens to events with scope: 'popover'
await provider.render(SortBy, { scope: 'popover' })($container);
```

## Real-time Updates

The container automatically updates when search events are received:

1. **Search Results**: Updates sort options based on available attributes
2. **Sort Changes**: Automatically triggers new searches with updated sort

## Integration Examples

### Basic PLP Setup

```javascript
await provider.render(SortBy, {
  onSortChange: (value) => {
    console.log('Sort order changed:', value);
  }
})($sortByContainer);
```

## Best Practices

1. **Scope Management**: Use unique scope identifiers for multiple instances
2. **Sort Callbacks**: Use `onSortChange` for custom sort handling
3. **Real-time Updates**: Let the container manage updates automatically.

## Troubleshooting

### Common Issues

1. **Container Not Updating**: Check scope configuration and event handling
2. **Sort Not Changing**: Verify search API is being called with correct sort
3. **Styling Conflicts**: Use specific CSS classes to avoid conflicts

### Sort Behavior

- **Dynamic Options**: Sort options are automatically populated from search metadata
- **State Persistence**: Sort state is maintained across search requests
- **Search Integration**: Sort changes trigger new search calls with updated parameters

---

# Product Discovery drop-in dictionary

The default Product Discovery dictionary file (`i18n/en_US.json`) contains the default values for all labels and text common to the Product Discovery drop-in component.

## Default keys and values

---

# Product Discovery Data & Events

{/*
  âš ï¸ TEMPLATE USAGE GUIDE âš ï¸
  
  This template is used by scripts/generate-events-docs.js to generate event documentation.
  
  WHAT THE SCRIPT USES FROM THIS TEMPLATE:
  - Section headings and descriptive text (used as-is)
  - Import statements
  - The REPEAT_FOR_EACH_EVENT block (replicated for each event)
  - Placeholders: Product Discovery, Product Discovery, EVENT_NAME, etc.
  
  WHAT THE SCRIPT GENERATES INDEPENDENTLY:
  - Table contents between START/END markers (example rows are for reference only)
  - Event-specific data (names, descriptions, payloads from source repos)
  
  TO CHANGE:
  - Section text/descriptions â†’ Edit this template
  - Table structure (columns, links, formatting) â†’ Edit scripts/generate-events-docs.js
  - Both template and script must be kept in sync for table structure changes
*/}


The **Product Discovery** drop-in uses the [event bus](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/) to emit and listen to events for communication between drop-ins and external integrations. For common events shared across multiple drop-ins (such as `locale`, `error`, `authenticated`, etc.), see the [Common events reference](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/#common-events-reference).


<strong>Version: 2.1.0</strong>


> **Note:** **New to drop-in events?** Learn about the [event system architecture](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/), including the publish-subscribe pattern, subscription configuration, and best practices for event handling.

## Events reference

{/* EVENTS_TABLE_START */}


| Event | Direction | Description |
|-------|-----------|-------------|
| [search/error](#searcherror-emits-and-listens) | Emits and listens | Triggered when an error occurs |
| [search/loading](#searchloading-emits-and-listens) | Emits and listens | Triggered when loading state changes |
| [search/result](#searchresult-emits-and-listens) | Emits and listens | Triggered when results are available |


{/* EVENTS_TABLE_END */}

## Event details

The following sections provide detailed information about each event, including its direction, data payload structure, and usage examples.


### `search/error` (emits and listens)

Triggered when an error occurs

#### Data payload

```typescript
string
```



#### Usage

Listen to this event in your storefront:

```javascript

const searchErrorListener = events.on('search/error', (data) => {
  console.log('search/error event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
searchErrorListener.off();
```

### `search/loading` (emits and listens)

Triggered when loading state changes

#### Data payload

```typescript
boolean
```



#### Usage

Listen to this event in your storefront:

```javascript

const searchLoadingListener = events.on('search/loading', (data) => {
  console.log('search/loading event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
searchLoadingListener.off();
```

### `search/result` (emits and listens)

Triggered when results are available

#### Data payload

```typescript
{
result: ProductSearchResult;
request: SearchVariables;
}
```

| Property | Type | Description |
|----------|------|-------------|
| `result` | `ProductSearchResult` | See type definition in source code |
| `request` | `SearchVariables` | See type definition in source code |


#### Usage

Listen to this event in your storefront:

```javascript

const searchResultListener = events.on('search/result', (data) => {
  console.log('search/result event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
searchResultListener.off();
```

---

# Product Discovery functions

The Product Discovery drop-in component provides API functions to perform searches, update results, and keep connected containers in sync.

## search

The `search` function performs a product search based on the parameters. It updates the search context and emits events consumed by containers such as `SearchResults`, `Facets`, `Pagination`, and `SortBy`.

Passing `null` as the `variables` parameter clears the current search state and resets related containers.

```ts
export const search = async (
  variables: {
    phrase?: string;
    pageSize?: number;
    currentPage?: number;
    filter?: Array<{
      attribute: string;
      contains?: string;
      eq?: string;
      in?: string[];
      range?: { from?: number; to?: number };
      startsWith?: string;
    }>;
    sort?: Array<{
      attribute: string;
      direction: 'ASC' | 'DESC';
    }>;
  } | null,
  options?: {
    scope?: string;
  }
): Promise<void>
```

### Variables



### Options



### Returns

Returns a promise that resolves when the search completes and related events have been emitted.   No direct return payload; containers update automatically based on the emitted events.

### Events

The event bus emits the following events during the search lifecycle:

| Event name            | Payload                       | Description |
|-----------------------|--------------------------------|-------------|
| `search/loading`      | `boolean`                      | Emitted when a search request starts (`true`) or ends (`false`). |
| `search/result`       | `{ request, result }`          | Emitted with the search variables and the search results. |
| `search/error`        | `Error`                        | Emitted if the search request fails. |

Events are scoped when a `scope` option is provided. Scoped events only update containers registered with the same scope.

### Usage

Perform a basic search:

```js

await search({
  phrase: 'shirts',
  pageSize: 12,
  currentPage: 1,
  filter: [],
  sort: []
});
```

Perform a scoped quick search:

```js
await search({
  phrase: 'sneakers',
  pageSize: 6,
  currentPage: 1,
  filter: [],
  sort: []
}, { scope: 'popover' });
```

Search with filters and sorting:

```js
await search({
  phrase: '',
  pageSize: 12,
  currentPage: 1,
  filter: [
    { attribute: 'categories', in: ['apparel'] },
    { attribute: 'price', range: { from: 25, to: 75 } }
  ],
  sort: [{ attribute: 'price', direction: 'ASC' }]
});
```

Clear search results:

```js
await search(null);
```

---

# Product Discovery overview

The Product Discovery drop-in enables you to display and customize product search results, category listings, and faceted navigation within your storefront.

The Product Discovery drop-in component provides a set of modular, event-driven containersâ€”such as product lists, facets, sort controls, and paginationâ€”that can be used individually or composed together to build tailored product listing pages (PLPs), category pages, and quick search experiences.

Each container reacts to search events orchestrated by the **[search](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/functions/)** API functions, ensuring the UI stays in sync as shoppers search, filter, sort, and paginate through results. Multiple search instances can run on the same page using scoped contexts, allowing for features like a full-page PLP and a quick search overlay.

## Data Flows

### PLP Search

<Diagram 
  type="mermaid" 
  caption="Event Driven Architecture â€” Search"
  code={`sequenceDiagram
    participant U as User
    participant API as search() API
    participant EB as Event Bus
    participant SR as SearchResults
    participant F as Facets
    participant P as Pagination
    participant S as SortBy
    participant GQL as GraphQL API
    %% Initial search
    U->>API: search({phrase: "shirts"})
    API->>GQL: request data from Catalog Services
    GQL-->>API: return results
    API->>EB: emit('search/loading', true)
    API->>EB: emit('search/result', { request, result })
    API->>EB: emit('search/loading', false)
    
    %% All containers receive loading and result events
    EB->>SR: search/loadingsearch/result
    EB->>F: search/loadingsearch/result
    EB->>P: search/loadingsearch/result
    EB->>S: search/loadingsearch/result
`}
/>

### Scoped Quick Search Flow (pop-over)

(scope: "popover")
    participant GQL as GraphQL API
    %% Quick search
    U->>API: search({phrase: "shirt"}, {scope: "popover"})
    API->>GQL: request data from Catalog Services
    GQL-->>API: return results
    API->>EB: emit('search/loading', true, {scope: "popover"})
    API->>EB: emit('search/result', { request, result }, {scope: "popover"})
    API->>EB: emit('search/loading', false, {scope: "popover"})
    
    %% Only SearchResults receives events (scoped)
    EB->>SR: search/loadingsearch/result (scope: "popover")
`}
/>

## Core Design Principles
- **Event-Driven**: Container communication via a central event bus
- **Modular**: UI is split into purpose-specific containers
- **Scoped**: Supports multiple isolated search instances with full ACDL compliance

## Key capabilities
- Composable. Use `SearchResults`, `Facets`, `Pagination`, and `SortBy`  containers to build your desired layout.
- Scoped search contexts to support multiple independent search areas on a single page (for example, PLP and quick search).
- Slot-based customization â€“ Extend or replace UI parts, such as headers, footers, or product action areas.
- Pre-selected filters, sort order, and pagination are automatically sync with the current search state.
- Pre-integrated data collection events compatible with ACDL for each stage of the search lifecycle.

## Use cases

- Product listing pages (PLPs) â€“ Display results by filtering, sorting, and paginating.
- Category pages â€“ Show products and refinements scoped to a specific category.
- Quick search overlays to provide instant results as shoppers type.

## Supported Commerce features

The following table provides an overview of the Adobe Commerce features that the Product Discovery drop-in component supports:

| Feature          | Status                                       |
| ---------------- | -------------------------------------------- |
| Simple Product View |  |
| Complex Product View |       |

---

# Product Discovery installation

This guide will help you install and configure the Product Discovery drop-in component in your storefront.

## Prerequisites

Before you begin, ensure you have:

- Adobe Commerce instance with [Live Search](https://experienceleague.adobe.com/en/docs/commerce/live-search/overview) enabled
- Access to your store's GraphQL endpoint
- Required API keys and credentials
- Node.js and npm installed on your development environment

## Step-by-step

Use the following steps to install the Product Discovery drop-in component:



<Task>

### Install the packages

Use a CDN or NPM (recommended for performance) to install the drop-in component tools (`@dropins/tools`) and product discovery (`@dropins/storefront-product-discovery`) packages.

<Tabs>
  <TabItem label="NPM" icon="seti:npm">

    ```bash frame="none"
    npm install @dropins/tools @dropins/storefront-product-discovery
    ```

  </TabItem>
  <TabItem label="CDN" icon="external">

    ```html title="index.html" del={"Replace with actual URLs":5-7}
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Your Storefront</title>

      <script src="https://cdn.jsdelivr.net/npm/@dropins/tools@latest"></script>
      <script src="https://cdn.jsdelivr.net/npm/@dropins/storefront-product-discovery@latest"></script>
    </head>
    ```

  </TabItem>
</Tabs>

:::note[Install @dropins/tools]
All drop-in components require the `@dropins/tools` package. This package contains the libraries that drop-in components need to initialize and communicate, including `fetch-graphql`, `event-bus`, and `initializer` utilities.
:::

</Task>

<Task>
### Map the packages

In the `<head>` tag of your `index.html` or `head.html` file, use an `importmap` pointed to the `node_modules` directory, a **custom local directory**, or **CDN** (for run-time environments).

<Tabs>
<TabItem label="node_modules" icon="seti:npm">

  ```html title="head.html"
  <script type="importmap">
    {
      "imports": {
        "@dropins/tools/": "/node_modules/@dropins/tools/",
        "@dropins/storefront-product-discovery/": "/node_modules/@dropins/storefront-product-discovery/"
      }
    }
  </script>
  <script src="/scripts/scripts.js" type="module"></script>
  ```

</TabItem>
<TabItem label="custom" icon="seti:folder">

  ```html title="head.html"
  <script type="importmap">
    {
      "imports": {
        "@dropins/tools/": "/scripts/__dropins__/tools/",
        "@dropins/storefront-product-discovery/": "/scripts/__dropins__/storefront-product-discovery/"
      }
    }
  </script>
  <script src="/scripts/scripts.js" type="module"></script>
  ```

</TabItem>
<TabItem label="CDN" icon="external">

  ```html title="index.html"
  <head>
    <script type="importmap">
      {
        "imports": {
          "@dropins/tools/": "https://cdn.jsdelivr.net/npm/@dropins/tools@latest/",
          "@dropins/storefront-product-discovery/": "https://cdn.jsdelivr.net/npm/@dropins/storefront-product-discovery@latest/"
        }
      }
    </script>
  </head>
  ```

</TabItem>
</Tabs>

With the `importmap` defined for both runtime and build-time environments, you can now **import the required files** from these packages into your product list page block as described in the next step.

</Task>

<Task>
### Initialize the drop-in

The code below shows how to register the Product Discovery drop-in, configure placeholders and translation files, and set GraphQL endpoint and headers. You can add these functions as a script to your website and import them on blocks where Product Discovery components are rendered.

```js title="product-discovery-initializer.js"

await initializeDropin(async () => {
  setEndpoint(await commerceEndpointWithQueryParams());
  setFetchGraphQlHeaders((prev) => ({ ...prev, ...getHeaders('cs') }));

  const labels = await fetchPlaceholders('placeholders/search.json');
  const langDefinitions = {
    default: {
      ...labels
    }
  };

  return initializers.mountImmediately(initialize, { langDefinitions });
})();
```

</Task>

<Task>
### Import the required files

Import the required files from `@dropins/tools`, `@dropins/storefront-product-discovery`, and your initializer file into a JavaScript file for your product list page and header blocks.

<Tabs>
<TabItem label="product-list-page.js">

```js title="product-list-page.js"
// Component tools

// Drop-in component functions

// Drop-in component provider

// Drop-in component containers

// Initializers
```

</TabItem>
<TabItem label="header.js">

```js title="header.js"
// Component tools

// Drop-in component functions

// Drop-in component provider

// Drop-in component containers

// Initializers
```

</TabItem>
</Tabs>
</Task>

<Task>
### Configure and render the Product Discovery components

Render the Product Discovery components on the page. The example below shows rendering for a PLP and a quick search overlay.

<Tabs>
<TabItem label="product-list-page.js">

```js title="product-list-page.js"
const fragment = document.createRange().createContextualFragment(`
  <div class="search__wrapper">
    <div class="search__left-column">
      <div class="search__facets"></div>
    </div>
    <div class="search__right-column">
      <div class="search__result-info"></div>
      <div class="search__product-list"></div>
      <div class="search__pagination"></div>
    </div>
  </div>
`);

const $resultInfo = fragment.querySelector('.search__result-info');
const $facets = fragment.querySelector('.search__facets');
const $productList = fragment.querySelector('.search__product-list');
const $pagination = fragment.querySelector('.search__pagination');

provider.render(SortBy)($resultInfo);
provider.render(Facets)($facets);
provider.render(SearchResults)($productList);
provider.render(Pagination)($pagination);

block.appendChild(fragment);
```

</TabItem>
<TabItem label="header.js">

```js title="header.js"
const search = document.createRange().createContextualFragment(`
  <div class="search-wrapper nav-tools-wrapper">
    <button type="button" class="nav-search-button">Search</button>
    <div class="nav-search-input nav-search-panel nav-tools-panel">
      <div id="search-bar-input"></div>
      <div class="search-bar-result"></div>
    </div>
  </div>
`);

block.append(search);

const searchInput = block.querySelector('#search-bar-input');
const searchResult = block.querySelector('.search-bar-result');

provider.render(SearchBarInput)($searchInput);
provider.render(SearchBarResults)($searchResult);
```

</TabItem>
</Tabs>
</Task>


The [Commerce boilerplate template](https://github.com/hlxsites/aem-boilerplate-commerce) includes all of the necessary drop-in components and configurations to help you get started quickly, so Adobe recommends relying on the boilerplate instead of installing, configuring, and integrating the drop-in components individually.

---

# Product Discovery slots

Learn about the slots provided in the Product Discovery drop-in component.

[Extending drop-in components](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/extending/) describes default properties available to all slots.

## SearchResults slots

The slots for the `SearchResults` container allow you to customize the appearance of product search results.

```js
slots?: {
    ProductActions?: SlotProps<{ 
      product: Product;
      variables: SearchVariables | null; 
    }>;
    
    ProductPrice?: SlotProps<{ 
      product: Product; 
      variables: SearchVariables | null; 
    }>;

    ProductName?: SlotProps<{ 
      product: Product; 
      variables: SearchVariables | null; 
    }>;
    
    ProductImage?: SlotProps<{ 
      product: Product; 
      variables: SearchVariables | null; 
      defaultImageProps: ImageProps 
    }>
    
    NoResults?: SlotProps<{ 
      error: string | null; 
      variables: SearchVariables | null 
    }>;
    
    Header?: SlotProps<{ 
      products: Product[]; 
      variables: SearchVariables | null 
    }>;
    
    Footer?: SlotProps<{ 
      products: Product[]; 
      variables: SearchVariables | null 
    }>;
};
```

### Product interface

The `Product` interface provides access to product data in slot context objects:

```typescript
export interface Product {
  id: string;
  name: string;
  sku: string;
  shortDescription: string;
  url: string;
  urlKey: string;
  metaTitle: string;
  metaKeywords: string;
  metaDescription: string;
  lowStock: boolean;
  links: any[];
  images: ProductImage[];
  description: string;
  externalId: string;
  inputOptions: any[];
  addToCartAllowed: boolean;
  price?: ProductViewPrice;
  priceRange?: {
    minimum: ProductViewPrice;
    maximum: ProductViewPrice;
  };
  inStock: boolean;
  typename: string;
  initialized?: boolean;
}

export interface ProductViewPrice {
  final: ProductPrice;
  regular: ProductPrice;
  roles?: string[];
}

export interface ProductPrice {
  amount: {
    value: number;
    currency: string;
  };
}

export interface ProductImage {
  label: string;
  roles: string[];
  url: string;
}
```

### SearchVariables interface

The `SearchVariables` interface provides access to search parameters and context in slot context objects:

```typescript
export type Scope = 'search' | 'popover' | string;

export interface SearchVariables {
  scope?: Scope;
  phrase?: string;
  filter?: SearchFilter[];
  sort?: SortOrder[];
  currentPage?: number;
  pageSize?: number;
  context?: SearchContext;
}

export interface SearchContext {
  customerGroup?: string;
  userViewHistory?: ViewHistoryRecord[];
}

export interface ViewHistoryRecord {
  sku: string;
  dateTime: string;
}

export interface SearchFilter {
  attribute: string;
  in?: string[];
  eq?: string;
  range?: {
    from: number;
    to: number;
  };
}

export interface SortOrder {
  attribute: string;
  direction: 'ASC' | 'DESC';
}
```

### Header slot

The `Header` slot allows you to change content at the top of the `SearchResults` container.

The context object passed to the callback function includes a `products` property containing the search results and a `variables` property with the current search parameters. You can access properties like `products.length` for result count, `variables.phrase` for the search term, `variables.currentPage` for pagination info, and iterate through `products` to display summary information.

### Footer slot

The `Footer` slot allows you to change content at the bottom of the `SearchResults` container.

The context object passed to the callback function includes a `products` property containing the search results and a `variables` property with the current search parameters. You can access properties like `products.length` for result count, `variables.currentPage` and `variables.pageSize` for pagination controls, and iterate through `products` to display summary information.

### ProductActions slot

The `ProductActions` slot allows you to add or replace content in the actions section of each product's rendering.

The context object passed to the callback function includes a `product` property containing the product data and a `variables` property with the current search parameters. You can access properties like `product.addToCartAllowed`, `product.inStock`, and `product.id` to conditionally render actions. The `variables.context?.customerGroup` can be used to show different actions based on user permissions.

### ProductPrice slot

The `ProductPrice` slot allows you to add or replace content in the price section of each product's rendering.

The context object passed to the callback function includes a `product` property containing the product data and a `variables` property with the current search parameters. You can access `product.price` for the current price or `product.priceRange` for min/max pricing. Use `variables.context?.customerGroup` to display role-based pricing.

### ProductName slot

The `ProductName` slot allows you to add or replace content in the name section of each product's rendering.

The context object passed to the callback function includes a `product` property containing the product data and a `variables` property with the current search parameters. You can access properties like `product.name`, `product.sku`, and `product.shortDescription` for display. The `variables.phrase` can be used to highlight matching search terms.

### ProductImage slot

The `ProductImage` slot allows you to add or replace content in the image section of each product's rendering.

The context object passed to the callback function includes a `product` property containing the product data, a `variables` property with the current search parameters, and a `defaultImageProps` property with the following structure:

```typescript
interface ImageProps {
  loading: 'lazy';
  src: string;
  alt: string;
  width: string;
  height: string;
}
```

### NoResults slot

The `NoResults` slot allows you to customize what is displayed when there are no matching results or if an error occurs.

The context includes:
- `error`: An error message or `null`
- `variables`: The search parameters used for the query

You can access `variables.phrase` to show the search term that returned no results, `variables.filter` to display applied filters, and `variables.scope` to customize messaging based on the search context.

#### Example implementation

```js
provider.render(SearchResults, {
  slots: {
    ProductName: (ctx) => {
      const skuDiv = document.createElement('div');
      skuDiv.innerHTML = ctx.product.sku;
      ctx.prependSibling(skuDiv);
    },
    NoResults: (ctx) => {
      const message = document.createElement('p');
      message.textContent = ctx.error
        ? `Error: ${ctx.error}`
        : 'No products found for your search.';
      return message;
    }
  }
})($searchResultsContainer);
```

## Facets slots

The slots for the `Facets` container allow you to customize the appearance of the facets.

```js
slots?: {
    Facet?: SlotProps<{ data: SearchFacet }>;
    SelectedFacets?: SlotProps<{ data: SearchFacet[] }>;
    Facets?: SlotProps<{ data: SearchFacet[] }>;
    FacetBucket?: SlotProps<{ data: FacetBucket }>;
    FacetBucketLabel?: SlotProps<{ data: FacetBucket }>;
};
```

### Facet slot

The `Facet` slot allows you to customize the appearance of each individual facet.

The context object includes a `data` property with the facet details:

```typescript
export interface SearchFacet {
  title: string;
  attribute: string;
  buckets: FacetBucket[];
}

export interface FacetBucket {
  title: string;
  count: number;
  __typename: string;
  from?: number;
  to?: number;
  selected?: boolean;
}
```

### Facets slot

The `Facets` slot allows you to customize the appearance of the entire list of facets.

The context object includes a `data` property containing an array of `SearchFacet` objects.

### SelectedFacets slot

The `SelectedFacets` slot allows you to customize the list of currently selected facets.

The context object includes a `data` property containing an array of `SearchFacet` objects that represent the selected filters.

### FacetBucket slot

The `FacetBucket` slot allows you to customize the rendering of each bucket within a facet.

The context object includes a `data` property containing a `FacetBucket` object.

### FacetBucketLabel slot

The `FacetBucketLabel` slot allows you to customize only the label portion of each bucket within a facet.

The context object includes a `data` property containing a `FacetBucket` object.

---

# Product Discovery styles

The CSS classes for each UI component that provides the product discovery drop-in component with its UI are provided here. Override these classes and add new classes to customize the look and feel of your product discovery components to match your specific style requirements.

[Styling drop-in components](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/styling/) describes how to inspect the drop-in component in your browser's developer tools to discover the BEM class names to be extended.


## Example CSS overrides

Here's an example of overriding the CSS classes for the DROPIN_NAME drop-in component:

```css title="product-discovery.css"
.product-discovery-product-list__grid {
  grid-template-columns: repeat(4, 1fr);
}
```

## Product Discovery CSS classes

The CSS classes for each Product Discovery Component are provided here.

---

# Recommendations containers

Recommendations containers display AI-powered product suggestions using Adobe Sensei. The following container provides personalized product recommendations based on customer behavior and context.



| Container | Description |
|-----------|-------------|
| [ProductList](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/recommendations/containers/product-list/) | Personalized recommendations powered by Adobe Sensei. |

---

# ProductList container

The `ProductList` container manages and displays a list of recommended products based on the current product. Its behavior is driven by configuration options such as `currentSku`, `recId`, and `routing` through `routeProduct` callbacks.


  ![ProductList container](@images/dropins/recommendations/product-list.png/)


## Configurations

The `ProductList` container provides the following configuration options:



The `ProductListProps` interface has the following shape:

```ts
export interface ProductListProps extends HTMLAttributes<HTMLDivElement> {
  recId: string;
  currentSku: string;
  initialData?: {
    recommendations?: {
      results: RecommendationUnitModel[];
      totalProducts: number;
    };
  };
  hideHeading?: boolean;
  routeProduct?: (item: Item) => string;
  cartSkus?: string[];
  userPurchaseHistory?: any[];
  userViewHistory?: any[];
  slots?: {
    Heading?: SlotProps;
    Footer?: SlotProps;
    Title?: SlotProps<{
      item: Item;
      productUrl: string;
    }>;
    Sku?: SlotProps<{
      item: Item;
    }>;
    Price?: SlotProps<{
      item: Item;
    }>;
    Thumbnail?: SlotProps<{
      item: any;
      defaultImageProps: ImageProps;
    }>;
  };
}
```

The `RecommendationUnitModel` object has the following shape:

```ts
export interface RecommendationUnitModel {
  displayOrder: number;
  pageType: PageType;
  title: string;
  items: Item[];
  totalProducts: number;
  typeId: string;
  unitId: string;
  unitName: string;
}

export type PageType = 'Product'; // Always hardcoded to 'Product' per requirements

export interface Item {
  uid: string;
  sku: string;
  name: string;
  urlKey: string;
  images: ItemImage[];
  price: FinalPrice;
  priceRange?: {
    minimum?: FinalPrice;
    maximum?: FinalPrice;
  };
  visibility: string;
  queryType: string;
  itemType: string;
}

interface ItemImage {
  label: string;
  roles: string[];
  url: string;
}

export interface Price {
  value: number | null;
  currency: string | null;
}

export interface FinalPrice {
  final?: {
    amount?: Price;
  };
}

export interface RecommendationsResponse {
  results: RecommendationUnitModel[];
  totalResults: number;
}

export interface GraphQLResponse {
  errors?: Array<{ message: string }>;
  data?: {
    recommendations: RecommendationsResponse;
  };
}
```

## Supported Slots

The `ProductList` container supports the following slots:

* **Heading** - Customize the recommendations heading
* **Footer** - Customize the action button area (Add to Cart / View Product)
* **Title** - Customize the product title display
* **Sku** - Customize the SKU display
* **Price** - Customize the price display
* **Thumbnail** - Customize the product image display

Each slot receives context data relevant to its purpose, allowing for highly customizable product displays.

## Example configuration

The following example demonstrates how to render the `ProductList` container with the `recId`, `currentSku`, and `routeProduct` callbacks with different slots:

```js

// Render Container
provider.render(ProductList, {
  recId: 'recommendation-unit-1',
  routeProduct: (item) => `/products/${item.urlKey}`,
  currentSku: 'ADB150',
  hideHeading: false,
  slots: {
      // Example of how to prepend or append to the default Heading
      Heading: (ctx) => {
        const heading = document.createElement('div');
        heading.innerText = 'Slot: Content before default heading';
        ctx.prependChild(heading);
        const footer = document.createElement('div');
        footer.innerText = 'Slot: Content after default heading';
        ctx.appendChild(footer);
      },

      // Example of how to prepend or append to the default Thumbnail
      Thumbnail: (ctx) => {
        const thumbnail = document.createElement('div');
        thumbnail.innerText = 'Slot: Content before default thumbnail';
        ctx.prependChild(thumbnail);
        const footer = document.createElement('div');
        footer.innerText = 'Slot: Content after default thumbnail';
        ctx.appendChild(footer);
      },

      // Example of how to prepend or append to the default Price
      Price: (ctx) => {
        const price = document.createElement('div');
        price.innerText = 'Slot: Content before default price';
        ctx.prependChild(price);
        const footer = document.createElement('div');
        footer.innerText = 'Slot: Content after default price';
        ctx.appendChild(footer);
      },

      // Example of how to replace default Footer with a custom footer based on product type
      Footer: (ctx) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'footer__wrapper';
        const addToCart = document.createElement('div');
        addToCart.className = 'footer__button--add-to-cart';
        wrapper.appendChild(addToCart);

        if (ctx.product.itemType === 'SimpleProductView') {
          // Add to Cart Button
          UI.render(Button, {
            children: 'Add to Cart',
            onClick: () => {
              // Call add to cart function from cart/api
              console.log('Add to Cart');
            },
            variant: 'primary',
          })(addToCart);
        } else {
          // View Product Button
          UI.render(Button, {
            children: 'Select Options',
            onClick: () => {
              console.log('Select Options');
              window.location.href = ctx.product.urlKey;
            },
            variant: 'tertiary',
          })(addToCart);
        }
        ctx.replaceWith(wrapper);
      },
    },
}));

```

## Key Features

- **Automatic Data Fetching**: Fetches recommendations based on `currentSku` and other context
- **Intersection Observer**: Automatically tracks when recommendations are viewed
- **Event Publishing**: Publishes render and view events for analytics
- **Loading States**: Handles loading states during data fetching
- **Empty States**: Gracefully handles empty recommendation results
- **Internationalization**: Supports multiple languages through i18n
- **Customizable Slots**: Extensive customization options for all UI elements

---

# Recommendations dictionary

The default recommendations dictionary file (`i18n/en_US.json`) contains the default values for all labels and text common to the recommendations drop-in component.

## Default keys and values

---

# Recommendations Data & Events

{/*
  âš ï¸ TEMPLATE USAGE GUIDE âš ï¸
  
  This template is used by scripts/generate-events-docs.js to generate event documentation.
  
  WHAT THE SCRIPT USES FROM THIS TEMPLATE:
  - Section headings and descriptive text (used as-is)
  - Import statements
  - The REPEAT_FOR_EACH_EVENT block (replicated for each event)
  - Placeholders: Recommendations, Recommendations, EVENT_NAME, etc.
  
  WHAT THE SCRIPT GENERATES INDEPENDENTLY:
  - Table contents between START/END markers (example rows are for reference only)
  - Event-specific data (names, descriptions, payloads from source repos)
  
  TO CHANGE:
  - Section text/descriptions â†’ Edit this template
  - Table structure (columns, links, formatting) â†’ Edit scripts/generate-events-docs.js
  - Both template and script must be kept in sync for table structure changes
*/}


The **Recommendations** drop-in uses the [event bus](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/) to emit and listen to events for communication between drop-ins and external integrations. For common events shared across multiple drop-ins (such as `locale`, `error`, `authenticated`, etc.), see the [Common events reference](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/#common-events-reference).


<strong>Version: 1.1.1</strong>


> **Note:** **New to drop-in events?** Learn about the [event system architecture](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/), including the publish-subscribe pattern, subscription configuration, and best practices for event handling.

## Events reference

{/* EVENTS_TABLE_START */}


| Event | Direction | Description |
|-------|-----------|-------------|
| [recommendations/data](#recommendationsdata-emits-and-listens) | Emits and listens | Triggered when data is available or changes |


{/* EVENTS_TABLE_END */}

## Event details

The following sections provide detailed information about each event, including its direction, data payload structure, and usage examples.


### `recommendations/data` (emits and listens)

Triggered when data is available or changes

#### Data payload

```typescript
RecommendationUnitModel[] | null
```



#### Usage

Listen to this event in your storefront:

```javascript

const recommendationsDataListener = events.on('recommendations/data', (data) => {
  console.log('recommendations/data event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
recommendationsDataListener.off();
```

---

# Product Recommendations functions

This topic provides the details and instructions you need to use the functions provided by the product recommendations drop-in component.

## getRecommendations

The `getRecommendations` function retrieves product recommendations based on various parameters such as page type, current SKU, cart items, and user history. The function calls the GraphQL recommendations query and transforms the response into a standardized format.

```ts
export const getRecommendations = async (params: {
  pageType: string;
  currentSku: string;
  cartSkus?: string[];
  userPurchaseHistory?: any[];
  userViewHistory?: any[];
}): Promise<RecommendationUnitModel | null>
```



### Returns

Returns a promise that resolves to a `RecommendationUnitModel` object or null. The recommendations data is transformed into a standardized format before being returned.

### RecommendationUnitModel

The `RecommendationUnitModel` object has the following shape:

```ts
export type PageType = 'Product'; // Always hardcoded to 'Product' per requirements

export interface RecommendationUnitModel {
  displayOrder: number;
  pageType: PageType;
  title: string;
  items: Item[];
  totalProducts: number;
  typeId: string;
  unitId: string;
  unitName: string;
}

export interface Item {
  uid: string;
  sku: string;
  name: string;
  urlKey: string;
  images: ItemImage[];
  price: FinalPrice;
  priceRange?: {
    minimum?: FinalPrice;
    maximum?: FinalPrice;
  };
  visibility: string;
  queryType: string;
  itemType: string;
}

interface ItemImage {
  label: string;
  roles: string[];
  url: string;
}

export interface Price {
  value: number | null;
  currency: string | null;
}

export interface FinalPrice {
  final?: {
    amount?: Price;
  };
}

export interface RecommendationsResponse {
  results: RecommendationUnitModel[];
  totalResults: number;
}

export interface GraphQLResponse {
  errors?: Array<{ message: string }>;
  data?: {
    recommendations: RecommendationsResponse;
  };
}
```

### Events

The event bus emits the `recommendations/data` event with the transformed recommendations data as the payload.

### Usage

To get recommendations for a product page:

```js

getRecommendations({
  pageType: 'Product',
  currentSku: 'VA19-GO-NA',
  cartSkus: ['VT02-PE-M', 'VA19-GO-NA'],
  userPurchaseHistory: [],
  userViewHistory: []
});
```

To get recommendations with user history:

```js

getRecommendations({
  pageType: 'Product',
  currentSku: 'VA19-GO-NA',
  userPurchaseHistory: [
    { sku: 'VT02-PE-M', timestamp: '2024-03-20T10:00:00Z' }
  ],
  userViewHistory: [
    { sku: 'VA19-GO-NA', timestamp: '2024-03-20T09:00:00Z' }
  ]
});
```

---

# Product Recommendations overview

The product recommendations drop-in component provides a powerful way to suggest products to customers based on their browsing patterns and behaviors. These recommendations are displayed as units with descriptive labels such as "Customers who viewed this product also viewed" or "Customers who bought this product also bought". The component can be managed and deployed across different store views directly from the Adobe Commerce Admin.

## Supported Commerce features

The following table provides an overview of the Adobe Commerce features that the product recommendations component supports:

| Feature                                                          | Status                                       |
| ---------------------------------------------------------------- | -------------------------------------------- |
| Product-based recommendations                                    |  |
| Category-based recommendations                                   |  |
| Personalized recommendations                                     |  |
| Real-time recommendation updates                                |  |
| Multiple recommendation types per page                          |  |
| Custom recommendation labels                                    |  |
| A/B testing support                                            |  |
| Analytics integration                                          |  |
| Cross-sell recommendations                                     |  |
| Up-sell recommendations                                       |  |
| Related products                                              |  |
| Recently viewed products                                      |  |
| Popular products                                              |  |
| Trending products                                             |  |
| No-code UI configurations                                     |  |
| Slots for extensibility                                      |  |

## Section topics

The topics in this section will help you understand how to customize and use the product recommendations effectively within your storefront.

### Installation

Provides the step-by-step process for embedding product recommendations into your site. This topic covers everything from basic setup requirements to more advanced configurations, ensuring that the drop-in component integrates seamlessly with your existing website architecture. It is designed for compatibility with modern web technologies, focusing on ease of use and flexibility for developers. Visit the [recommendations installation](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/recommendations/installation/) page to get started.

### Styles

Describes how to customize the appearance of the product recommendations using CSS. We provide guidelines and examples for applying styles to various components within the drop-in. This customization allows brands to align the drop-in component's look and feel with their overall design aesthetic, enhancing brand consistency across the platform. Visit the [recommendations styles](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/recommendations/styles/) page to learn more.

### Containers

Describes the structural elements of the product recommendations, specifically focusing on how the container manages and displays content. It includes information on configuration options and how to leverage these settings to customize the user experience. Understanding the container is essential for developers looking to optimize the layout and styling of the recommendations. Visit the recommendations containers page to learn more.

### Slots

Slots allow developers to customize the appearance of the product recommendations by adding or modifying content within specific sections of the drop-in component. Visit the [recommendations slots](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/recommendations/slots/) page to learn more.

### Functions

Describes the API functions available in the Product Recommendations dropin. These functions allow developers to retrieve and display detailed recommendation information dynamically. Visit the [Recommendations Functions](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/recommendations/functions/) page to learn more.

---

# Product Recommendations Installation

This guide will help you install and configure the product recommendations drop-in component in your storefront.

## Prerequisites

Before you begin, ensure you have:

- Adobe Commerce instance with Product Recommendations enabled
- Access to your store's GraphQL endpoint
- Required API keys and credentials
- Node.js and npm installed on your development environment

## Step-by-step

Use the following steps to install the product recommendations component:

:::note[Edge Delivery Service]
These steps are specific for Edge Delivery Services projects, and may not necessarily be the same for other frameworks such as a static HTML or React framework.
:::



<Task>

### Install the packages

Use a CDN or NPM (recommended for performance) to install the drop-in component tools (`@dropins/tools`) and product recommendations (`@dropins/storefront-recommendations`) packages.

<Tabs>
  <TabItem label="NPM" icon="seti:npm">

    ```bash frame="none"
    npm install @dropins/tools @dropins/storefront-recommendations
    ```

  </TabItem>
  <TabItem label="CDN" icon="external">

    ```html title="index.html" del={"Replace with actual URLs":5-7}
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Your Storefront</title>

      <script src="https://cdn.jsdelivr.net/npm/@dropins/tools@latest"></script>
      <script src="https://cdn.jsdelivr.net/npm/@dropins/storefront-recommendations@latest"></script>
    </head>
    ```

  </TabItem>
</Tabs>

:::note[Install @dropins/tools]
All drop-in components require the `@dropins/tools` package. This package contains the libraries that drop-in components need to initialize and communicate, including `fetch-graphql`, `event-bus`, and `initializer` utilities.
:::

</Task>

<Task>
### Map the packages

In the `<head>` tag of your `index.html` or `head.html` file, use an `importmap` pointed to the `node_modules` directory, a **custom local directory**, or **CDN** (for run-time environments).

<Tabs>
<TabItem label="node_modules" icon="seti:npm">
    This example shows an `importmap` added to a `head.html` The `importmap` points both packages to the local `node_modules` directory that contains your installed drop-in component files from the drop-in component tools (@dropins/tools) and the product recommendations (@dropins/storefront-recommendations):

  ```html title="head.html"
  <script type="importmap">
    {
      "imports": {
        "@dropins/tools/": "/node_modules/@dropins/tools/",
        "@dropins/storefront-recommendations/": "/node_modules/@dropins/storefront-recommendations/",
      }
    }
  </script>
  <script src="/scripts/scripts.js" type="module"></script>
    ```
  </TabItem>
    <TabItem label="custom" icon="seti:folder">
    This example shows an `importmap` added to a `head.html` The `importmap` points both packages to local directories that contain all the optimized/minified files from the drop-in component tools (@dropins/tools) and the product recommendations (@dropins/storefront-recommendations):

    ```html title="head.html"
    <script type="importmap">
      {
        "imports": {
          "@dropins/tools/": "/scripts/__dropins__/tools/",
          "@dropins/storefront-recommendations/": "/scripts/__dropins__/storefront-recommendations/",
        }
      }
    </script>
    <script src="/scripts/scripts.js" type="module"></script>
    ```

  </TabItem>
  <TabItem label="CDN" icon="external">
    This example shows an `importmap` pointing both packages to a CDN for the drop-in component tools (@dropins/tools) and the product recommendations (@dropins/storefront-recommendations):

    ```html title="index.html" {"Replace CDN URLs with correct URLs":5-7} del='https://cdn.jsdelivr.net/npm/'
    <head>
      <script type="importmap">
        {
          "imports": {

            "@dropins/tools/": "https://cdn.jsdelivr.net/npm/@dropins/tools@latest",
            "@dropins/storefront-recommendations/": "https://cdn.jsdelivr.net/npm/@dropins/storefront-recommendations@latest",
          }
        }
      </script>
    </head>
    ```

  </TabItem>

</Tabs>

With the `importmap` defined for both runtime and build-time environments, you can now **import the required files** from these packages into your product recommendations block as described in the next step.

</Task>

<Task>
### Import the required files

Import the required files from the drop-in components tools (`@dropins/tools/fetch-graphql.js'`, `@dropin/tools/initializers.js`) and the product recommendations (`@dropins/storefront-recommendations`) into a JavaScript file for your product recommendations block. The example here shows the imports added to a `product-recommendations.js` file. These imports constitute the minimum imports you need to create a fully functioning product recommendations for your site:

```js title="product-recommendations.js"

// component tools

// drop-in component functions

// Drop-in component provider

// Drop-in component containers
```

</Task>

<Task>
### Connect to the endpoint

Connect your product recommendations component to the Catalog Service GraphQL endpoint and set the required headers as shown in the example below. Replace the endpoint URL and header placeholder values with the actual values from your Commerce backend services:

```js title="product-recommendations.js"
// Set endpoint configuration
product.setEndpoint('https://<catalog-service-endpoint>/graphql');

product.setFetchGraphQlHeaders({
  // Environment required headers
  'Magento-Environment-Id': 'your-environment-id',
  'Magento-Store-View-Code': 'your-store-view-code',
  'Magento-Website-Code': 'your-website-code',
  'x-api-key': 'your-api-key',
  'Magento-Store-Code': 'main_website_store',
  'Magento-Customer-Group': 'your-customer-group',
  'Content-Type': 'application/json',
});
```

</Task>

<Task>
### Register and load the drop-in

The code below shows how to register the product recommendations component, load it (mount), and enable the logger for debugging purposes. You can add these functions within a `<script>` tag in your product recommendations HTML page as shown here:

```html title="index.html" ins={"1":5} ins={"2":8}
<script type="module">
  // more code above...

  // Register and load the Product Recommendations drop-in
  initializers.register(pkg.initialize);

  // Mount Initializers (must be called after all initializers are registered)
  window.addEventListener('load', initializers.mount);
</script>
```

<Callouts square color="var(--sl-color-green)">

1. This function registers the product recommendations component to be loaded on the page by the `initializers.mount` function.
1. This event handler triggers the initializers.mount function to load the product recommendations component after the page has loaded.

</Callouts>

</Task>




## Recommendation types

The following recommendation types are available:

| Type | Description |
|------|-------------|
| viewed | Products viewed by other customers |
| bought | Products bought by other customers |
| related | Related products based on category |
| trending | Currently trending products |
| popular | Most popular products |
| recently-viewed | Recently viewed products by the current customer |

## Placement options

You can place recommendations in various locations:

- Product page
- Category page
- Cart page
- Checkout page
- Home page
- Search results page

---

# Product Recommendations slots

Learn about the slots provided in the product recommendations drop-in component.

## ProductList slots

```js
interface ProductListProps

slots?: {
  Heading?: SlotProps;
  Price?: SlotProps;
  Thumbnail?: SlotProps;
  Footer?: SlotProps;
};
```

### Heading slot

The `Heading` slot allows you to add content to the top of the `ProductList` container.

```js
 provider.render(ProductList, {
  slots: {
    Heading: (ctx) => {
      // Runs on mount
      const heading = document.createElement('h2');
      heading.innerText = 'Recommendations Product List';
      ctx.appendChild(heading);
    },
  },
})($list),
```

### Price slot

The `Price` slot allows you to prepend or append to the default Price.

```js

Price: (ctx) => {
  const price = document.createElement('div');
  price.innerText = 'Slot: Content before default price';
  ctx.prependChild(price);
  const footer = document.createElement('div');
  footer.innerText = 'Slot: Content after default price';
  ctx.appendChild(footer);
},
```

### Thumbnail slot

The `Thumbnail` slot allows you to prepend or append to the default thumbnail.

```js
Thumbnail: (ctx) => {
  const thumbnail = document.createElement('div');
  thumbnail.innerText = 'Slot: Content before default thumbnail';
  ctx.prependChild(thumbnail);
  const footer = document.createElement('div');
  footer.innerText = 'Slot: Content after default thumbnail';
  ctx.appendChild(footer);
},
```

### Footer slot

The `Footer` slot allows you to add content to the bottom of the `ProductList` container.

The following example shows how to replace the default Footer with a custom footer based on product type.

```js
Footer: (ctx) => {
  const wrapper = document.createElement('div');
  wrapper.className = 'footer__wrapper';
  const addToCart = document.createElement('div');
  addToCart.className = 'footer__button--add-to-cart';
  wrapper.appendChild(addToCart);

  if (ctx.product.itemType === 'SimpleProductView') {
      // Add to Cart Button
      UI.render(Button, {
        children: 'Add to Cart',
        onClick: () => {
            // Call add to cart function from cart/api
            console.log('Add to Cart');
          },
          variant: 'primary',
        })(addToCart);
      } else {
      // View Product Button
      UI.render(Button, {
        children: 'Select Options',
          onClick: () => {
            console.log('Select Options');
            window.location.href = ctx.product.urlKey;
          },
          variant: 'tertiary',
          })(addToCart);
      }
    ctx.replaceWith(wrapper);
},
```

---

# Product Recommendations styles

The CSS classes for each UI component that provides the recommendations drop-in component with its UI are provided here. Override these classes and add new classes to customize the look and feel of your recommendations to match your specific style requirements.

## Customizing your recommendations styles

The quickest way to override the recommendations CSS is to inspect the recommendation UI from your browser's developer tools.


  ![Find CSS classes to override](@images/dropins/findstylesrecommendations.png/)




1. **Inspect the element** in the UI that you want to customize (right-click on the element and select "Inspect" from the menu).
1. **Identify the CSS class(es)** for the element. We use [BEM naming](https://getbem.com/naming/), which makes it easy to know which component you're changing (and which CSS file to use). This class styles the `Recommendations` component, so use your `recommendations.css` file.
1. **Copy the CSS class** to your `recommendations.css` file to override the existing rules or add new rules to the class. But wait! Look closely ðŸ§ at the `.dropin-product-item-card__title` class. It's using **design token**. And when you see a design token within a CSS rule, don't remove the token. Instead, change the token's value (where it's defined) OR create a new token along-side this existing one to ensure maintenance and updates continue to benefit from global design token usage.



## Example CSS overrides

Here's an example of adding CSS class overrides to your `recommendations.css` file:

```css title="recommendations.css"
.dropin-product-item-card__title {
    font: var(--type-body-1-strong-font);
    letter-spacing: var(--type-body-1-strong-letter-spacing);
}

.dropin-product-item-card__sku, .dropin-product-item-card__price {
    font: var(--type-body-1-default-font);
}

.dropin-product-item-card__action {
    margin-top: var(--spacing-xsmall);
    width: 100%;
}
```

## Recommendations component CSS

The CSS classes for recommendations component is provided here.



## Summary

You can customize the recommendations by overriding the CSS classes provided for component. Create a CSS file for each component to make it easier to maintain and update your recommendations CSS. Use the BEM naming convention and your browser's dev tools to identify and copy the class to your corresponding component CSS file and override it as needed. Happy styling! ðŸŽ¨

---

# AddressForm container

The `AddressForm` container is a standalone component designed for creating and editing customer addresses. This container enables merchants to build a custom user experience around address management while leveraging a pre-built form that minimizes development effort. The form integrates seamlessly with the Adobe Commerce backend environment, providing flexible configuration of address attributes, validation, labels, attribute sorting, and more.

The [`Addresses`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/containers/addresses/) container also uses this container.

The following image illustrates a sample AddressForm container:


  ![AddressForm container](@images/dropins/user-account/address-form-container.png/)


> **Note:** Custom address attributes and attribute validation are supported. See [Customer attribute properties](https://experienceleague.adobe.com/en/docs/commerce-admin/customers/customer-accounts/attributes/attribute-properties) in the _Customer Management Guide_ for more information.

## Configurations

The `AddressForm` container provides the following configuration options:



## Examples

HTMLInputElement usage sample:

```javascript
const formRef = { current: null };

provider.render(AddressForm, {
  forwardFormRef: formRef,
})(containerWrapper);

const isFormValid = formRef.current.handleValidationSubmit();
const formData = inputRef.current.formData;

return { 
    handleValidationSubmit,
    formData: normalizeGetAddressData(modifyFormRef, true),
    isDataValid, 
    }; 
```

`isDataValid` is a boolean value that indicates whether the form has been validated without an explicit submit action.

inputsDefaultValueSet sample payload:

```javascript
inputsDefaultValueSet: {
  city: 'City',
  company: '',
  countryCode: 'AR',
  region: {
    regionCode: 'AR-H',
    regionId: 1579,
  },
  telephone: '123456789',
  vatId: '999',
  postcode: '12345',
  street: 'Street One',
  streetMultiline_2: 'Street Two',
}
```

## Example

The following example renders the `AddressForm` container with custom configurations:

```js
provider.render(AddressForm, {
 addressesFormTitle: 'Address form title',
 addressId: '',
 isOpen: true,
 shippingCheckBoxValue: true,
 billingCheckBoxValue: true,
 showShippingCheckBox: true,
 showBillingCheckBox: true,
 onChange: (values, inputValue) => {
   console.log('allValues', values);
   console.log('inputValue', inputValue);
 },
 onSuccess: () => {
   console.log('onSuccess');
 },
 onError: () => {
   console.log('onError');
 },
})(containerWrapper);
```

---

# AddressValidation container

The `AddressValidation` container displays a suggested shipping address (from a third-party verification service) alongside the entered address, allowing shoppers to choose between them.

Typically invoked from a modal during address creation after calling your address verification service.

## AddressValidation configurations

The `AddressValidation` container provides the following configuration options:

<OptionsTable
  compact
  options={[
    ['Option', 'Type', 'Req?', 'Description'],
    ['originalAddress', 'CustomerAddressesModel | null', 'Yes', 'Original address set by the user.'],
    ['suggestedAddress', 'Partial<CustomerAddressesModel> | null', 'Yes', 'Address suggestion to present to the user.'],
    ['handleSelectedAddress', 'function', 'No', 'Async callback fired when the shopper selects an address. Receives the selection and the chosen address.'],
  ]}
/>

### AddressValidationProps interface

The `AddressValidation` container receives an object that implements the following interface:

```ts
interface AddressValidationProps {
  selectedAddress?: 'suggested' | 'original' | null;
  suggestedAddress: Partial<CustomerAddressesModel> | null;
  originalAddress: CustomerAddressesModel | null;
  handleSelectedAddress?: (payload: {
    selection: 'suggested' | 'original';
    address: CustomerAddressesModel | null | undefined;
  }) => void;
}
```

## CustomerAddressesModel type

The `CustomerAddressesModel` type has this shape:

```ts
interface CustomerAddressesModel {
  city?: string;
  countryCode?: string;
  region?: { region: string; regionCode: string; regionId: string | number };
  postcode?: string;
  street?: string;
}
```

> **Note:** Transform your address verification service output to `CustomerAddressesModel` format (with fields like `street`, `city`, `region`, `countryCode`, `postcode`) before passing it to the container. Missing properties default to the original address values.

## Example

For a complete walkthrough, see the [Validate address](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/tutorials/validate-address/) tutorial.

---

# Addresses container

The `Addresses` container is a standalone component that creates, edits, and deletes customer addresses. It supports custom address attributes and configurable validation through the Adobe Commerce Admin.

The `Addresses` container relies on the [`AddressForm`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/containers/address-form/) container for address creation and editing. It inherits all behaviors from the `AddressForm` container.

## Container views
The Addresses container can be implemented in several views.

### Full-size view

The full-size view is used when the `Addresses` component functions as a standalone page. This view displays all addresses, enables pagination (based on backend configurations), and provides full functionality for creating, editing, and deleting addresses. A **Create Address** button can be displayed below the list. Clicking the button opens the address creation form, which is configurable from the Commerce Admin.

The following images illustrate the full-size view of the Addresses container with no addresses, all addresses, and an address being edited.


  ![Full size implementation of the Addresses container with no addresses](@images/dropins/user-account/addresses-full-empty.png/)



  ![Full size implementation of the Addresses container with multiple addresses](@images/dropins/user-account/addresses-full-all.png/)



  ![Full size implementation of the Addresses container being edited](@images/dropins/user-account/addresses-full-edit.png/)


### Minified view

Use the minified view when the container is part of a page with other components, such as a user account dashboard. In this view, editing and deletion functionality is disabled, and the **Create New Address** button is replaced with a **View All Addresses** button. Only the default shipping and billing addresses are visible.

The following images illustrate the minified view of the Addresses container with no addresses, and with multiple addresses (but only one is displayed).


  ![Empty minified Addresses container](@images/dropins/user-account/addresses-minified-multiple.png/)



  ![Minified Addresses container with multiple addresses](@images/dropins/user-account/addresses-minified-multiple.png/)


### Selectable view

The selectable view is intended for scenarios that require address selection, such as during checkout. This view includes styling adjustments and represents each address card as a selectable radio button, facilitating address selection.

The following images illustrate the selectable view of the Addresses container. In the first image an address has been selected. In the second, an address can be created.


  ![Selectable Addresses container with selection](@images/dropins/user-account/addresses-selectable-selected.png/)



  ![Create an address in a selectable Addresses container](@images/dropins/user-account/addresses-selectable-new-address.png/)


> **Note:** Custom address attributes and attribute validation are supported. See [Customer attribute properties](https://experienceleague.adobe.com/en/docs/commerce-admin/customers/customer-accounts/attributes/attribute-properties) in the _Customer Management Guide_ for more information.

## Configurations

The Addresses container provides the following configuration options:



## Example

The following example demonstrates how to use the Addresses container:

```javascript
export default async function decorate(block) {
 const {
   'minified-view': minifiedViewConfig = 'false',
 } = readBlockConfig(block);

 if (!checkIsAuthenticated()) {
   window.location.href = CUSTOMER_LOGIN_PATH;
 } else {
   await accountRenderer.render(Addresses, {
     minifiedView: minifiedViewConfig === 'true',
     withActionsInMinifiedView: false,
     withActionsInFullSizeView: true,
     routeAddressesPage: () => CUSTOMER_ADDRESS_PATH,
   })(block);
 }
}


```

---

# CustomerInformation container

The `CustomerInformation` container is a standalone component that provides customers with access to their personal information. It allows users to view and edit their profile details, including their name, contact information, password, and email address.

The following images show the default view, edit view, edit view with password input, and change password view of the CustomerInformation container:


  ![Default view](@images/dropins/user-account/customer-info-default.png/)



  ![Edit view](@images/dropins/user-account/customer-info-edit.png/)



  ![Edit view with password input](@images/dropins/user-account/customer-info-edit-with-password.png/)



  ![Change password view](@images/dropins/user-account/customer-info-change-password.png/)


> **Note:** Custom customer attributes and attribute validation are supported. See [Customer attribute properties](https://experienceleague.adobe.com/en/docs/commerce-admin/customers/customer-accounts/attributes/attribute-properties) in the _Customer Management Guide_ for more information.

## Configurations

The CustomerInformation container provides the following configuration options:



## Example

The following example demonstrates how to use the CustomerInformation container:

```javascript
export default async function decorate(block) {
  if (!checkIsAuthenticated()) {
    window.location.href = CUSTOMER_LOGIN_PATH;
  } else {
    await accountRenderer.render(CustomerInformation, {})(block);
  }
}
```

---

# User Account containers

User Account containers manage account information, addresses, and order history. The following containers provide the building blocks for complete account management experiences.



| Container | Description |
|-----------|-------------|
| [AddressForm](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/containers/address-form/) | Add or edit customer addresses. |
| [Addresses](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/containers/addresses/) | Manage shipping and billing addresses. |
| [AddressValidation](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/containers/address-validation/) | Validate addresses for accurate delivery. |
| [CustomerInformation](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/containers/customer-information/) | Profile information: name, email, and contact details. |
| [OrdersList](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/containers/orders-list/) | Order history with details and status. |

---

# OrdersList container

The `OrdersList` container is a standalone component designed to provide access to a customer's order history and detailed order information. It can be rendered in a full-size or minified view.

Use the full-size view when the `OrdersList` component functions as a standalone page. This view displays the complete list of orders, includes a filter for filtering by the date placed. It also features pagination, which is visible if the number of orders exceeds one page.


  ![Full-size view with no order list items](@images/dropins/user-account/orders-full-no-orders.png/)



  ![Full-size view with multiple items](@images/dropins/user-account/customer-info-edit.png/)


The minified view can be usef when the container is part of a page alongside other components, such as a user account dashboard. In this view, only a few of the most recent orders are displayed (the number is configurable). A **View all orders** button is rendered at the bottom, which navigates the customer to the full order history page.


  ![Minified view with no items](@images/dropins/user-account/orders-minified-none.png/)



  ![Minified view with multiple items](@images/dropins/user-account/orders-minified-multiple.png/)


## OrdersList configurations

The OrdersList container provides the following configuration options:



## Example

The following example demonstrates how to use the OrdersList container:

```javascript
export default async function decorate(block) {
 const { 'minified-view': minifiedViewConfig = 'false' } = readBlockConfig(block);

 if (!checkIsAuthenticated()) {
   window.location.href = CUSTOMER_LOGIN_PATH;
 } else {
   await accountRenderer.render(OrdersList, {
     minifiedView: minifiedViewConfig === 'true',
     routeOrdersList: () => CUSTOMER_ORDERS_PATH,
     routeOrderDetails: (orderNumber) => `${CUSTOMER_ORDER_DETAILS_PATH}?orderRef=${orderNumber}`,
     routeReturnDetails: ({ orderNumber, returnNumber }) => `${CUSTOMER_RETURN_DETAILS_PATH}?orderRef=${orderNumber}&returnRef=${returnNumber}`,
     routeOrderProduct: (productData) => (productData ? `/products/${productData.product.urlKey}/${productData.product.sku}` : '#'),
   })(block);
 }
}
```

---

# User account dictionary

The default user account dictionary file (`i18n/en_US.json`) contains the default values for all labels and text common to the user account drop-in component.

## Default keys and values

---

# User Account Data & Events

The **User Account** drop-in uses the [event bus](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/events/) for communication between drop-ins and external integrations.


<strong>Version: 1.2.0</strong>


## Events

This drop-in does not emit or listen to any drop-in-specific events. This drop-in focuses on UI presentation and data display, relying on function calls rather than event-driven communication for its core functionality. It uses only common events for standard cross-component functionality like localization and error handling.

For information about common events like `locale`, `error`, and `authenticated`, see the [common events reference](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/#common-events-reference).

---

# User account functions

The user account drop-in component provides API functions that allow developers to retrieve and display account details, including shipping and billing addresses and previous orders.

## createCustomerAddress

The `createCustomerAddress` function creates an address for an existing customer using the `CustomerAddressesModel` object as an argument. The function calls the [`createCustomerAddress`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/create-customer-address/) mutation.

```ts
export const createCustomerAddress = async (
  address: CustomerAddressesModel
): Promise<string>
```



The `CustomerAddressesModel` object has the following fields:




### Returns

Returns a promise that resolves to a string, which could be a success message or an error message.

### Usage

To create a new address:

```ts

const address = {
  firstName: 'John',
  lastName: 'Doe',
  city: 'Los Angeles',
  company: 'Adobe',
  countryCode: 'US',
  region: {
    region: 'California',
    regionCode: 'CA',
    regionId: '12',
  },
  telephone: '1234567890',
  postcode: '90001',
  street: '123 Main St',
  streetMultiline_2: 'Suite 100',
  defaultShipping: true,
  defaultBilling: true,
};
```

## getAttributesForm

The `getAttributesForm` function uses the [`attributesForm`](https://developer.adobe.com/commerce/webapi/graphql/schema/attributes/queries/attributes-form/) query to retrieve EAV attributes associated with customer and customer address frontend forms. The `formCode` parameter must be one of the following values: `customer_account_create`, `customer_account_edit`, `customer_address_create`, or `customer_address_edit`.

```ts
export const getAttributesForm = async (
  formCode: string
): Promise<AttributesFormModel[]>
```



### Returns

Returns a promise that resolves to an `AttributesFormModel` array. It has the following structure:

```javascript
{
      items {
        code
        default_value
        entity_type
        frontend_class
        frontend_input
        is_required
        is_unique
        label
        options {
          is_default
          label
          value
        }
        ... on CustomerAttributeMetadata {
          multiline_count
          sort_order
          validate_rules {
            name
            value
          }
        }
      }
      errors {
        type
        message
      }
}
```

### Usage

To get attributes associated with the `customer_address_edit` form:

```ts

getAttributesForm(formCode: 'customer_address_edit');
```

## getCountries

The `getCountries` function uses the [`countries`](https://developer.adobe.com/commerce/webapi/graphql/schema/directory/queries/countries/) query to retrieve a list of countries.

```ts
export const getCountries = async (): Promise<{
  availableCountries: Country[] | [];
  countriesWithRequiredRegion: string[];
  optionalZipCountries: string[];
}>
```

### Returns

Returns a promise that resolves to arrays of countries, regions, and postal codes.

```ts
{
    countries {
      two_letter_abbreviation
      full_name_locale
    }
    storeConfig {
      countries_with_required_region
      optional_zip_countries
    }
}
```

### Usage

To get a list of countries:

```javascript

getCountries();
```

## getCustomer

The `getCustomer` function retrieves the customer information for the logged-in customer. The function uses the [`customer`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/customer/) query.

```ts
export const getCustomer = async (): Promise<CustomerDataModelShort>
```

### Returns

Returns a promise that resolves to `CustomerDataModelShort` object:

```ts
export interface CustomerDataModelShort {
  firstName: string;
  lastName: string;
  middleName: string;
  dateOfBirth: string;
  dob: string;
  prefix: string;
  gender: 1 | 2 | string;
  suffix: string;
  email: string;
  createdAt: string;
  [key: string]: string | boolean | number;
}
```

### Usage

To get details about the customer:

```javascript

getCustomer();
```

## getCustomerAddress

The `getCustomerAddress` function returns an array of addresses associated with the current customer. The function uses the [`customer`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/customer/) query.

```ts
export const getCustomerAddress = async (): Promise<
  CustomerAddressesModel[]
>
```

### Returns

Returns a promise that resolves to `CustomerAddressesModel` object:

```ts
export interface CustomerAddressesModel {
  firstName?: string;
  lastName?: string;
  city?: string;
  company?: string;
  countryCode?: string;
  region?: { region: string; regionCode: string; regionId: string | number };
  telephone?: string;
  id?: string;
  vatId?: string;
  postcode?: string;
  street?: string;
  streetMultiline_2?: string;
  defaultShipping?: boolean;
  defaultBilling?: boolean;
}
```

### Usage

To get information about the customer address:

```javascript

getCustomerAddress();
```

## getOrderHistoryList

The `getOrderHistoryList` function is an asynchronous function that retrieves a list of customer orders using the [`customer`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/customer/) query. It optionally takes parameters for pagination and filtering.

```ts
export const getOrderHistoryList = async (
  pageSize: number,
  selectOrdersDate: string,
  currentPage: number
): Promise<OrderHistory | null>
```



### Returns

Returns a promise that resolves to an `OrderHistory` object or null.

### Usage

To get a list of customer orders:

```ts

getOrderHistoryList();
```


## getRegions

The `getRegions` function uses the [`country`](https://developer.adobe.com/commerce/webapi/graphql/schema/directory/queries/country/) query to retrieve a list of states or provinves for a specific country.


```ts
export const getRegions = async (
  countryCode: string
): Promise

### Returns

Returns a promise that resolves to a `RegionTransform` array:

```ts
export interface RegionTransform {
  text: string;
  value: string;
  id?: string | number;
}
```

### Usage

To get a list of regions for a specific country:

```ts

getRegions(countryCode: "AS");
```

## getStoreConfig

The `getStoreConfig` function uses the [`storeConfig`](https://developer.adobe.com/commerce/webapi/graphql/schema/store/queries/store-config/) query to retrieve details about password requirements.

```ts
export const getStoreConfig = async (): Promise<StoreConfigModel>
```

### Returns

Returns a promise that resolves to a `StoreConfigModel` object:

```ts
export interface StoreConfigModel {
  minLength: number;
  requiredCharacterClasses: number;
}
```

### Usage

To get the store configuration:

```ts

getStoreConfig();
```

## removeCustomerAddress

The `removeCustomerAddress` function removes an address associated with the current customer. The function uses the [`deleteCustomerAddress`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/delete-address/) mutation.


```ts
export const removeCustomerAddress = async (
  addressId: number
): Promise<boolean>
```



### Returns

Returns a promise that resolves to a boolean value that indicates whether the address was removed.

### Usage

To remove an address:

```ts

removeCustomerAddress(id: "1");
```

## updateCustomer

The `updateCustomer` function updates the logged-in customer. The function uses the [`updateCustomerV2`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/update-v2/) mutation.

The `form` object keys are converted to snake_case using the `convertKeysCase` utility with specific mappings for `firstName`, `lastName`, `middleName`, and `custom_attributesV2`.

```ts
export const updateCustomer = async (
  form: Record<string, string>
): Promise<string>
```



### Returns

Returns a promise that resolves to a string, which could be a success message or an error message.

### Usage

To update the customer:

```ts

updateCustomer(form: CustomerUpdateInput);
```

## updateCustomerAddress

The `updateCustomerAddress` function updates an address associated with the current customer. The function uses the [`updateCustomerAddress`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/update-address/) mutation.

The `forms` object includes an `addressId`, which is a number representing the ID of the address to be updated and other address details as defined in `CustomerAddressesModel`.

```ts
export const updateCustomerAddress = async (
  forms: ExtendedAddressFormProps
): Promise<string>
```



The `CustomerAddressesModel` object has the following shape:



### Returns

Returns a promise that resolves to a string, which could be a success message or an error message.

### Usage

To update the customer address:

```ts
updateCustomerAddress(forms: {
  "addressId": 1,
  "city": "Austin",
  "countryCode": "US",
  "countryId": "US",
  "defaultBilling": true,
  "defaultShipping": true,
  "firstname": "John",
  "lastname": "Doe",
  "postcode": "78759",
  "region": {
    "regionId": 57,
    "regionCode": "TX"
  },
  "street": ["123 Main St"],
});
```

## updateCustomerEmail

The `updateCustomerEmail` function updates the email address of the logged-in customer. The function calls the [`updateCustomerEmail`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/update-email/) mutation.

```ts
export const updateCustomerEmail = async (
  email: string,
  password: string
): Promise<string>
```



### Returns

Returns a promise that resolves to a string, which could be a success message or an error message.

### Usage

To update the customer's email address:

```ts

updateCustomerEmail(forms: {
  "email": "test@email.com",
  "password": "xyz789abc123",
});
```

## updateCustomerPassword

The `updateCustomerPassword` function updates the password of the logged-in customer. The function calls the [`changeCustomerPassword`](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/change-password/) mutation.

```ts
export const updateCustomerPassword = async ({
  currentPassword,
  newPassword,
}: ChangeCustomerPasswordProps): Promise<string>
```



### Returns

Returns a promise that resolves to a string, which could be the customer's email if the password change is successful, or an error message if there are errors.

### Usage

To update the customer's password:

```ts

updateCustomerPassword({ "currentPassword": "xyz789abc123", "newPassword": "123xyz789abc" });
```

---

# User account overview

The user account drop-in component provides account management features in your storefront.

## Supported Commerce features

The following tables provide an overview of the Adobe Commerce features that the user account drop-in component supports:

| Feature                                | Status                                     |
|----------------------------------------|--------------------------------------------|
| Add/remove new address                 |    |
| Change email                           |    |
| Change password                        |    |
| Login as customer                      |  |
| Manage products in wishlist            |   |
| Move products from wishlist to cart    |   |
| Update address                         |    |
| View addresses saved during checkout   |    |

---

# User account initialization

The user account drop-in component does not require any special data or specific parameters to be initialized. To initialize the drop-in component, you must import [`/scripts/initializers/account.js`](https://github.com/hlxsites/aem-boilerplate-commerce/blob/develop/scripts/initializers/account.js) into the appropriate file.

```js

await initializeDropin(async () => {
  const labels = await fetchPlaceholders();

  const langDefinitions = {
    default: {
      ...labels,
    },
  };

  return initializers.mountImmediately(initialize, { langDefinitions });
})();
```

The `langDefinitions` property defines and registers language packs for the user account component. This allows you to provide localized text for different languages in your application.

## Configuration options

The user account component initializer accepts the following property:



### Example

The following example initializes the `commerce-addresses` block:

```js

export default async function decorate(block) {
 const {
   'minified-view': minifiedViewConfig = 'false',
 } = readBlockConfig(block);

 if (!checkIsAuthenticated()) {
   window.location.href = CUSTOMER_LOGIN_PATH;
 } else {
   await accountRenderer.render(Addresses, {
     minifiedView: minifiedViewConfig === 'true',
     withActionsInMinifiedView: false,
     withActionsInFullSizeView: true,
     routeAddressesPage: () => CUSTOMER_ADDRESS_PATH,
   })(block);
 }
}
```

---

# User account sidebar

The user account sidebar is not part of the account component, but it is implemented as a block within the boilerplate (`commerce-account-sidebar`). Its primary function is to render a configurable sidebar menu for the user account, managed through Document Authoring.


  ![User account sidebar](@images/dropins/user-account/sidebar-overview.png/)


## Configurations

The `commerce-account-sidebar` block can be integrated into various pages via Document Authoring, as demonstrated in the screenshot below.


  ![Configuration parameters](@images/dropins/user-account/sidebar1.png/)


The content of the `commerce-account-sidebar` block is fully manageable through Document Authoring, specifically within the `/customer/sidebar-fragment` document. This structure allows for easy customization and updates, as shown in the following example:


  ![Configuration structure](@images/dropins/user-account/sidebar2.png/)


The configuration structure includes:

* **Menu item name**
  * **Second line** (optional descriptive text)
  * **Link** (URL for navigation)
  * **SDK icon name** (icon representation for each menu item)

---

# User account styles

This topic introduces you to the CSS classes for each UI component used in the user account drop-in component and shows you how to override these classes to customize the user account component's CSS styling to match your brand.

## Big Picture

The quickest way to override user account CSS is to inspect the user account UI from your browser's developer tools to discover the BEM class names you want to add to or override. This process is numbered in the image below.


  ![Find CSS classes to override](@images/dropins/user-account/find-styles-user-account.png/)




1. **Inspect the element** in the UI that you want to customize (right-click on the element and select "Inspect" from the menu).
1. **Identify the CSS class(es)** for the element. We use [BEM naming](https://getbem.com/naming/), which makes it easy to know which component you're changing (and which CSS file to use).
1. **Copy the CSS class names to override** to your custom CSS file.



## How to override the default styles



1. **Create a new CSS file** in your project for the user account component. Name the file `custom-account.css`.
1. **Copy the BEM class names** displayed in the Element tab of the developer panel into your new file.
1. **Add your custom CSS rules** to the `custom-account.css` file to add or override the default styles.
1. **Import the custom CSS file** into the `commerce-account.css` file.

   ```css
   @import 'custom-account.css';
   ```

1. **Save the file** and refresh your browser to see the changes.



## Example CSS overrides

The following example shows how to override two of the many classes for the user account component.

```css title="custom-account.css"
.checkout__heading {
  display: flex;
  justify-content: space-between;
}

.checkout__heading-title {
  line-height: 1.5;
  font-size: 1.5rem;
}
```

## Account CSS classes

The CSS classes for each user account component are provided here.

---

# Customize the layout of the AddressForm

The AddressForm container provides a highly configurable and customizable layout for seamless integration. The sorting of address attributes is managed through the Adobe Commerce Admin settings, giving flexibility in how data fields are displayed.

The visual layout of the form, including input widths (such as 50% or 100% to position multiple inputs on the same line), is controlled by CSS. This enables integrators to tailor the form's appearance by applying custom CSS rules.

By default, the first name and last name fields in the address form are set to 50% width. The display is controlled through CSS, as the form is implemented using a grid layout:


  ![Default AddressForm container](@images/dropins/user-account/address-form-two-column.png/)


To modify the layout and render these fields as full-width, create custom CSS rules at the boilerplate level and use them to override default container CSS:


  ![One column AddressForm container](@images/dropins/user-account/address-form-one-column.png/)


Using this approach, you can easily customize the address form layout during the integration process, such as implementing a three-column layout to display three fields in a row. These adjustments require only basic CSS knowledge for effective customization.

This approach is fully applicable to address forms in all views of the Addresses container, as it utilizes the AddressForm container internally.

### Layout Customisation Example

The folllwing examples show how to adjust the [storefront-addresses](https://github.com/hlxsites/aem-boilerplate-commerce/blob/develop/blocks/commerce-addresses/commerce-addresses.css) block CSS in a boilerplate environment to customize the address form layout.

In the default layout, some fields are half width, while others take up the whole width.


  ![Default layout of the AddressForm container](@images/dropins/user-account/initial-form-layout.png/)


To set all fields to half width, add the following CSS rule to the `storefront-addresses` block:

```css
.commerce-addresses .account-address-form {
   grid-template-columns: repeat(2,1fr);
}
```


  ![Two column layout of the AddressForm container](@images/dropins/user-account/two-column-layout.png/)


To set the text area and buttons group set to 100% width while the other fields are half width:

```css
.commerce-addresses .account-address-form div.account-address-form__field--test_text_area,
.commerce-addresses .account-address-form div.account-address-form-wrapper__buttons {
   grid-column: span 2;
}
```
Notice that CSS selector includes the modifier `--test_text_area`, allowing you to target a specific field by attribute code.


  ![Two column layout with full width text box](@images/dropins/user-account/mixed-layout.png/)


To create a three-column layout with a full size text and button area, set the grid template columns to `repeat(2,1fr)`:

```css
.commerce-addresses .account-address-form {
   grid-template-columns: repeat(2,1fr);
}

.commerce-addresses .account-address-form div.dropin-field {
   grid-column: span 1;
}

.commerce-addresses .account-address-form div.account-address-form__field--test_text_area,
.commerce-addresses .account-address-form div.account-address-form-wrapper__buttons {
   grid-column: span 3;
}
```


  ![Three column layout with full width text area](@images/dropins/user-account/three-column-layout.png/)

---

# Validate address in My Account

Use the `AddressValidation` container to present both the original and suggested addresses from your verification service, letting shoppers choose before saving. This tutorial shows how to integrate the container in the `commerce-addresses` block.


  ![Validate address](@images/dropins/user-account/address-validation.png/)


## Overview

At a high level:

- Call your address verification service on form submit.
- If it returns a suggestion, open a modal and render `AddressValidation`.
- If the shopper selects the suggestion, populate the form with the suggested data and re-submit; otherwise, retain the original form values.

> **Note:** Code snippets reference utilities like `showModal`, `removeModal`, and `validateAddress`. Implement these functions to match your application's needs (examples of `validateAddress` and basic CSS are provided below).

## Integration in commerce-addresses block

Update your `blocks/commerce-addresses/commerce-addresses.js` to:

- Import `AddressValidation`
- Pass `forwardFormRef`, `onAddressData`, and `onSubmit` to `Addresses`
- When a suggestion exists, show a modal with `AddressValidation` and two actions: Edit Address and Save Address

```javascript
// blocks/commerce-addresses/commerce-addresses.js

const validateAddress = async (address) => {
  // Call your service with the form data
  // const result = await fetch(...)
  // return result.suggestedAddress || null

  // Example mocked suggestion
  return {
    city: 'Bainbridge Island',
    countryCode: 'US',
    postcode: '98110-2450',
    region: { regionCode: 'WA', regionId: 1 },
    street: ['123 Winslow Way E'],
    telephone: '555-123-4567',
  };
};

const finalizeSubmission = (setContainerProps, formRef, updates = {}) => {
  setContainerProps({ onSubmit: null, ...updates });
  setTimeout(() => formRef.current?.requestSubmit(), 1);
};

const renderAddressValidation = async ({
  originalAddress,
  suggestedAddress,
  onEdit,
  onSave,
}) => {
  const container = document.createElement('div');
  const addressValidation = document.createElement('div');
  const actionsContainer = document.createElement('div');
  const editAddressButton = document.createElement('div');
  const saveAddressButton = document.createElement('div');
  actionsContainer.appendChild(editAddressButton);
  actionsContainer.appendChild(saveAddressButton);
  container.appendChild(addressValidation);
  container.appendChild(actionsContainer);
  actionsContainer.classList.add('actions-container');

  await showModal(container);

  let selectedAddress, currentSelection;
  provider.render(AddressValidation, {
    selectedAddress: 'suggested',
    originalAddress,
    suggestedAddress,
    handleSelectedAddress: async ({ address, selection }) => {
      selectedAddress = address;
      currentSelection = selection;
    },
  })(addressValidation);

  UI.render(Button, {
    children: 'Edit Address',
    size: 'medium',
    variant: 'secondary',
    onClick: () => {
      if (currentSelection === 'suggested') {
        onEdit(selectedAddress);
      }
      removeModal();
    },
  })(editAddressButton);

  UI.render(Button, {
    children: 'Save Address',
    size: 'medium',
    variant: 'primary',
    onClick: () => {
      const updates = {};
      if (currentSelection === 'suggested') {
        updates.inputsDefaultValueSet = selectedAddress;
      }
      removeModal();
      onSave(updates);
    },
  })(saveAddressButton);
};

export default async function decorate(block) {
  const { 'minified-view': minifiedViewConfig = 'false' } = readBlockConfig(block);

  if (!checkIsAuthenticated()) {
    window.location.href = rootLink(CUSTOMER_LOGIN_PATH);
    return;
  }

  let originalAddress;
  const formRef = { current: null };

  const addressesContainer = await accountRenderer.render(Addresses, {
    minifiedView: minifiedViewConfig === 'true',
    withActionsInMinifiedView: false,
    withActionsInFullSizeView: true,
    routeAddressesPage: () => rootLink(CUSTOMER_ADDRESS_PATH),
    forwardFormRef: formRef,
    onAddressData: (values) => {
      originalAddress = values?.data;
    },
    onSubmit: async (event, formValid) => {
      if (!formValid) return;

      const setContainerProps = (updates) => {
        addressesContainer.setProps((prev) => ({ ...prev, ...updates }));
      };

      const suggestedAddress = await validateAddress(originalAddress);
      if (!suggestedAddress) {
        finalizeSubmission(setContainerProps, formRef);
        return;
      }

      await renderAddressValidation({
        originalAddress,
        suggestedAddress,
        onEdit: (selectedAddress) => {
          setContainerProps({ inputsDefaultValueSet: selectedAddress });
        },
        onSave: (updates) => {
          finalizeSubmission(setContainerProps, formRef, updates);
        },
      });
    },
  })(block);
}
```

```javascript
// modal-utils.js

let modal;

export const showModal = async (content) => {
  modal = await createModal([content]);
  modal.showModal();
};

export const removeModal = () => {
  if (!modal) return;
  modal.removeModal();
  modal = null;
};
```

### Optional styles

```css
/* Minimal layout for the modal */
.modal-content {
  padding: 32px;
}

.actions-container {
  display: flex;
  gap: 16px;
  margin-top: 48px;
  justify-content: flex-end;
}
```

## Next steps

- See the [`AddressValidation` container](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/containers/address-validation/) container for props and behaviors.
- Ensure your suggestion matches the `CustomerAddressInput` shape expected by the Addresses container.

---

# User auth functions

## confirmEmail

The `confirmEmail` function uses the supplied `customerEmail` and `customerConfirmationKey` parameters to complete the customer activation process. Adobe Commerce sends the confirmation key to the customer when they request to create an account. The function calls the [`confirmEmail` mutation](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/confirm-email/).

```ts
confirmEmail({
  customerEmail: string,
  customerConfirmationKey: string,
});
```



### Returns

Returns a promise that resolves to a `confirmEmailProps` object.

### Usage

```ts

confirmEmail({
  customerEmail: 'abc@example.com',
  customerConfirmationKey: '1234567890',
});
```

## createCustomer

The `createCustomer` function creates a customer account based on the data supplied in the `forms` parameter. By default, the function uses the [`createCustomer` mutation](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/create-customer/). If the `apiVersion2` parameter is set to `true`, the function uses the [`createCustomerV2` mutation](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/create-v2/).

```ts
createCustomer(forms: Customer; apiVersion2: boolean);
```



`Customer` contains the following properties:

```ts
export interface Customer {
  firstname: string;
  lastname: string;
  email: string;
  is_subscribed: boolean;

  custom_attributes?: Record<string, string>[];
}
```

### Returns

Returns a promise that resolves to a `CreateCustomerDataResponse` object.

### Usage

```ts


createCustomer( forms:{
  allow_remote_shopping_assistance: true,
  date_of_birth: "1990-01-01",
  email: "john.doe@example.com",
  firstname: "John",
  is_subscribed: true,
  lastname: "Doe",
  middlename: "",
  password: "Password123",
  prefix: "",
  suffix: "",
  taxvat: "",
}, apiVersion2: true);
```

## createCustomerAddress

The `createCustomerAddress` function defines a new customer address. The customer can subseqently designate the address for billing or shipping orders. The function calls the [`createCustomerAddress` mutation](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/create-customer-address/).

```ts
createCustomerAddress (address: AddressFormProps);
```



`AddressFormProps` contains the following properties:

```ts
export interface AddressFormProps {
  region: Region;
  city: string;
  company: string;
  country_code: string;
  country_id: string;
  custom_attributes: CustomAttributes[];
  custom_attributesV2: CustomAttributesV2[];
  default_billing?: boolean;
  default_shipping?: boolean;
  fax: string;
  firstname: string;
  lastname: string;
  middlename: string;
  postcode: string;
  prefix: string;
  street: string[];
  suffix: string;
  telephone: string;
  vat_id: string;
}
```

### Returns

Returns a promise that resolves to a `CreateCustomerAddressResponse` object.

### Usage

```ts

createCustomerAddress(address: {
  "city": "Phoenix",
  "country_code": "US",
  "default_billing": true,
  "default_shipping": false,
  "firstname": "Bob",
  "lastname": "Loblaw",
  "postcode": "77777",
  "region": {
    "region": "Arizona",
    "region_code": "AZ",
  },
  "street": ["123 Main St"],
  "telephone": "555 555-5555",
});
```

## getAttributesForm

The `getAttributesForm` function uses the `attributesForm` query to retrieve EAV attributes associated with customer and customer address frontend forms. The function calls the [`attributesForm` query](https://developer.adobe.com/commerce/webapi/graphql/schema/attributes/queries/attributes-form/).

```ts
getAttributesForm(formCode: string);
```



### Returns

Returns a promise that resolves to an `AttributesFormModel` object.

### Usage

```ts

getAttributesForm(formCode: "customer_account_create");
```

## getCustomerData

The `getCustomerData` function retrieves data about the customer represented by the value of the `auth_dropin_user_token` parameter. The function calls the [`customer` query](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/queries/customer/).

```ts
getCustomerData(auth_dropin_user_token: string);
```



### Returns

Returns a promise that resolves to a `CustomerDataModel` object.

### Usage

```ts

getCustomerData(auth_dropin_user_token: "abcdefghi12345");
```

## getCustomerToken

The `getCustomerToken` function handles the sign-in operation. It requires `userName` and `password` parameters and performs the following actions under the hood:

1. Retrieves the customer token.

1. Fetches customer data using the token.

1. Sets the `auth_dropin_firstname` and `auth_dropin_user_token` cookies.

1. Publishes an [Adobe Client Data Layer (ACDL)](https://github.com/adobe/adobe-client-data-layer) event.

1. Emits an â€œauthenticatedâ€ event.

You can use the `getCustomerToken` function to build a custom authentication flow that remains fully integrated with other drop-in components.

The function calls the [`generateCustomerToken` mutation](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/generate-token/).

```ts
getCustomerToken(
  {
    email: string,
    password: string,
    handleSetInLineAlertProps: (value?: inLineAlertInterface) => void;
    translations: Record<string, string>;
    onErrorCallback?: (value?: unknown) => void;
  },
);
```

<OptionsTable
  compact
  options={[
    ['Parameter', 'Type', 'Req?', 'Description'],
    ['email', 'string', 'Yes', 'The customer email address.'],
    ['password', 'string', 'Yes', 'The customer password.'],
    [
      'handleSetInLineAlertProps',
      '(value?: inLineAlertInterface) => void',
      'No',
      'A function that sets the inline alert.',
    ],
    ['translations', 'Record<string, string>', 'No', 'A record of translations.'],
    [
      'onErrorCallback',
      '(value?: unknown) => void',
      'No',
      'A callback function that is called when an error occurs.',
    ],
  ]}
/>

### Returns

`getCustomerTokenProps`

### Usage

```ts

getCustomerToken(email: "abc@example.com", password: "MyBadPassword");
```

## getStoreConfig

The `getStoreConfig` function uses the [`storeConfig` query](https://developer.adobe.com/commerce/webapi/graphql/schema/store/queries/store-config/) to retrieve store configuration data.

```ts
getStoreConfig();
```

### Returns

Returns a promise that resolves to a `StoreConfigModel` object.

### Usage

```ts

getStoreConfig();
```

## requestPasswordResetEmail

The `requestPasswordResetEmail` function initiates the process of resetting a customer's password. The function calls the [`requestPasswordResetEmail` mutation](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/request-password-reset-email/).

```ts
requestPasswordResetEmail(email: string);
```



### Returns

Returns a promise that resolves to a `PasswordResetEmailModel` object.

### Usage

```ts

requestPasswordResetEmail(email: "abc@example.com");
```

## resendConfirmationEmail

The `resendConfirmationEmail` function resends the email confirmation to the customer using the supplied `customerEmail` parameter. The function calls the `resendConfirmationEmail` mutation, which is included in the Storefront Compatability Package.

```ts
resendConfirmationEmail(customerEmail:string);
```



### Returns

Returns a promise that resolves to a `resendConfirmationEmailResponse` object.

### Usage

```ts

resendConfirmationEmail(customerEmail:"abc@example.com");
```

## resetPassword

The `resetPassword` function resets a customer's password using the supplied `email`, `resetPasswordToken`, and `newPassword` parameters. The function calls the [`resetPassword` mutation](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/reset-password/).

```ts
resetPassword (email: string, resetPasswordToken: string, newPassword: string);
```



### Returns

Returns a promise that resolves to a `ResetPasswordModel` object.

### Usage

```ts

resetPassword(
    email: "abc@example.com",
    resetPasswordToken: "gh80pkjGdsPyiXc0sUUXswX1uGN7crUr",
    newPassword: "ThisNewPasswordIsSomewhatBetter");
```

## revokeCustomerToken

The `revokeCustomerToken` function revokes the customer's token and clears cookie. It then publishes an ACDL event and emits an "authenticated" event.

This API can also be used to build a custom sign-out flow that stays fully integrated with other drop-in components.

The function calls the [`revokeCustomerToken` mutation](https://developer.adobe.com/commerce/webapi/graphql/schema/customer/mutations/revoke-token/).

```ts
revokeCustomerToken();
```

### Returns

Returns a promise that resolves to a `RevokeCustomerTokenModel` object.

### Usage

```ts

revokeCustomerToken();
```

---

# AuthCombine container

The AuthCombine container renders a dialog that combines the sign-in, sign-up, and reset password forms. The user can switch between the forms using the provided links.


  ![AuthCombine container](@images/user-auth/auth-combine.png/)


## AuthCombine configurations

The AuthCombine container provides the following configuration options:



## Example

The following example renders the AuthCombine container with the provided form configurations.

```javascript
{
  authRenderer.render(AuthCombine, {
    signInFormConfig,
    signUpFormConfig,
    resetPasswordFormConfig,
  })(signInForm);
};
```

---

# User Auth containers

User Auth containers handle authentication, registration, and password management. The following containers provide the building blocks for complete authentication experiences.



| Container | Description |
|-----------|-------------|
| [AuthCombine](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/auth-combine/) | Unified sign-in and sign-up interface. |
| [ResetPassword](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/reset-password/) | Request password reset via email. |
| [SignIn](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/sign-in/) | Login with email and password. |
| [SignUp](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/sign-up/) | New customer registration and account creation. |
| [SuccessNotification](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/success-notification/) | Confirmation for successful authentication. |
| [UpdatePassword](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/update-password/) | Change account password securely. |

---

# ResetPassword container

The ResetPassword container renders a dialog that initiates the process of resetting the user's password. The user must provide their email address to receive a password reset link.


  ![ResetPassword container](@images/user-auth/reset-password.png/)


Upon success, Commerce sends the user an email with a link in the following format: 

```text
https://www.example.com/customer/account/createPassword/?email=<user_email>&id=<user_id>&token=<token>
```

The user will also see an appropriate notification on the storefront. Clicking the link leads the user to the [UpdatePassword container](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/update-password/).


  ![ResetPassword response](@images/user-auth/reset-password-response.png/)


## ResetPassword configurations

The ResetPassword container provides the following configuration options:




## Example

The following example checks whether the user is authenticated. If the user is authenticated, the user is redirected to the customer account page. If the user is not authenticated, the user is redirected to the ResetPassword container. 

```javascript
export default async function decorate(block) {
  if (checkIsAuthenticated()) {
    window.location.href = CUSTOMER_ACCOUNT_PATH;
  } else {
    await authRenderer.render(ResetPassword, {
      routeSignIn: () => CUSTOMER_LOGIN_PATH,
    })(block);
  }

  events.on('authenticated', (authenticated) => {
    if (authenticated) window.location.href = CUSTOMER_ACCOUNT_PATH;
  });
}
```

---

# SignIn container

The SignIn container helps render different screens that enable the customer to log in to an account. The container supports multiple scenarios, including standard logins for existing accounts and for accounts that are process of being confirmed.

If customers are required to confirm an email address to create an account, the **Stores** > Configuration > **Customers** > **Customer Configuration** > **Create New Account Options** > **Require Emails Confirmation** setting in the Commerce Admin must be set to **Yes**.

## Simple login

The standard login screen can be displayed when an account has already been created or confirmed, or when email configuration is disabled.

Upon a successful login, the SignIn container renders the [SuccessNotification](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/success-notification/) container. This container can be overridden using the Slots API.

Alternatively, if you pass the routeRedirectOnSignIn property, the user will be redirected to the specified URL after successful login. (Neither SuccessNotification nor Slot content will be rendered.)


  ![SignIn standard login container](@images/user-auth/sign-in-container.png/)


## Log in to an unconfirmed account

This scenario is applicable when email confirmation has been enabled, and the user has created an account, but has not confirmed their email.

If the user attempts to log in with credentials for an unconfirmed account, they will see a custom notification allowing them to resend the confirmation email. When the user clicks on the **Resend confirmation email** link shown below, Commerce sends a new confirmation email to the user.


  ![SignIn standard login container](@images/user-auth/sign-in-not-confirmed.png/)


## Confirmation from email

The SignIn container processes email confirmations when users click on the confirmation link sent to their email. The link format is:

`https://www.example.com/customer/account/confirm/?back_url=&email=<user_email>&id=<user_id>&key=<confirmation_key>`

The following steps describe the flow:

- Email confirmation is enabled in the Commerce Admin.
- The user has created an account and received the email confirmation link.
- The user clicks on the link and gets redirected to the email confirmation page with the SignIn drop-in.

> **Note:** To enable the email confirmation functionality, you must pass the `enableEmailConfirmation`
  property with a true value during integration.


  ![SignIn standard login container](@images/user-auth/sign-in-email-confirm.png/)


## SignIn configurations

The SignIn container provides the following configuration options:

<OptionsTable
  compact
  options={[
    ['Option', 'Type', 'Req?', 'Description'],
    [
      'slots',
      'SuccessNotification',
      'No',
      'Allows passing the SuccessNotification container or custom component rendered on successful sign-in if routeRedirectOnSignIn is not provided.',
    ],
    ['labels', 'Record<string, string>', 'No', 'Text that describes the container'],
    [
      'formSize',
      'default | small',
      'No',
      'Controls form paddings and spacing. Use "small" to embed the form in small layout containers like a dropdown in the header.',
    ],
    [
      'renderSignUpLink',
      'boolean',
      'No',
      'Controls the visibility of the â€œSign upâ€ link next to the â€œForgot Passwordâ€ link.',
    ],
    [
      'initialEmailValue',
      'string',
      'No',
      'Allows passing an initial value for the email input (prefilled sign-in form).',
    ],
    [
      'enableEmailConfirmation',
      'boolean',
      'No',
      'Determines if this container is used to handle email confirmation.',
    ],
    [
      'hideCloseBtnOnEmailConfirmation',
      'boolean',
      'No',
      'Controls the visibility of the â€œCloseâ€ button on the email confirmation view.',
    ],
    [
      'routeRedirectOnEmailConfirmationClose',
      'function',
      'No',
      'Determines where the user is redirected when the â€œCloseâ€ button on the email confirmation view is clicked.',
    ],
    [
      'routeForgotPassword',
      'function',
      'No',
      'Determines where the â€œForgot password?â€ link redirects the customer.',
    ],
    [
      'routeSignUp',
      'function',
      'No',
      'Determines where the â€œSign upâ€ link redirects the customer (link visibility is based on the renderSignUpLink property).',
    ],
    [
      'routeRedirectOnSignIn',
      'function',
      'No',
      'Determines the page to which the user should be redirected after sign-in. If provided, the user wonâ€™t be redirected to the  SuccessNotification container or any slot-defined override.',
    ],
    [
      'onSuccessCallback',
      'function',
      'No',
      'Callback executed when the user successfully logs in, receiving userName and status as parameters.',
    ],
    [
      'onErrorCallback',
      'function',
      'No',
      'Callback executed when an error occurs, receiving the error object as a parameter.',
    ],
    [
      'onSignUpLinkClick',
      'function',
      'No',
      'Executed on clicking the â€œSign upâ€ link before redirect (link visibility is based on the renderSignUpLink property).',
    ],
  ]}
/>

## Example

The following example renders the SignIn container.

```javascript
export default async function decorate(block) {
  if (checkIsAuthenticated()) {
    window.location.href = CUSTOMER_ACCOUNT_PATH;
  } else {
    await authRenderer.render(SignIn, {
      enableEmailConfirmation: true,
      routeForgotPassword: () => CUSTOMER_FORGOTPASSWORD_PATH,
      slots: {
        SuccessNotification: (ctx) => {
          const userName = ctx?.isSuccessful?.userName || '';

          const elem = document.createElement('div');

          authRenderer.render(SuccessNotification, {
            labels: {
              headingText: `Welcome ${userName}!`,
              messageText: 'You have successfully logged in.',
            },
            slots: {
              SuccessNotificationActions: (innerCtx) => {
                const primaryBtn = document.createElement('div');

                authRenderer.render(Button, {
                  children: 'My Account',

                  onClick: () => {
                    window.location.href = CUSTOMER_ACCOUNT_PATH;
                  },
                })(primaryBtn);

                innerCtx.appendChild(primaryBtn);

                const secondaryButton = document.createElement('div');
                secondaryButton.style.display = 'flex';
                secondaryButton.style.justifyContent = 'center';
                secondaryButton.style.marginTop = 'var(--spacing-xsmall)';

                authRenderer.render(Button, {
                  children: 'Logout',
                  variant: 'tertiary',
                  onClick: async () => {
                    await authApi.revokeCustomerToken();
                    window.location.href = '/';
                  },
                })(secondaryButton);

                innerCtx.appendChild(secondaryButton);
              },
            },
          })(elem);

          ctx.appendChild(elem);
        },
      },
    })(block);
  }
}
```

---

# SignUp container

The SignUp container provides a form where the user enters the details required to create a new account. The execution of this form can vary, depending on how Commerce is configured:

- If email confirmations have been enabled, the user account is not activated until the user clicks on the confirmation link that Commerce sends to the user's email address.

- If the customer account contains custom attributes, these must be configured to be available to the form. See [Customer attribute properties](https://experienceleague.adobe.com/en/docs/commerce-admin/customers/customer-accounts/attributes/attribute-properties) for more information.

## Simple container

A SignUp container can collect minimal information, such as name, email, and password, to create a new account. Alternatively, it can collect additional information, such as addresses, if the `addressesData` property is passed.

By default, upon a successful registration, the SignUp container renders the [SuccessNotification](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/success-notification/) container.

The user is logged on when the `isAutoSignInEnabled` property is passed.

If the `routeRedirectOnSignIn` property is passed, the user is redirected to the specified URL after a successful login. Neither the SuccessNotification container nor slots will be rendered.

In this scenario, email confirmation must be disabled.


  ![SignUp container](@images/user-auth/sign-up-container.png/)


## Registration with email confirmation enabled

If a user creates an account when email confirmation is enabled, a different form is rendered in place of the sign-up form to inform the user about the next steps. Automatic sign-in is not possible if email confirmation is enabled.


  ![SignUp container](@images/user-auth/sign-up-verify-email.png/)


## SignUp configurations

The SignUp container provides the following configuration options:



### Example

The following example redirects the user to the account page if they are already authenticated. If not, the user is redirected first to the login page, then to the account page.

```javascript
export default async function decorate(block) {
  const isAuthenticated = !!getCookie('auth_dropin_user_token');

  if (isAuthenticated) {
    window.location.href = '/customer/account';
  } else {
    await authRenderer.render(SignUp, {
      hideCloseBtnOnEmailConfirmation: true,
      routeSignIn: () => '/customer/login',
      routeRedirectOnSignIn: () => '/customer/account',
    })(block);
  }
}
```

---

# SuccessNotification container

The SuccessNotification container displays a message to the user after a successful action, such as signing up or updating a password. The SignIn, SignUp, and UpdatePassword containers can pass the SuccessNotification container as a slot.

In the following diagram, a SignIn container has passed the SuccessNotification container, which defines the displayed text and action buttons.


  ![SuccessNotification container](@images/user-auth/success-notification.png/)


## SuccessNotification configurations

The SuccessNotification container provides the following configuration options:



## Example

The following example renders the SignIn container. On success, the container displays a welcome heading, a message, and two action buttons: "My Account" and "Logout".

```javascript
export default async function decorate(block) {
  if (checkIsAuthenticated()) {
    window.location.href = CUSTOMER_ACCOUNT_PATH;
  } else {
    await authRenderer.render(SignIn, {
      enableEmailConfirmation: true,
      routeForgotPassword: () => CUSTOMER_FORGOTPASSWORD_PATH,
      slots: {
        SuccessNotification: (ctx) => {
          const userName = ctx?.isSuccessful?.userName || '';

          const elem = document.createElement('div');

          authRenderer.render(SuccessNotification, {
            labels: {
              headingText: `Welcome ${userName}!`,
              messageText: 'You have successfully logged in.',
            },
            slots: {
              SuccessNotificationActions: (innerCtx) => {
                const primaryBtn = document.createElement('div');

                authRenderer.render(Button, {
                  children: 'My Account',

                  onClick: () => {
                    window.location.href = CUSTOMER_ACCOUNT_PATH;
                  },
                })(primaryBtn);

                innerCtx.appendChild(primaryBtn);

                const secondaryButton = document.createElement('div');
                secondaryButton.style.display = 'flex';
                secondaryButton.style.justifyContent = 'center';
                secondaryButton.style.marginTop = 'var(--spacing-xsmall)';

                authRenderer.render(Button, {
                  children: 'Logout',
                  variant: 'tertiary',
                  onClick: async () => {
                    await authApi.revokeCustomerToken();
                    window.location.href = '/';
                  },
                })(secondaryButton);

                innerCtx.appendChild(secondaryButton);
              },
            },
          })(elem);

          ctx.appendChild(elem);
        },
      },
    })(block);
  }
}
```

---

# UpdatePassword container

The UpdatePassword container continues the process of resetting the user's password that began in the [ResetPassword container](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/reset-password/). The user clicks a link in an email to navigate to the UpdatePassword container, where they can enter a new password.

Upon a successful password update, the UpdatePassword container renders the [SuccessNotification](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/success-notification/) container. 

The UpdatePassword container can be overridden using the Slots API.

If the `signInOnSuccess` property is passed, the user will be automatically logged in and redirected to the value specified in `routeRedirectOnSignIn`. This property overrides SuccessNotification or custom slot content.

If the `routeRedirectOnPasswordUpdate` property is passed, the user will be redirected to the specified URL after a successful password update. This property overrides the SuccessNotification container or custom slot content.


  ![UpdatePassword container](@images/user-auth/reset-password.png/)


## UpdatePassword configurations

The UpdatePassword container provides the following configuration options:



### Example

The following example uses the UpdatePassword container to change the user's password. If successful, the SuccessNotification container is rendered.

```javascript
export default async function decorate(block) {
  if (checkIsAuthenticated()) {
    window.location.href = CUSTOMER_ACCOUNT_PATH;
  } else {
    await authRenderer.render(UpdatePassword, {
      routeWrongUrlRedirect: () => CUSTOMER_LOGIN_PATH,
      routeSignInPage: () => CUSTOMER_LOGIN_PATH,
      slots: {
        SuccessNotification: (ctx) => {
          const userName = ctx?.isSuccessful?.userName || '';

          const elem = document.createElement('div');

          authRenderer.render(SuccessNotification, {
            labels: {
              headingText: `Welcome ${userName}!`,
              messageText: 'Your password has been successfully updated.',
            },
            slots: {
              SuccessNotificationActions: (innerCtx) => {
                const primaryBtn = document.createElement('div');

                authRenderer.render(Button, {
                  children: 'My Account',

                  onClick: () => {
                    window.location.href = CUSTOMER_ACCOUNT_PATH;
                  },
                })(primaryBtn);

                innerCtx.appendChild(primaryBtn);

                const secondaryButton = document.createElement('div');
                secondaryButton.style.display = 'flex';
                secondaryButton.style.justifyContent = 'center';
                secondaryButton.style.marginTop = 'var(--spacing-xsmall)';

                authRenderer.render(Button, {
                  children: 'Logout',
                  variant: 'tertiary',
                  onClick: async () => {
                    await authApi.revokeCustomerToken();
                    window.location.href = '/';
                  },
                })(secondaryButton);

                innerCtx.appendChild(secondaryButton);
              },
            },
          })(elem);

          ctx.appendChild(elem);
        },
      },
    })(block);
  }
}
```

---

# User authentication dictionary

The default user authentication dictionary file (`i18n/en_US.json`) contains the default values for all labels and text common to the user authentication drop-in component.

## Default keys and values

---

# User Auth Data & Events

{/*
  âš ï¸ TEMPLATE USAGE GUIDE âš ï¸
  
  This template is used by scripts/generate-events-docs.js to generate event documentation.
  
  WHAT THE SCRIPT USES FROM THIS TEMPLATE:
  - Section headings and descriptive text (used as-is)
  - Import statements
  - The REPEAT_FOR_EACH_EVENT block (replicated for each event)
  - Placeholders: User Auth, User Auth, EVENT_NAME, etc.
  
  WHAT THE SCRIPT GENERATES INDEPENDENTLY:
  - Table contents between START/END markers (example rows are for reference only)
  - Event-specific data (names, descriptions, payloads from source repos)
  
  TO CHANGE:
  - Section text/descriptions â†’ Edit this template
  - Table structure (columns, links, formatting) â†’ Edit scripts/generate-events-docs.js
  - Both template and script must be kept in sync for table structure changes
*/}


The **User Auth** drop-in uses the [event bus](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/) to emit and listen to events for communication between drop-ins and external integrations. For common events shared across multiple drop-ins (such as `locale`, `error`, `authenticated`, etc.), see the [Common events reference](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/#common-events-reference).


<strong>Version: 2.1.1</strong>


> **Note:** **New to drop-in events?** Learn about the [event system architecture](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/), including the publish-subscribe pattern, subscription configuration, and best practices for event handling.

## Events reference

{/* EVENTS_TABLE_START */}


| Event | Direction | Description |
|-------|-----------|-------------|
| [auth/error](#autherror-emits) | Emits | Emitted when an error occurs |


{/* EVENTS_TABLE_END */}

## Event details

The following sections provide detailed information about each event, including its direction, data payload structure, and usage examples.


### `auth/error` (emits)

Emitted when an error occurs

#### Data payload

```typescript
{ source: string; type: string; error: Error | string }
```

| Property | Type | Description |
|----------|------|-------------|
| `source` | `string` | See type definition in source code |
| `type` | `string` | See type definition in source code |
| `error` | `Error \| string` | See type definition in source code |


#### Usage

Listen to this event in your storefront:

```javascript

const authErrorListener = events.on('auth/error', (data) => {
  console.log('auth/error event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
authErrorListener.off();
```

---

# User auth overview

The user auth drop-in component will provide user authentication to allow customers to sign up, log in, and log out of your storefront.

## Supported Commerce features

The following table provides an overview of the Adobe Commerce features that the user auth drop-in component supports:

| Feature                                | Status                                       |
| -------------------------------------- | -------------------------------------------- |
| Account confirmation email             |  |
| Custom customer attributes for sign up |  |
| ReCAPTCHA protection for web forms     |  |
| Retrieve password                      |  |
| Sign in                                |  |
| Sign up                                |  |

---

# reCAPTCHA integration

The reCAPTCHA module enables reCAPTCHA protection, which is natively supported by Adobe Commerce. It also provides an API allowing merchants to integrate reCAPTCHA protection into custom implementations. The current version of the module supports only reCAPTCHA v3 Invisible.

[Google reCAPTCHA](https://experienceleague.adobe.com/en/docs/commerce-admin/systems/security/captcha/security-google-recaptcha) in the _Admin Systems Guide_ describes how to configure Adobe Commerce.

:::note[Using the Commerce Boilerplate?]
The reCAPTCHA module is implemented in the [Commerce Boilerplate](https://experienceleague.adobe.com/developer/commerce/storefront/get-started/boilerplate-project/) within the `/scripts/initializers/index.js` file.
:::



## Integrations

To integrate ReCaptcha, follow these steps:

<Steps>

1. Load the app.

   - Call the `setConfig` method to fetch and set reCAPTCHA configuration.
   - (Optional) Extend the configuration with custom forms if a custom integration not natively supported by Adobe Commerce is planned.

1. Load the page with a protected form.

   Call the `initReCaptcha` method to add the script and initialize the ReCaptcha badge.

1. Render the form.

   - The user interacts with the page and form, providing the required data.
   - The user clicks the submit button.

1. Call the `verifyReCaptcha` API.

   Retrieve the reCAPTCHA token via the Google API.

</Steps>



### Flow for forms covered by Adobe Commerce natively

Use the following workflow for standard Adobe Commerce integrations



1.  Set the reCAPTCHA token in the X-ReCaptcha header.

1.  Send the request to the backend.

1.  Commerce validates the token. If it fails, Commerce returns an error.



### Flow for custom integrations

Use one of the following workflows for custom integrations:

- (Recommended) Send the token to Commerce and validate it on the server side. If validation passes, Commerce returns a normal response. Otherwise, it returns an error.

- Validate the token on the client side. If validation passes, send the request.

## reCAPTCHA API

The reCAPTCHA package exposes the following APIs, allowing developers to integrate it with native Adobe Commerce functionality or set up custom integrations:

- `setConfig`
- `setEndpoint`
- `initreCAPTCHA`
- `verifyreCAPTCHA`
- `enableLogger`

### setConfig

The `setConfig` method fetches and stores the reCAPTCHA configuration from the backend.
It is essential to call this method before the `initreCAPTCHA` and `verifyreCAPTCHA` methods during app initialization, because other reCAPTCHA functionality will not be fully operational until the configurations are loaded and set up.

#### Usage

The `setConfig` method is intended to be called without parameters, in which case the backend configuration will be used.

```javascript

reCAPTCHA.setConfig();
```

However, you can pass a configuration object as a parameter to override the backend configurations.

```javascript

reCAPTCHA.setConfig({ is_enabled: true });
```

### setEndpoint

The `setEndpoint` method sets the endpoint that the reCAPTCHA module uses to fetch configurations. Its use is optional. If reCAPTCHA uses the same API Mesh endpoint as the rest of the application, you do not need to set it explicitly. It will be inherited from the `fetch-graphql` package.

#### Usage

The following example sets the endpoint:

```javascript

reCAPTCHA.setEndpoint('https://www.example.com/graphql');
```

### initreCAPTCHA

The `initreCAPTCHA` method initializes reCAPTCHA scripts and badges. Call this method after the `setConfig` method and before rendering forms with reCAPTCHA protection.

The `initreCAPTCHA` method should be called before each form rendering. Do not call it at the top level of the application, immediately after the `setConfig` API, because this would load reCAPTCHA scripts on all pages, not just those with forms protected by reCAPTCHA.

Additionally, you must call `initreCAPTCHA` for each form render to ensure the script is in place and the reCAPTCHA badge is properly initialized.

#### Usage

The following example initializes reCAPTCHA:

```javascript

reCAPTCHA.initreCAPTCHA();
```

### verifyreCAPTCHA

The `verifyreCAPTCHA` method retrieves the reCAPTCHA token via the Google API. It should be called after `setConfig` and `initreCAPTCHA`, and before submitting a protected form to retrieve the reCAPTCHA token.

When the reCAPTCHA token is retrieved, for forms covered by native Adobe Commerce functionality, it is required to pass this token as an X-reCAPTCHA header.

For custom implementations, token validation should be implemented on either the server side or client side, and the token should be used according to the custom implementation.

#### Usage

The following example retrieves the reCAPTCHA token:

```javascript

export const setReCaptchaToken = async () => {
  const token = await reCAPTCHA.verifyreCAPTCHA();

  if (token) {
    setFetchGraphQlHeader('X-reCAPTCHA', token);
  }
};
```

### enableLogger

The `enableLogger` method enables extensive logging to the console for each step and error during reCAPTCHA operations. It is intended for development and debugging purposes.

#### Usage

The following example enables the logger:

```javascript

reCAPTCHA.enableLogger(true);
```

---

# User auth slots

The UserAuth drop-in component provides several slots that can be used to customize the presentation of its containers.

[Extending drop-in components](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/extending/) describes default properties available to all slots.

## PrivacyPolicyConsent slot

The `PrivacyPolicyConsent` slot can be used to display the privacy policy consent message in the [`SignUp` container](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/sign-up/). The following example shows how to use this slot to display a custom privacy policy message and link, as shown in the image below.


  ![SignUp container with PrivacyPolicyConsent](@images/user-auth/privacy-policy.png/)


```js
provider.render(SignUp, {
 routeSignIn: () => getRoute('#SignIn'),
 routeRedirectOnSignIn: () => getRoute('#AuthCombine'),
 slots: {
   PrivacyPolicyConsent: async (ctx) => {
     const wrapper = document.createElement('span');
     const link = document.createElement('a');

     Object.assign(wrapper.style, {
       color: 'var(--color-neutral-700)',
       font: 'var(--type-button-2-font)',
       letterSpacing: 'var(--type-button-2-letter-spacing)',
       textAlign: 'left',
       display: 'block',
       fontSize: '12px',
       marginBottom: 'var(--spacing-medium)',
     });

     link.href = '/privacy-policy';
     link.target = '_blank';
     link.textContent = 'Privacy Policy';

     wrapper.append(
       'By creating an account, you acknowledge that you have read and agree to our ',
       link,
       ', which outlines how we collect, use, and protect your personal data.'
     );

     ctx.appendChild(wrapper);
   },
 },
})(document.getElementById('SignUp'));
```

## SuccessNotification

The `SignIn`, `SignUp`, and `UpdatePassword` containers can use the `SuccessNotification` slot display a success message after a user successfully performs an action. See the [SuccessNotification container](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/success-notification/) for more information.

---

# Wishlist containers

Wishlist containers save and manage favorite products. The following containers provide the building blocks for complete wishlist experiences.



| Container | Description |
|-----------|-------------|
| [Wishlist](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/wishlist/containers/wishlist/) | Complete wishlist with saved products and management. |
| [WishlistAlert](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/wishlist/containers/wishlist-alert/) | Notifications when products are added or removed. |
| [WishlistItem](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/wishlist/containers/wishlist-item/) | Individual product entries with details and actions. |
| [WishlistToggle](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/wishlist/containers/wishlist-toggle/) | Add or remove products from wishlist. |

---

# Wishlist container

This container manages and displays the list of products on a user's wishlist.
A container's behavior is controlled by configuration options like `moveProdToCart`, `getProductData`, and `refineProduct`, and routing via `routeEmptyWishlistCTA`, `routeProdDetailPage`, and `routeToWishlist`.


  ![Wishlist container](@images/dropins/wish-list/wishlist.png/)


## Configurations

The `Wishlist` container provides the following configuration options:



## Example

The following example demonstrates how to render the `Wishlist` container:

```javascript
provider.render(Wishlist, {
    moveProdToCart: cartApi.addProductsToCart,
    routeProdDetailPage: (product) => rootLink(`/products/${product.urlKey}/${product.sku}`),
    getProductData: pdpApi.getProductData,
    getRefinedProduct: pdpApi.getRefinedProduct,
  });
```

---

# WishlistAlert container

The `WishlistAlert` container displays notifications that give feedback about actions performed in a wishlist drop-in component.


  ![Wishlist container](@images/dropins/wish-list/wishlist-alert.png/)


## Configurations

The `WishlistAlert` container provides the following configuration options:



## Example

The following example demonstrates how to render the `WishlistAlert` container:

```javascript
provider.render(Wishlist, {
    action: 'add', // or 'remove', 'move', 'addError', 'removeError'
    item: { product: { name: 'Sample Product' } },
    routeToWishlist: '/wishlist',
  });
```

---

# WishlistItem container

The `WishlistItem` container manages and displays a single product from a wishlist. It allows users to interact with the product, such as moving it to the cart or navigating to the product details page.

For complex products that have no variant selected in the wishlist, the **Move To Cart** button becomes a **Customize** button. Users must select a variant first by navigating to the product details page.
Its behavior is driven by configuration options such as `moveProdToCart`, `getProductData`, `getRefinedProduct` and routing via `routeProdDetailPage` callbacks.


  ![Wishlist container](@images/dropins/wish-list/wishlist-item.png/)


## Configurations

The `WishlistItem` container provides the following configuration options:



## Example

The following example demonstrates how to render the `WishlistItem` container:

```javascript
provider.render(WishlistItem, {
    item: sampleWishlistItem,
    moveProdToCart: cartApi.addProductsToCart,
    routeProdDetailPage: (product) => rootLink(`/products/${product.urlKey}/${product.sku}`),
    getProductData: pdpApi.getProductData,
    getRefinedProduct: pdpApi.getRefinedProduct
  });
```

---

# WishlistToggle container

The `WishlistToggle` container provides a button for adding and removing specific products.
Configuration options drive its behavior and appearance, such as size and variant.


  ![Wishlist container](@images/dropins/wish-list/wishlist.png/)


## Configurations

The `WishlistToggle` container provides the following configuration options:



## Example

The following example demonstrates how to render the `Wishlist` container:

```javascript
provider.render(WishlistToggle, {
    product: sampleProduct,
    iconWishlisted: ,
    iconToWishlist: ,
    size: 'medium',
    variant: 'primary',
    labelToWishlist: 'Add to Wishlist',
    labelWishlisted: 'Remove from Wishlist',
  });
```

---

# Wishlist dictionary

The default wishlist dictionary file (`i18n/en_US.json`) contains the default values for all labels and text common to the wishlist drop-in component.

## Default keys and values

---

# Wishlist Data & Events

{/*
  âš ï¸ TEMPLATE USAGE GUIDE âš ï¸
  
  This template is used by scripts/generate-events-docs.js to generate event documentation.
  
  WHAT THE SCRIPT USES FROM THIS TEMPLATE:
  - Section headings and descriptive text (used as-is)
  - Import statements
  - The REPEAT_FOR_EACH_EVENT block (replicated for each event)
  - Placeholders: Wishlist, Wishlist, EVENT_NAME, etc.
  
  WHAT THE SCRIPT GENERATES INDEPENDENTLY:
  - Table contents between START/END markers (example rows are for reference only)
  - Event-specific data (names, descriptions, payloads from source repos)
  
  TO CHANGE:
  - Section text/descriptions â†’ Edit this template
  - Table structure (columns, links, formatting) â†’ Edit scripts/generate-events-docs.js
  - Both template and script must be kept in sync for table structure changes
*/}


The **Wishlist** drop-in uses the [event bus](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/) to emit and listen to events for communication between drop-ins and external integrations. For common events shared across multiple drop-ins (such as `locale`, `error`, `authenticated`, etc.), see the [Common events reference](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/#common-events-reference).


<strong>Version: 2.0.1</strong>


> **Note:** **New to drop-in events?** Learn about the [event system architecture](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/), including the publish-subscribe pattern, subscription configuration, and best practices for event handling.

## Events reference

{/* EVENTS_TABLE_START */}


| Event | Direction | Description |
|-------|-----------|-------------|
| [wishlist/initialized](#wishlistinitialized-emits) | Emits | Emitted when the component completes initialization |
| [wishlist/alert](#wishlistalert-emits-and-listens) | Emits and listens | Triggered when an alert or notification is triggered |
| [wishlist/data](#wishlistdata-emits-and-listens) | Emits and listens | Triggered when data is available or changes |
| [wishlist/reset](#wishlistreset-emits-and-listens) | Emits and listens | Triggered when the component state is reset |


{/* EVENTS_TABLE_END */}

## Event details

The following sections provide detailed information about each event, including its direction, data payload structure, and usage examples.


### `wishlist/alert` (emits and listens)

Triggered when an alert or notification is triggered

#### Data payload

```typescript
WishlistActionPayload | null
```



#### Usage

Listen to this event in your storefront:

```javascript

const wishlistAlertListener = events.on('wishlist/alert', (data) => {
  console.log('wishlist/alert event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
wishlistAlertListener.off();
```

### `wishlist/data` (emits and listens)

Triggered when data is available or changes

#### Data payload

```typescript
Wishlist | null
```



#### Usage

Listen to this event in your storefront:

```javascript

const wishlistDataListener = events.on('wishlist/data', (data) => {
  console.log('wishlist/data event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
wishlistDataListener.off();
```

### `wishlist/initialized` (emits)

Emitted when the component completes initialization

#### Data payload

```typescript
Wishlist | null
```



#### Usage

Listen to this event in your storefront:

```javascript

const wishlistInitializedListener = events.on('wishlist/initialized', (data) => {
  console.log('wishlist/initialized event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
wishlistInitializedListener.off();
```

### `wishlist/reset` (emits and listens)

Triggered when the component state is reset

#### Data payload

```typescript
void
```



#### Usage

Listen to this event in your storefront:

```javascript

const wishlistResetListener = events.on('wishlist/reset', (data) => {
  console.log('wishlist/reset event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
wishlistResetListener.off();
```

---

# Wishlist functions

This topic provides the details and instructions you need to use the functions provided by the wishlist drop-in component.

## addProductsToWishlist

The `addProductsToWishlist` function allows you to add products to a user's wishlist.
This function is typically used when a user wants to save a product for later purchase.

### Example usage

```typescript

addProductsToWishlist([{ sku: 'sku_item_1', quantity: 1 }]);
```

## getStoreConfig

The `getStoreConfig` function retrieves the store configuration, which includes various settings and preferences for the store.

### Example function usage

```typescript

getStoreConfig();
```

## getWishlistById

The `getWishlistById` function retrieves a wishlist by its ID. This is useful for accessing a specific user's wishlist.

### Example function usage

```typescript

getWishlistById('1');
```

## getWishlists

The `getWishlists` function retrieves all wishlists associated with a user. This is useful for displaying all wishlists a user has created.

### Example function usage

```typescript

getWishlists();
```

## mergeWishlists

The `mergeWishlists` function allows you to merge a wishlist from local storage with one belonging to a registered user.
This is useful when a user wants to synchronize both local and remote wishlists into one wishlist after logging in.

### Example function usage

```typescript

mergeWishlists(wishlist);
```

## removeProductsFromWishlist

The `removeProductsFromWishlist` function allows you to remove products from a user's wishlist.

### Example usage

```typescript

removeProductsFromWishlist([{ product: { sku: 'sku_item_1' }}]);
```

## updateProductsInWishlist

The `updateProductsInWishlist` function allows you to update the quantity of products in a user's wishlist.

### Example usage

```typescript

updateProductsInWishlist([{ wishlistItemId: 'test-id', quantity: 1, description: 'Lorem ipsum' }]);
```

---

# Wishlist overview

The wishlist drop-in component provides both guests and registered customers with a mechanism to store products they are interested in purchasing later.

The wishlist component is fully customizable and can be integrated into your storefront to enhance the shopping experience.

## Use cases

The wishlist drop-in component offers a variety of fully-customizable controls to highlight your products (according to your brand's aesthetics) and create interactive experiences. Use cases include:

- **Buy it later**: Users can save products they find interesting to a dedicated location for quick access when they are ready to make a purchase.
- **Synchronization**: When a guest user creates an account or logs in, their wishlist items automatically sync across all devices where they are signed in.

## Supported Commerce features

The following table provides an overview of the Adobe Commerce features that the wishlist drop-in component supports:

| Feature          | Status                                       |
| ---------------- | -------------------------------------------- |
| Wishlist a product for customers |       |
| Move a product from wishlist to cart |       |
| Move a product from cart to wishlist |       |

---

# Wishlist installation

Our drop-in components are designed for the browser's JavaScript run-time without the need for a bundler. But they can also be installed and executed in a build-time environment with bundlers like Webpack and Vite. The installation steps for both run-time and build-time environments are the same after the initial drop-in component package imports.

## Step-by-step

The following steps show how to install the wishlist component into your site.



    <Task>

        ### Install the packages

        Use a CDN or NPM (recommended for performance) to install the drop-in component tools (`@dropins/tools`) and wishlist (`@dropins/storefront-wishlist`) packages.

        <Tabs>
            <TabItem label="NPM" icon="seti:npm">

                ```bash frame="none"
                npm install @dropins/tools @dropins/storefront-wishlist
                ```

            </TabItem>
            <TabItem label="CDN" icon="external">

                ```html title="index.html" del={"Replace with actual URLs":5-7}
                <head>
                    <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                            <title>Your Storefront</title>

                            <script src="https://cdn.jsdelivr.net/npm/@dropins/tools@latest"></script>
                            <script src="https://cdn.jsdelivr.net/npm/@dropins/storefront-wishlist@latest"></script>
                </head>
                ```

            </TabItem>
        </Tabs>

        :::note[Install @dropins/tools]
        All drop-in components require the `@dropins/tools` package. This package contains the libraries that drop-in components need to initialize and communicate, including `fetch-graphql`, `event-bus`, and `initializer` utilities.
        :::

    </Task>

    <Task>
        ### Map the packages

        In the `<head>` tag of your `index.html` or `head.html` file, use an `importmap` pointed to the `node_modules` directory, a **custom local directory**, or **CDN** (for run-time environments).

        <Tabs>
            <TabItem label="node_modules" icon="seti:npm">
                This example shows an `importmap` added to a `head.html` The `importmap` points both packages to the local `node_modules` directory that contains your installed drop-in component files from the drop-in component tools (@dropins/tools) and the Wishlist drop-in component (@dropins/storefront-wishlist):

                ```html title="head.html"
                <script type="importmap">
                    {
                        "imports": {
                        "@dropins/tools/": "/node_modules/@dropins/tools/",
                        "@dropins/storefront-wishlist/": "/node_modules/@dropins/storefront-wishlist/",
                    }
                    }
                </script>
                <script src="/scripts/scripts.js" type="module"></script>
                ```
            </TabItem>
            <TabItem label="custom" icon="seti:folder">
                This example shows an `importmap` added to a `head.html` The `importmap` points both packages to local directories that contain all the optimized/minified files from the drop-in component tools (@dropins/tools) and the wishlist component (@dropins/storefront-wishlist):

                ```html title="head.html"
                <script type="importmap">
                    {
                        "imports": {
                        "@dropins/tools/": "/scripts/__dropins__/tools/",
                        "@dropins/storefront-wishlist/": "/scripts/__dropins__/storefront-wishlist/",
                    }
                    }
                </script>
                <script src="/scripts/scripts.js" type="module"></script>
                ```

            </TabItem>
            <TabItem label="CDN" icon="external">
                This example shows an `importmap` pointing both packages to a CDN for the drop-in component tools (@dropins/tools) and the wishlist component (@dropins/storefront-wishlist):

                ```html title="index.html" {"Replace CDN URLs with correct URLs":5-7} del='https://cdn.jsdelivr.net/npm/'
                <head>
                    <script type="importmap">
                        {
                            "imports": {

                            "@dropins/tools/": "https://cdn.jsdelivr.net/npm/@dropins/tools@latest",
                            "@dropins/storefront-pdp/": "https://cdn.jsdelivr.net/npm/@dropins/storefront-wishlist@latest",
                        }
                        }
                    </script>
                </head>
                ```

            </TabItem>

        </Tabs>

        With the `importmap` defined for both run-time and build-time environments, you can now **import the required files** from these packages into your PDP drop-in component JavaScript file as described in the next step.

    </Task>

    <Task>
        ### Import the required files

        Import the required files from the drop-in components tools (`@dropin/tools/initializers.js`) and the wishlist component (`@dropins/storefront-wishlist`) into a JavaScript file for your wishlist drop-in. In this example, we'll call this file `wishlist.js`. See the [boilerplate code](https://github.com/hlxsites/aem-boilerplate-commerce/blob/main/blocks/commerce-wishlist/commerce-wishlist.js) for a list of the default imports.

    </Task>

    <Task>
        ### Connect to the endpoint

        Connect your product details component to the Catalog Service GraphQL endpoint and set the required headers as shown in the example below. Replace the endpoint URL and header placeholder values with the actual values from your Commerce backend services:

        ```js title="product-details.js"
        // Set endpoint configuration
        product.setEndpoint('https://<catalog-service-endpoint>/graphql');

        product.setFetchGraphQlHeaders({
            // Environment required headers
            'Magento-Environment-Id': 'your-environment-id',
            'Magento-Store-View-Code': 'your-store-view-code',
            'Magento-Website-Code': 'your-website-code',
            'x-api-key': 'your-api-key',
            'Magento-Store-Code': 'main_website_store',
            'Magento-Customer-Group': 'your-customer-group',
            'Content-Type': 'application/json',
        });
        ```

    </Task>

    <Task>
        ### Register and load the drop-in

        The code below shows how to register the wishlist component, load it (mount), and enable the logger for debugging purposes. You can add these functions within a `<script>` tag in your product details HTML page as shown here:

        ```html title="index.html" ins={"1":5} ins={"2":8}
        <script type="module">
            // more code above...

            // Register and load the product details component
            initializers.mountImmediately(pdp.initialize);

            // Mount Initializers (must be called after all initializers are registered)
            window.addEventListener('load', initializers.mount);
        </script>
        ```

        <Callouts square color="var(--sl-color-green)">

            1. This function registers the product details component to be loaded on the page by the `initializers.mount` function.
            1. This event handler triggers the initializers.mount function to load the product details component after the page has loaded.

        </Callouts>

    </Task>

    <Task>
        ### Create templates and render the drop-in

        Render the wishlist components on the page. The example below provides the minimal configuration options required to render the default wishlist components:

        ```js title="commerce-wishlist.js"
        const showAuthModal = (event) => {
            if (event) {
                event.preventDefault();
            }

            const signInModal = document.createElement('div');
            signInModal.setAttribute('id', 'signin-modal');

            const signInForm = document.createElement('div');
            signInForm.setAttribute('id', 'signin-form');

            signInModal.onclick = (clickEvent) => {
                if (clickEvent.target === signInModal) {
                    signInModal.remove();
                }
            };

            signInModal.appendChild(signInForm);
            document.body.appendChild(signInModal);

            // Render auth form
            authRenderer.render(AuthCombine, {
                signInFormConfig: { renderSignUpLink: true },
                signUpFormConfig: {},
                resetPasswordFormConfig: {},
            })(signInForm);

            const authListener = events.on('authenticated', (authenticated) => {
                if (authenticated) {
                    signInModal.remove();
                    authListener.off();
                }
            });
        };

        export default async function decorate(block) {
            const {
                'start-shopping-url': startShoppingURL = '',
            } = readBlockConfig(block);

            await wishlistRenderer.render(Wishlist, {
                routeEmptyWishlistCTA: startShoppingURL ? () => rootLink(startShoppingURL) : undefined,
                moveProdToCart: cartApi.addProductsToCart,
                routeProdDetailPage: (product) => rootLink(`/products/${product.urlKey}/${product.sku}`),
                onLoginClick: showAuthModal,
                getProductData: pdpApi.getProductData,
                getRefinedProduct: pdpApi.getRefinedProduct,
            })(block);
        }
        ```

        Test the wishlist component by viewing your wishlist page in a browser, or running your local dev or build server. If you see the wishlist component rendered in the browser, congrats!, you have a successful installation. If not, check the console for any errors and verify that you have followed all the steps correctly.

    </Task>



## Summary

The installation of all drop-in components follows the same pattern demonstrated by installing the PDP drop-in: Install, Map, Import, Connect, Register, and Render.

---

# Wishlist styles

The CSS classes for each UI component that provides the wishlist drop-in component with its UI are provided here. Override these classes and add new classes to customize the look and feel of your wishlist drop-in component to match your specific style requirements.

## Customizing your Wishlist styles

The quickest way to override wishlist CSS is to inspect the wishlist UI from your browser's developer tools.


    ![Find CSS classes to override](@images/dropins/wish-list/inspector.png/)




- 1. **Inspect the element** in the UI that you want to customize (right-click on the element and select "Inspect" from the menu).
- 2. **Identify the CSS class(es)** for the element. We use [BEM naming](https://getbem.com/naming/), which makes it easy to know which component you're changing (and which CSS file to use). This class styles the `Wishlist` component, so use your `Wishlist.css` file.



## Example CSS overrides

Here's an example of adding CSS class overrides to your `Wishlist.css` file:

```css title="wishlist.css"
.wishlist-wishlist__heading-count {
    color: #3D3D3D;
}

.wishlist-product-item-name {
  width: 65%;
}

```

## PDP Component CSS

The CSS classes for each PDP Component are provided here.











## Summary

You can customize the wishlist component by overriding the CSS classes provided for each component. Create a CSS file for each component to make it easier to maintain and update your Wishlist CSS. Use the BEM naming convention and your browser's dev tools to identify and copy the class to your corresponding component CSS file and override it as needed. Happy styling! ðŸŽ¨

---

# Company Management Data & Events

{/*
  âš ï¸ TEMPLATE USAGE GUIDE âš ï¸
  
  This template is used by scripts/generate-events-docs.js to generate event documentation.
  
  WHAT THE SCRIPT USES FROM THIS TEMPLATE:
  - Section headings and descriptive text (used as-is)
  - Import statements
  - The REPEAT_FOR_EACH_EVENT block (replicated for each event)
  - Placeholders: Company Management, Company Management, EVENT_NAME, etc.
  
  WHAT THE SCRIPT GENERATES INDEPENDENTLY:
  - Table contents between START/END markers (example rows are for reference only)
  - Event-specific data (names, descriptions, payloads from source repos)
  
  TO CHANGE:
  - Section text/descriptions â†’ Edit this template
  - Table structure (columns, links, formatting) â†’ Edit scripts/generate-events-docs.js
  - Both template and script must be kept in sync for table structure changes
*/}


The **Company Management** drop-in uses the [Event Bus](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/events/) to emit and listen to events for communication between drop-ins and external integrations. For common events shared across multiple drop-ins (such as `locale`, `error`, `authenticated`, etc.), see the [Common Events Reference](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/#common-events-reference).

## Events reference

{/* EVENTS_TABLE_START */}


| Event | Direction | Description |
|-------|-----------|-------------|
| [company/updated](#companyupdated-emits) | Emits | Emitted when the component state is updated |
| [companyContext/changed](#companycontextchanged-listens) | Listens | Fired by Company Context (`companyContext`) when a change occurs |


{/* EVENTS_TABLE_END */}

## Event details

The following sections provide detailed information about each event, including its direction, data payload structure, and usage examples.


### `company/updated` (emits)

Emitted when the component state is updated

#### Data payload

```typescript
{ company?: any; message?: string; error?: any }
```

| Property | Type | Description |
|----------|------|-------------|
| `company` | `any` (optional) | See type definition in source code |
| `message` | `string` (optional) | See type definition in source code |
| `error` | `any` (optional) | See type definition in source code |


#### Usage

Listen to this event in your storefront:

```javascript

const companyUpdatedListener = events.on('company/updated', (data) => {
  console.log('company/updated event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
companyUpdatedListener.off();
```

### `companyContext/changed` (listens)

Fired by Company Context (`companyContext`) when a change occurs

#### Data payload

```typescript
string | null | undefined
```



#### Usage

Listen to this event in your storefront:

```javascript

const companyContextChangedListener = events.on('companyContext/changed', (data) => {
  console.log('companyContext/changed event received:', data);
  // Add your custom logic here
});

// Later, when you want to stop listening
companyContextChangedListener.off();
```

---

# B2B Commerce Overview

Adobe Commerce B2B provides powerful business-to-business commerce capabilities designed to meet the unique needs of organizations selling to other businesses. This comprehensive solution enables complex B2B workflows, pricing structures, and purchasing processes.

## Key B2B Features


  <Card title="Company Management" icon="users">
    Advanced company account structures with hierarchical user management and permissions.
  </Card>
  <Card title="Quote System" icon="document">
    Negotiable quotes and approval workflows for complex B2B purchasing processes.
  </Card>
  <Card title="Custom Pricing" icon="dollar-sign">
    Tiered pricing, volume discounts, and customer-specific pricing structures.
  </Card>
  <Card title="Purchase Orders" icon="clipboard">
    Support for purchase order workflows and approval processes.
  </Card>
  <Card title="Requisition Lists" icon="list">
    Reorderable product lists for streamlined repeat purchases.
  </Card>
  <Card title="Credit Management" icon="credit-card">
    Credit limits and payment terms management for business customers.
  </Card>


## Getting Started with B2B

B2B commerce implementations require careful planning and configuration to meet specific business requirements. Key considerations include:

- **Company Structure**: Define how companies and users are organized
- **Pricing Strategy**: Implement tiered pricing and volume discounts
- **Approval Workflows**: Set up quote and purchase order approval processes
- **Catalog Management**: Configure shared catalogs for different customer segments
- **Integration Requirements**: Plan for ERP and other business system integrations

## B2B Drop-ins and Components

Adobe Commerce B2B extends the standard storefront drop-ins with specialized B2B functionality:

- Enhanced user account management for company structures
- Quote request and management interfaces
- Requisition list functionality
- Company-specific product catalogs
- Advanced pricing displays

## Next Steps

Ready to start building your B2B commerce solution? Explore the documentation to learn more about:

- B2B-specific drop-in components
- Configuration best practices  
- Integration patterns
- Customization approaches

For detailed implementation guidance, consult the B2B setup and configuration documentation.

---

# Overview of B2B drop-ins

This section contains B2B-specific drop-in components for Adobe Commerce Storefront. These components are designed to handle business-to-business commerce scenarios and provide specialized functionality for B2B customers.

## Available B2B Drop-ins

B2B drop-ins will be listed here as they are added to this section.

For more information about B2B functionality, refer to the [Adobe Commerce B2B documentation](https://experienceleague.adobe.com/docs/commerce-admin/b2b/introduction.html).

---

# Accordion



---

# ActionButton



---

# ActionButtonGroup



---

# AlertBanner



---

# Breadcrumbs



---

# Button



---

# Card



---

# CartItem



---

# CartList



---

# Checkbox



---

# Color Swatch



---

# ContentGrid



---

# Divider



---

# Field



---

# Header



---

# Icon



---

# IllustratedMessage



---

# Image



---

# Image Swatch



---

# Incrementer



---

# Inline Alert



---

# Input



---

# InputDate



---

# InputFile



---

# InputPassword



---

# Modal



---

# Overview

A flexible set of interactive building blocks, such as actions, containment,
navigation, text, and selection elements, thought to create unique tailored
commerce user interfaces.

## Components

The SDK provides the following collection of reusable UI components:

- [Accordion](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/accordion/) - Expandable content sections
- [ActionButton](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/actionbutton/) - Button with loading states
- [ActionButtonGroup](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/actionbuttongroup/) - Group of action buttons
- [AlertBanner](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/alertbanner/) - Notification banner
- [Breadcrumbs](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/breadcrumbs/) - Navigation breadcrumbs
- [Button](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/button/) - Basic button component
- [Card](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/card/) - Content container
- [CartItem](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/cartitem/) - Shopping cart item
- [CartList](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/cartlist/) - Shopping cart list
- [Checkbox](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/checkbox/) - Checkbox input
- [ColorSwatch](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/colorswatch/) - Color selection swatch
- [ContentGrid](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/contentgrid/) - Grid layout for content
- [Divider](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/divider/) - Horizontal divider
- [Field](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/field/) - Form field wrapper
- [Header](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/header/) - Page header
- [Icon](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/icon/) - SVG icon component
- [IllustratedMessage](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/illustratedmessage/) - Illustration with text
- [Image](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/image/) - Image component
- [ImageSwatch](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/imageswatch/) - Image selection swatch
- [Incrementer](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/incrementer/) - Incrementer component
- [InlineAlert](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/inlinealert/) - Inline alert component
- [Input](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/input/) - Text input field
- [InputDate](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/inputdate/) - Date input field
- [InputFile](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/inputfile/) - File upload input
- [InputPassword](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/inputpassword/) - Password input field
- [Modal](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/modal/) - Modal component
- [Pagination](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/pagination/) - Page navigation
- [Picker](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/picker/) - Selection picker
- [Price](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/price/) - Price display
- [PriceRange](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/pricerange/) - Price range display
- [ProgressSpinner](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/progressspinner/) - Loading indicator
- [RadioButton](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/radiobutton/) - Radio button input
- [Skeleton](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/skeleton/) - Loading placeholder
- [Tag](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/tag/) - Label tag
- [TextArea](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/textarea/) - Multi-line text input
- [TextSwatch](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/textswatch/) - Text selection swatch
- [ToggleButton](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/togglebutton/) - Toggle switch button

By using these components, you can create a consistent and engaging user experience across your application. Each component is designed to be flexible and customizable, allowing you to tailor the UI to your specific needs and brand.

---

# Pagination



---

# Picker



---

# Portal



---

# Price



---

# PriceRange



---

# Product Item Card



---

# Progress Spinner



---

# Radio Button



---

# Skeleton



---

# Tag



---

# TextArea



---

# Text Swatch



---

# ToggleButton



---

# Base Design System

With the base design system, you can use system and reference tokens to ensure color, typography, spacing, and shape values are consistent across your site.

## What are design tokens?

Design tokens are design decisions that ensure a unified and cohesive product experience. The tokens represent a consistent use of design data that provides specific values for spacing, color, typography, and shapesâ€”without hard-coding those values.

Our Base design tokens are directly integrated into our shared components. They cover the various options for platforms, component states, and more.


## Extending the baseline design tokens

Base includes a set of baseline design tokens and default values for you to
customize, collaborate on, and use in your own designs and product
implementation.

It's important to keep in mind that not every component is going to be
captured in the foundational and baseline design tokens. If they're limited
for what you're trying to design or build, just add in the tokens you may
need within each category.

## How to use design tokens

To apply design tokens on your project, make use of the UIProvider, which grants components access to the design tokens as CSS variables. Simply specify the desired design token using the var() CSS function to apply its corresponding value.

```css
.myComponent {
  background-color: var(--color-brand-500);
}
```

---

# Colors



---

# Grids



---

# Overview

The Base design system provides a comprehensive set of design tokens and guidelines that form the foundation of our component library. It defines core visual elements like colors, typography, spacing, and shapes to ensure consistency across your application. By leveraging these design tokens through our components, you can create cohesive user experiences while maintaining flexibility to customize the look and feel to match your brand.

## Topics

- [Colors](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/design/colors/) - Color tokens and usage
- [Typography](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/design/typography/) - Font families, sizes and styles
- [Spacing](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/design/spacing/) - Spacing scale and tokens
- [Shapes](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/design/shapes/) - Border radius and other shape tokens
- [Grids](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/design/grid/) - Layout grid system

By following these design guidelines and utilizing the provided tokens, you can create consistent, accessible, and visually appealing interfaces that align with modern design principles. The Base design system serves as a solid foundation that can be extended and customized to meet your specific needs while maintaining cohesion across your application.

---

# Shapes



---

# Spacing



---

# Typography



---

# CLI usage

To see all the available CLI commands in the terminal, use the `--help` flag:

```bash
npx elsie --help
```

## `gql`

The `gql` command can generate types and mocks for your GraphQL API. Files will
be generated in `<domain package root>/src/__generated__/`.

To use it, you must first configure your `.elsie.js` with the necessary values:

```js
// For Adobe Commerce Catalog Service
schema: {
    endpoint: "https://catalog-service-sandbox.adobe.io/graphql",
    headers: {
        "MAGENTO-ENVIRONMENT-ID": "..."
        "MAGENTO-STORE-VIEW-CODE": "..."
        "MAGENTO-WEBSITE-CODE": "..."
        "MAGENTO-STORE-CODE": "..."
        "MAGENTO-CUSTOMER-GROUP": "..."
        "API-KEY": "..."
    }
}
```

```js
// For Adobe Mesh API
schema: {
    endpoint: "https://graph.adobe.io/api/.../graphql?api_key=...",
    headers: {
        "some-mesh-specific-header": "mesh-header-value"
    }
}
```

```js
// For Adobe Commerce (non-Mesh)
schema: {
    endpoint: "https://commerce-backend-url.test.graphql",
    headers: {}
}
```

Then the following commands will generate to

```bash
npx elsie gql types
```

```bash
npx elsie gql mocks
```

## `generate`

Summary list of commands for quick copy/paste.

```bash
npx elsie generate config --name <Domain>
```

```bash
npx elsie generate component --pathname <MyUIComponent>
```

```bash
npx elsie generate container --pathname <MyContainer>
```

```bash
npx elsie generate api --pathname <myApiFunction>
```

## Add Config

Generate a new `.elsie.js` configuration file for the project.

```bash
npx elsie generate config --name <Domain>
```

```javascript
module.exports = {
  name: '<Domain>',
  api: {
    root: './src/api',
    importAliasRoot: '@/<Domain>/api',
  },
  components: [
    {
      id: 'Components',
      root: './src/components',
      importAliasRoot: '@/<Domain>/components',
      cssPrefix: 'elsie',
      default: true,
    },
  ],
  containers: {
    root: './src/containers',
    importAliasRoot: '@/<Domain>/containers',
  },
  schema: {
    endpoint: process.env.ENDPOINT,
    // Add necessary headers
    headers: {},
  },
};
```

## Add Component

Generate a new UI Component for the project.

```bash
npx elsie generate component --pathname <MyUIComponent>
```

```bash
ðŸ†• src/components/LoginForm/LoginForm.css created
ðŸ†• src/components/LoginForm/LoginForm.stories.tsx created
ðŸ†• src/components/LoginForm/LoginForm.test.tsx created
ðŸ†• src/components/LoginForm/LoginForm.tsx created
ðŸ†• src/components/LoginForm/index.ts created
âœï¸ src/components/index.ts updated
```

## Add Container

Generate a new Frontend Container for the project.

```bash
npx elsie generate container --pathname <MyContainer>
```

```bash
ðŸ†• src/containers/Login/Login.stories.tsx created
ðŸ†• src/containers/Login/Login.test.tsx created
ðŸ†• src/containers/Login/Login.tsx created
ðŸ†• src/containers/Login/index.ts created
âœï¸ src/containers/index.ts updated
```

## Add Function

Generate a new API function for the project.

```bash
npx elsie generate api --pathname <myApiFunction>
```

```console
ðŸ†• src/api/login/login.mdx created
ðŸ†• src/api/login/login.test.ts created
ðŸ†• src/api/login/login.ts created
ðŸ†• src/api/login/index.ts created
âœï¸ src/api/index.ts updated
```

---

# Introduction to the Drop-in SDK

Welcome to the Drop-in SDK Documentation! This SDK provides the tools and resources to help you build and customize your storefront. Whether you're new to drop-in components or looking to optimize your store, this SDK should provide the resources you need. If it doesn't, please reach out to the Commerce team.

## Big picture

For the frontend, the drop-in SDK includes our design system, which provides the components and design tokens that make merchant rebranding quick and easy.

For everything else, the drop-in SDK provides a complete framework for mounting, rendering, eventing, testing, and hydrating drop-ins with data from the Commerce backend.

## Get started

Get started with the Drop-in SDK:

- [CLI usage](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/get-started/cli/)

The Drop-in SDK aims to streamline your development process while maintaining flexibility for customization. By providing a robust set of components, utilities, and design tokens, along with comprehensive documentation and examples, we hope to empower you to create exceptional commerce experiences. Explore the documentation to learn more about the SDK's capabilities and how to leverage them effectively in your projects.

---

# Event Bus

The Event Bus enables different parts of your application to communicate and stay synchronized through message passing. It supports event-driven architecture for drop-ins, allowing containers to react to changes from other containers and communicate data changes to the storefront.

> **Note:** **New to event-driven architecture?** Learn about the [event system architecture and patterns](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/) including the publish-subscribe pattern, event declarations, and best practices before diving into the API.

## Import

**From drop-in project using the SDK:**

```ts
```

**From integration project (storefront):**

```js
```

## Core Methods

### Subscribe to Events

Subscribe to events and receive notifications when they occur.

```ts
const eventListener = events.on('<event>', (payload) => {
  // Handle the event payload
  console.log('Event received:', payload);
});

// Stop listening to the event
eventListener.off();
```

**Example:**
```ts
// Listen for cart updates
const cartListener = events.on('cart/data', (cartData) => {
  if (cartData) {
    console.log(`Cart has ${cartData.totalQuantity} items`);
    updateCartUI(cartData);
  } else {
    console.log('Cart is empty');
    showEmptyCart();
  }
});

// Later, when you want to stop listening
cartListener.off();
```

### Emit Events

Broadcast events to all listeners across your application.

```ts
events.emit('<event>', payload);
```

**Examples:**
```ts
// Emit cart data
const cartData = {
  id: 'cart-123',
  totalQuantity: 2,
  items: [
    { uid: 'item-1', quantity: 1, sku: 'PROD-001', name: 'Product Name' }
  ]
};

events.emit('cart/data', cartData);
```

### Get Last Event Payload

Retrieve the most recent payload for a specific event.

```ts
const lastPayload = events.lastPayload('<event>');
```

**Example:**
```ts
// Get the current cart state without waiting for an event
const currentCart = events.lastPayload('cart/data');

if (currentCart) {
  console.log('Current cart total:', currentCart.totalQuantity);
}
```

### Enable Debug Logging

Enable console logging to debug event flow.

```ts
// Enable logging to see all events in console
events.enableLogger(true);
```

## Advanced Features

### Eager Loading

When subscribing to events, you can execute the event handler immediately with the last known payload. This is useful for getting the current state without waiting for the next event.

```ts
// Handler will execute immediately if there's a previous payload
const listener = events.on('cart/data', (cartData) => {
  console.log('Cart data received:', cartData);
}, { eager: true });
```

**Use cases:**
- Initialize UI components with current state
- Avoid waiting for the first event emission
- Ensure components have the latest data on mount

### Event Scoping

Create namespaced events to avoid conflicts between different parts of your application.

```ts
// Subscribe to a scoped event
const scopedListener = events.on('data/update', (data) => {
  console.log('Scoped data received:', data);
}, { scope: 'feature-a' });

// Emit a scoped event
events.emit('data/update', payload, { scope: 'feature-a' });

// Get last payload for a scoped event
const lastScopedData = events.lastPayload('data/update', { scope: 'feature-a' });
```

**Scoped event names:**
When using scopes, the actual event name becomes `scope/event`. For example:
- `'feature-a/data/update'` instead of `'data/update'`
- `'module-b/user/action'` instead of `'user/action'`

**Use cases:**
- Separate different features or modules
- Different contexts within the same application
- Component-specific event handling

### Combining Options

Use both eager loading and scoping together for powerful event handling.

```ts
// Subscribe to a scoped event with eager loading
const listener = events.on('locale', (locale) => {
  console.log('Current locale:', locale);
}, { 
  eager: true, 
  scope: 'user-preferences' 
});
```

## Event-Driven Drop-ins

The Event Bus enables drop-ins to be truly event-driven, allowing for loose coupling between components and seamless communication across the application.

### Container-to-Container Communication

Containers can react to changes from other Containers, enabling complex interactions without direct dependencies.

```ts
// Product Container: Emits when a product is added to cart
function ProductContainer() {
  const handleAddToCart = (product) => {
    // Add to cart logic...
    
    // Notify other containers about the cart change
    events.emit('cart/data', updatedCartData);
  };
  
  return (
     handleAddToCart(product)}>
      Add to Cart
    
  );
}

// Cart Container: Reacts to cart changes from any source
function CartContainer() {
  useEffect(() => {
    const cartListener = events.on('cart/data', (cartData) => {
      updateCartDisplay(cartData);
      updateCartBadge(cartData.totalQuantity);
    }, { eager: true });
    
    return () => cartListener.off();
  }, []);
  
  return ;
}

// Mini Cart Container: Also reacts to the same cart changes
function MiniCartContainer() {
  useEffect(() => {
    const cartListener = events.on('cart/data', (cartData) => {
      updateMiniCart(cartData);
    }, { eager: true });
    
    return () => cartListener.off();
  }, []);
  
  return ;
}
```

### Storefront Communication

Drop-ins can communicate data changes to the storefront, enabling seamless integration with the host application.

```ts
// Authentication Container: Notifies storefront of login/logout
function AuthContainer() {
  const handleLogin = (userData) => {
    // Login logic...
    
    // Notify storefront of authentication change
    events.emit('authenticated', true);
  };
  
  const handleLogout = () => {
    // Logout logic...
    
    // Notify storefront of authentication change
    events.emit('authenticated', false);
  };
  
  return ;
}

// Storefront can listen for authentication changes
// This would be in the host application
const authListener = events.on('authenticated', (isAuthenticated) => {
  if (isAuthenticated) {
    showUserMenu();
    enableCheckout();
  } else {
    hideUserMenu();
    disableCheckout();
  }
}, { eager: true });
```

## Best Practices


1. **Always unsubscribe** from events when components unmount to prevent memory leaks
2. **Use scopes** to organize events by feature or component
3. **Enable eager loading** when you need immediate access to current state
4. **Use descriptive event names** that clearly indicate what data they contain
5. **Handle null/undefined payloads** gracefully in your event handlers
6. **Enable logging during development** to debug event flow
7. **Keep event payloads lightweight** to avoid performance issues
8. **Document your event contracts** so other developers know what to expect

---

# GraphQL Extensibility API

The GraphQL Extensibility API allows developers to extend existing GraphQL operations used by a Drop-in to meet additional data requirements without increasing code complexity or negatively impacting performance. 
This API provides a flexible and efficient way to customize GraphQL Fragments by integrating build-time modifications into the storefront's development pipeline.

## Extend your Drop-in GraphQL Fragments

To enable GraphQL Fragments to be extensible in your Drop-in, follow these steps:



<Task>
### Define Your Fragments

Create the content for the fragments you are exporting.

```ts
// ./src/api/fragments/MyFragment.ts

export const MY_FRAGMENT = `
  fragment MY_FRAGMENT on FragmentInterface {
    firstname
    lastname
    
    favorites {
      uid
      name
    }
  }
`;
```

</Task>

<Task>
### Create Fragments Manifest File

Next, create a new file for your project to list all the fragments you want to expose.

```ts
// ./src/api/fragments.ts

export { MY_FRAGMENT } from '@/my-dropin/api/graphql/MyFragment';
```

</Task>

<Task>
### Update the API Configuration

Finally, add the new file reference to the API configuration in `./.elsie.js`.

```js
// ./.elsie.js

module.exports = {
  name: 'MyDropin',
  api: {
    root: './src/api',
    importAliasRoot: '@/my-dropin/api',
    fragments: './fragments.ts', // ðŸ‘ˆ add this line
  },
  components: [
    {
      id: 'Components',
      root: './src/components',
      importAliasRoot: '@/my-dropin/components',
      cssPrefix: 'my-dropin',
      default: true,
    },
  ],
  containers: {
    root: './src/containers',
    importAliasRoot: '@/my-dropin/containers',
  },
  schema: {
    endpoint: process.env.ENDPOINT,
    headers: {}
  }
};
```

</Task>



## Extend the Data module

Now that we have made our fragments extensible, we must extend the data model used in our Drop-ins.



<Task>
### Define Typing to the Initializer API

First, add the typing to your initializer API in `./src/api/initialize/initialize.ts`.

```ts
// ./src/api/initialize/initialize.ts


type ConfigProps = {
  langDefinitions?: Lang;

  // ðŸ‘‡ add your models configuration
  models?: {
    MyModel?: Model<MyModel>;
  },
};

export const initialize = new Initializer<ConfigProps>({
  init: async (config) => {
    const defaultConfig = {};
    initialize.config.setConfig({ ...defaultConfig, ...config });
  },

  listeners: () => [],
});

export const config = initialize.config;
```

</Task>

<Task>
### Extend the Data Transformer

Then, use the configuration to extend the data transformer the model uses by deep merging the existing data transformation with the new configuration.

```ts
// ./src/data/transforms/transform-my-model.ts

export function transformMyModel(data: any): MyModel {
  const model = {
    name: `${data.firstname} ${data.lastname}`,
    favorites: data.favorites,
  };

  // Merge custom transformer, if provided
  return merge(
    model, // default transformer
    config.getConfig().models?.MyModel?.transformer?.(data) // custom transformer
  );
}
```

</Task>



## Using the GraphQL Extensibility Feature in Your Storefront

By extending the GraphQL Fragments and Models of drop-ins, you can leverage the drop-in's existing GraphQL operations and add extra fields needed to meet your specific business requirements. 
This approach enhances the user experience while maintaining code simplicity and performance efficiency since all modifications are integrated into the storefront's development build-time pipeline.

## Extend Drop-in's Fragments and Models

Follow these steps to extend the GraphQL Fragment and Model in your Drop-in:



<Task>
### Extend the GraphQL Fragment

Use the `overrideGQLOperations` function to extend the existing GraphQL Fragment, allowing you to add fields to the fragment as needed.

The `overrideGQLOperations` functions accept an array of configuration objects where you must specify:

#### npm: string

The node module name of the drop-in. i.e. "@dropins/my-dropin".

#### operations: string[] 

An array of string or template literal with operations. 

- Only one definition can be provided in the operation.
- These must match the operation name as provided by the drop-in. i.e. `MY_FRAGMENT`.
- The operations must be valid GraphQL operations, such as Fragment. i.e. `fragment MY_FRAGMENT on FragmentInterface { ... }`.
- In the case of a Fragment, the fragment name must match the same interface as the drop-in. i.e. `FragmentInterface`.
- If an existing field that has variables is used:
    - If not variables are provided, the existing variables will be used. i.e. `favorites(page: 1) { ... }`.
    - If new variables are provided, the new variable will be added. i.e. `favorites(page: 1, offset: 5) { ... }`.
    - If the existing variables are changed, the new variables will be used. i.e. `favorites(page: 2) { ... }`.


```js

overrideGQLOperations([
  {
    npm: '@dropins/my-dropin',
    operations: [`
      fragment MY_FRAGMENT on FragmentInterface {
        age
        
        favorites {
          quantity
        }
      }
    `],
  },
]);
```
</Task>

<Task>
### Extend the Data Model

Next, update the data models to include the new fields added to the fragment, ensuring that the additional data is correctly processed and available for use in the drop-in. i.e., Slots, Event Bus, etc.

```js

initializers.register(api.initialize, {
  models: {
    MyModel: {
      transformer: (data) => ({
        age: data?.age,
        favorites: data.favorites.map((favorite) => ({ 
          quantity: favorite.quantity,
        })),
      }),
    },
  },
});
```
</Task>

---

# Overview

The reference section provides documentation for core SDK functionality like event handling, initialization, rendering, and integration with external services like reCAPTCHA. These APIs form the foundation for building and customizing drop-in components.

## Topics

- [Events](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/events/)
- [GraphQL](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/graphql/)
- [Initializer](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/initializer/) 
- [Links](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/links/) 
- [reCAPTCHA](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/recaptcha/)
- [Render](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/render/)
- [Slots](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/slots/)
- [VComponent](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/reference/vcomponent/)

By understanding and utilizing these core APIs effectively, you can take full advantage of the SDK's capabilities while maintaining control over the implementation details. The reference documentation provides the technical foundation needed to integrate and customize the SDK's functionality within your application.

---

# Initializer

```typescript
// my-domain-package/initializer.ts

// import { events } from '@adobe/event-bus';

type ConfigProps = {};

export const initialize = new Initializer<ConfigProps>({
  init: async (config) => {
    const defaultConfig = {};
    initialize.config.setConfig({ ...defaultConfig, ...config });
  },

  listeners: () => [
    // events.on('authenticated', (authenticated) => {
    //   console.log('authenticated', authenticated);
    // }),
  ],
});

export const config = initialize.config;
```

```typescript
// Host Site

// Register Packages
initializers.register(pkg, { ...config });

// Mount Initializers
window.addEventListener('load', initializers.mount);
```

## `setImageParamKeys(params)`

The `setImageParamKeys` method is part of the initializers module in the `@dropins/tools` package. It allows you to set image parameters globally for all drop-in components that use the [Image](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/components/image/) component. CDN-based image optimization services, such as Fastly and Cloudflare, rely on these parameters to optimize images.

### Default behavior

Since Fastly is the default CDN for Adobe Commerce on Cloud, drop-in components add the following Fastly-style parameters to all image URLs by default:

- `width`
- `height`
- `auto`
- `quality`
- `crop`
- `fit`

Example:

```text
/media/catalog/product/adobestoredata/ADB150.jpg?auto=webp&quality=80&crop=false&fit=cover&width=960&height=1191`
```

Technical details about CDN-based image optimization differ depending on your backend Adobe Commerce solution:

-  Fastly is the default CDN-based image optimization service for Adobe Commerce on Cloud projects. Fastly-style parameters are used by default unless overridden via `setImageParamKeys`.
  
-  Cloudflare is the default CDN-based image optimization service for Adobe Commerce as a Cloud Service and Adobe Commerce Optimizer projects. Fastly-style parameters are used but are proxied through a [Cloudflare Worker](https://developers.cloudflare.com/images/transform-images/transform-via-workers) to transform the parameters to Cloudflare-style parameters. Overriding the default parameters using `setImageParamKeys` may interfere with the proxy transformation and lead to unexpected results.

> **Note:** If necessary, you can override these parameters with the `setImageParamKeys` method. For example, if you are using a CDN provider that requires different parameters or URL patterns.

### Parameters

- `params` - `{ [key: string]: string | ((data: any) => [string, string]) }`
  - An object of key-value pairs to map image parameters to their respective keys in the URL.
  - The value can be a string or a function that takes the parameter value as an argument and returns a tuple of the new key and transformed value.

### Functionality

- If a parameter key is provided via `setImageParamKeys`, it is used in generating image URLs instead of the default Fastly parameters.
- If a parameter key is not provided via `setImageParamKeys`, it is omitted from the generated image URLs.
- If a mapped key is a function and it is not specified as a parameter in the Image component, it is called with `null`. It should return a tuple of the key and value.
- If a mapping callback is provided, the callback is called with the parameter value (if it exists) and should return a tuple of the new key and transformed value.
- If a mapping callback returns `null`, the parameter is omitted from the generated image URLs.

### Usage

Call the `setImageParamKeys()` function before the `mountImmediately()` function in the application layer.

```javascript
// Set global image parameters
initializers.setImageParamKeys({
  // Re-map the width parameter to imgWidth
  width: 'imgWidth',
  // Transform the quality parameter
  quality: (value) => ['imgQuality', value * 100],
  // Add an additional parameter to the image URL
  extraParam: () => ['extraParam', 'extraValue'],
});

// Register and Mount Initializers immediately
initializers.mountImmediately(pkg.initialize, {
  // other configurations...
});
```

Now, when a dropin uses the Image component to render an image with a width of 300 pixels and quality value of 0.8:

```jsx

```

It renders the following image element:

```html

```

In this example, the width parameter is mapped to imgWidth and the value of the quality parameter is modified and mapped to imgQuality.

## `setGlobalLocale(locale)`

The `setGlobalLocale()` method is part of the initializers module in the `@dropins/tools` package.
It allows you to set a global locale for all drop-ins that use locale-sensitive components like the Price component.

### Default behavior

By default, locale-sensitive components use the browser's locale or fallback to 'en-US' if no global locale is set. Locale-sensitive components follow this fallback hierarchy:

1. Component-specific `locale` prop (highest priority)
2. Global locale set via `setGlobalLocale()` 
3. Browser's locale (`navigator.language`)
4. Default fallback locale (`'en-US'`) (lowest priority)

This ensures that your storefront always displays properly formatted content, even when specific locales are not configured.

### Parameters

- `locale` - `string` - The locale string (e.g., 'en-US', 'es-MX', 'fr-FR', 'de-DE').

### Functionality

- If a global locale is set via `setGlobalLocale()`, it will be used by components that support locale configuration.
- Component-specific locale props will take precedence over the global locale.
- If no global locale is set, components will fall back to the browser's locale or a default locale.

### Usage

Call the `setGlobalLocale()` function before the `mountImmediately()` function in the application layer.

```javascript
// Set global locale for consistent formatting across all drop-ins
initializers.setGlobalLocale('fr-FR');

// Register and Mount Initializers immediately
initializers.mountImmediately(pkg.initialize, {
  // other configurations...
});
```

#### Basic Example

When a drop-in uses the Price component without specifying a locale prop:

```jsx

```

It will render with the global locale (fr-FR) formatting:

```html

  100,00 â‚¬

```

#### Override Example

If the same component is used with a specific locale prop, that will take precedence over the global setting:

```jsx

```

It will render with the specified locale (en-US) formatting:

```html

  â‚¬100.00

```

---

# Links

## Adding Links using the route pattern

Whenever possible, avoid placing `onClick` handlers directly on anchor elements (``) in drop-in components, such as product or category pages, as this results in accessibility issues and broken browser behavior. Problems include:

- Right-click > Open in New Tab results in blank pages.
- Middle-click (open in background tab) won't work as expected.
- Keyboard navigation and screen readers may not trigger the link correctly.

Instead, follow the route pattern to provide composable and accessible navigation.

## How it works

Components accept a `routeX` function as a prop. The function receives a data model (a product, for example) and returns a URL. Internally, it's used like this:

```tsx
<a href={routeProduct?.(product) ?? '#'}>...
```

This lets developers customize routing logic per storefront while preserving link semantics.

## Example â€” Component-Side

In your component (a PLP item, for example):

The `routeProduct` prop must be optional and default to a # or an non-functional element like a `div` if not provided.

```tsx
type Props = {
  routeProduct?: (product: ProductModel) => string;
};

function ProductCard({ product, routeProduct }: Props) {
  return (
    
      <div>{product.name}</div>
    
  );
}
```

## Example â€” Storefront-Side

In the storefront integration (`commerce-cart.js` or `commerce-plp.js`, for example):

```js

provider.render(ProductList, {
  routeProduct: (product) => rootLink(`/products/${product.url.urlKey}/${product.topLevelSku}`),
});
```

---

# reCAPTCHA Integration

The reCAPTCHA module is implemented as a standalone SDK package. It enables reCAPTCHA protection, which is natively supported by Adobe Commerce. It also provides an API allowing merchants to integrate reCAPTCHA protection into custom implementations. The current version of the module supports only reCAPTCHA v3 Invisible.

## Installation

To install this functionality, run the following command:

```bash
npm i @adobe/reCAPTCHA
```

[Google reCAPTCHA](https://experienceleague.adobe.com/en/docs/commerce-admin/systems/security/captcha/security-google-recaptcha) in the _Admin Systems Guide_ describes how to configure Adobe Commerce.

## Integrations

To integrate ReCaptcha, follow these steps:

1. Load the app.

   - Call the `setConfig` method to fetch and set reCAPTCHA configuration.
   - (Optional) Extend the configuration with custom forms if a custom integration not natively supported by Adobe Commerce is planned.

2. Load the page with a protected form. Call the `initReCaptcha` method to add the script and initialize the ReCaptcha badge.

3. Render the form.

   - The user interacts with the page and form, providing the required data.
   - The user clicks the submit button.

4. Call the `verifyReCaptcha` API to retrieve the reCAPTCHA token via the Google API.

### Flow for forms covered by Adobe Commerce natively

Use the following workflow for standard Adobe Commerce integrations

1. Set the reCAPTCHA token in the X-ReCaptcha header.

1. Send the request to the backend.

1. Commerce validates the token. If it fails, Commerce returns an error.


### Flow for custom integrations

Use one of the following workflows for custom integrations:

- (Recommended) Send the token to Commerce and validate it on the server side. If validation passes, Commerce returns a normal response. Otherwise, it returns an error.

- Validate the token on the client side. If validation passes, send the request.

## reCAPTCHA API

The reCAPTCHA package exposes the following APIs, allowing developers to integrate it with native Adobe Commerce functionality or set up custom integrations:

* `setConfig`
* `setEndpoint`
* `initreCAPTCHA`
* `verifyreCAPTCHA`
* `enableLogger`

### setConfig

The `setConfig` method fetches and stores the reCAPTCHA configuration from the backend.
It is essential to call this method before the `initreCAPTCHA` and `verifyreCAPTCHA` methods during app initialization, because other reCAPTCHA functionality will not be fully operational until the configurations are loaded and set up.

#### Usage

The `setConfig` method is intended to be called without parameters, in which case the backend configuration will be used.

```javascript

reCAPTCHA.setConfig();
```

However, you can pass a configuration object as a parameter to override the backend configurations.

```javascript

reCAPTCHA.setConfig({is_enabled: true});
```

### setEndpoint

The `setEndpoint` method sets the endpoint that the recaptcha module uses to fetch configurations. Its use is optional. If reCAPTCHA uses the same mesh endpoint as the rest of the application, you do not need to set it explicitly. It will be inherited from the fetch-graphql package.

#### Usage

The following example sets the endpoint:

```javascript

reCAPTCHA.setEndpoint('https://www.example.com/graphql');
```

### initreCAPTCHA

The `initreCAPTCHA` method initializes reCAPTCHA scripts and badges. Call this method after the `setConfig` method and before rendering forms with reCAPTCHA protection.

The `initreCAPTCHA` method should be called before each form rendering. Do not call it at the top level of the application, immediately after the `setConfig` API, because this would load reCAPTCHA scripts on all pages, not just those with forms protected by reCAPTCHA.

Additionally, you must call `initreCAPTCHA` for each form render to ensure the script is in place and the reCAPTCHA badge is properly initialized.

#### Usage

The following example initializes reCAPTCHA:

```javascript

reCAPTCHA.initreCAPTCHA();
```

### verifyreCAPTCHA

The `verifyreCAPTCHA` method retrieves the reCAPTCHA token via the Google API. It should be called after `setConfig` and `initreCAPTCHA`, and before submitting a protected form to retrieve the reCAPTCHA token.

When the reCAPTCHA token is retrieved, for forms covered by native Adobe Commerce functionality, it is required to pass this token as an X-reCAPTCHA header.

For custom implementations, token validation should be implemented on either the server side or client side, and the token should be used according to the custom implementation.

#### Usage

The following example retrieves the reCAPTCHA token:

```javascript

export const setreCAPTCHAToken = async () => {
 const token = await verifyreCAPTCHA();

 if (token) {
   setFetchGraphQlHeader('X-reCAPTCHA', token);
 }
};
```

### enableLogger

The `enableLogger` method enables extensive logging to the console for each step and error during reCAPTCHA operations. It is intended for development and debugging purposes.

#### Usage

The following example enables the logger:

```javascript 

reCAPTCHA.enableLogger(true);
```

---

# Render

## Implementing a new render in your dropin

To implement a new render in your dropin, you must create an instance of the `Render` class from the `@adobe-commerce/elsie/lib` library, passing in a `Provider` component.

This setup initializes the rendering context with the specified provider, which can manage state, context, or other dependencies required by your components.

By exporting this `render` instance, you enable different parts of your application to render components within the defined context, ensuring consistent behavior and integration across your application.

```ts
// Dropin


export const render = new Render();
```

## Rendering a dropin's container in a storefront

The render function mounts a drop-in container or component into the DOM and manages its lifecycle. 
It returns a Promise that resolves to an object containing methods for updating and removing the component instance.

```js
// Storefront

const wrapper = document.getElementById('my-container-root');

provider.render(MyContainer, { ...props })(wrapper);
```

### Using VNode as a property

Some components may require VNodes as properties. If you are using another component from the library, provide the VNode by executing the component as a function.

```js
// Storefront


const wrapper = document.getElementById('my-container-root');

provider.render(Button, { 
    children: 'My Button', 
    icon: Icon({ source: 'Heart' }), 
})(wrapper);
```

You may also create your VNode using the `h` function from the Preact library. 

```js
// Storefront


const wrapper = document.getElementById('my-container-root');

provider.render(Button, { icon: h('div', { id: 'my-vnode' }) })(wrapper);
```

### Update properties of a rendered component

The `setProps` method is provided by the instance returned from the `render` function. 
It allows for dynamic updates to the properties of a rendered component. 
By accepting an updater function, `setProps` lets you modify the component's props based on its previous state. 
This method is particularly useful for making incremental changes or responding to user interactions 
without re-rendering the entire component. It ensures that the component's state remains consistent
and up-to-date with the latest data or user inputs.

#### Example

```js
// Storefront


const wrapper = document.getElementById('my-container-root');
const myContainer = await provider.render(MyContainer, { ...props })(wrapper);

const button = document.getElementById('my-button');

button.addEventListener('click', () => {
    // Update the component's props
    myContainer.setProps((prevProps) => ({
    ...prevProps,
    newProp: 'new value',
    }));
});
```

### Remove a rendered component from the DOM

The `remove` method is provided by the instance returned from the `render` function. 
It allows for the complete removal of a rendered component from the DOM. 
When invoked, `remove` ensures that the component and its associated resources are properly cleaned up, 
preventing memory leaks and maintaining the application's overall performance. 
This method is essential for managing the lifecycle of dynamic components, 
especially in applications where components need to be frequently added and removed based 
on user interactions or other events.

```js

const wrapper = document.getElementById('my-container-root');
const myContainer = await provider.render(MyContainer, { ...props })(wrapper);

const button = document.getElementById('my-button');

button.addEventListener('click', () => {
    // Remove the component from the DOM
    myContainer.remove();
});
```

---

# Slots

A Slot is a high-level interface for developers to define and manage dynamic content insertion within drop-in components.

## Context

The context is defined during implementation of a drop-in and can be used to pass data and functions to the slot.

### Pre-built Methods

- **dictionary**: The dictionary of the selected language.
- **replaceWith**: A function to replace the slot's content with a new HTML element.
- **appendChild**: A function to append a new HTML element to the slot's content.
- **prependChild**: A function to prepend a new HTML element to the slot's content.
- **appendSibling**: A function to append a new HTML element after the slot's content.
- **prependSibling**: A function to prepend a new HTML element **before** the slot's content.
- **getSlotElement**: A function to get a slot element.
- **onChange**: A function to listen to changes in the slot's context.

---

## Implementing a new slot

The `` component is used to define a slot in a container. It receives a name and a slot object with the following properties:

### name

The name of the slot in _PascalCase_. `string` (required).

### slotTag

The HTML tag to use for the slot's wrapper element. This allows you to change the wrapper element from the default `div` to any valid HTML tag (e.g., 'span', 'p', 'a', etc.). When using specific tags like 'a', you can also provide their respective HTML attributes (e.g., 'href', 'target', etc.).

Example:
```tsx
// Render with a span wrapper

  Inline content


// Render with an anchor wrapper

  Link content

```

### contentTag

The HTML tag to use for wrapping dynamically inserted content within the slot. This is separate from the slot's wrapper tag and allows you to control how dynamic content is structured. Defaults to 'div'.

Example:
```tsx
<Slot
  name="MySlot"
  slotTag="article"    // The outer wrapper will be an article
  contentTag="section" // Dynamic content will be wrapped in sections
  slot={(ctx) => {
    const elem = document.createElement('div');
    elem.innerHTML = 'Dynamic content';
    ctx.appendChild(elem); // This will be wrapped in a section tag
  }}
/>
```

### slot (required)

- `ctx`: An object representing the context of the slot, including methods for manipulating the slot's content.

The slot property, which is implemented as a promise function, provides developers with the flexibility to dynamically generate and manipulate content within slots. 
However, it's important to note that this promise is render-blocking, meaning that the component will not render until the promise is resolved.

### context

The context property in the Slot component lets developers pass extra information or functionality to customize how the slot
behaves or interacts with the application. This information is accessible within the slot's rendering logic, allowing for
tailored slot behavior based on specific needs or application states.

### render

The render property in the Slot component lets developers define how the content within the slot should be displayed and should be used when developers
need fine-grained control over what content appears within the slot.
It's particularly useful when using custom slot methods (see Privates below) in scenarios where the content to be displayed within the slot is dynamic and may depend on
properties passed to another component.

### children

The children property in the Slot component represents the content that is passed directly within the opening and closing tags of the Slot component.
It allows developers to include static content directly within the slot, which will be rendered as part of the slot's contents.
This property is useful for cases where the content within the slot is static or does not need to be dynamically generated by the slot.

```tsx
// MyContainer.tsx (Drop-in)


export interface MyContainerProps extends HTMLAttributes<HTMLDivElement> {
  slots?: {
    MyOpenSlot?: SlotProps<{
      // MyOpenSlot Context
      data: MyContainerData;
    }>;
  };
}

export const MyContainer: Container<MyContainerProps> = ({
  slots,
  children,
  ...props
}) => {
  // ...

  return (
    
      
    
  );
};
```

&nbsp;

```js
// blocks/my-block.js (storefront)

provider.render(MyContainer, {
  slots: {
    MyOpenSlot: async (ctx) => {
      // create a new HTML element
      const element = document.createElement('div');
      // set the innerHTML of the new element to the text from the context's data
      element.innerHTML = ctx.data.text;

      // append the new element to the slot's content
      ctx.appendChild(element);

      // ...or you could also use any of the other slot methods to manipulate the slot's content
      // ctx.replaceWith(element);
      // ctx.prependChild(element);
      // ctx.appendSibling(element);
      // ctx.prependSibling(element);

      // to listen and react to changes in the slot's context (lifecycle)
      ctx.onChange((next) => {
        // update the innerHTML of the new element to the new text from the context's data
        element.innerHTML = ctx.data.text;
      });
    },
  },
});
```

## Privates

The `` component has a private interface that serves as a mechanism for managing internal
complexity and promoting clean, modular design within the Slot component or related components.

### \_registerMethod

The `_registerMethod` private function is used to register a method in the slot's context which is particularly helpful in scenarios
where dynamic behavior or interactions need to be incorporated into the Slot component.

Slot Methods also include the ability to modify the slot's state or content based on external interactions or changes in application state.

### \_setProps

The `_setProps` private function within the Slot component is responsible for dynamically updating the properties of the slot.
It allows developers to modify the slot's state or content based on external interactions or changes in application state,
triggering re-renders of the slot component with updated properties.

### \_htmlElementToVNode

The `_htmlElementToVNode` private function in the Slot component converts HTML elements into virtual DOM nodes (VNodes),
enabling their integration into Preact components. This conversion facilitates the dynamic insertion of HTML content
into slots while benefiting from Preact's virtual DOM reconciliation and rendering.

```tsx
// MyContainer.tsx (Drop-in)

<Slot
  name="MyOpenSlot"
  slot={slots?.MyOpenSlot}
  context={{
    // custom slot method
    appendButton(callback) {
      // use _registerMethod to register a method in the slot's context
      this._registerMethod((...attrs) => {
        // callback return the values provided by the storefront developer
        const { text, ...buttonProps } = callback(...attrs);

        const button = (
          
            {text}
          
        );

        // use _setProps to update the slot's properties
        this._setProps((prev: any) => ({
          children: [...(prev.children || []), button],
        }));
      });
    },
  }}
  render={(props) => {
    // render the slot's content using props mutated by the slot's methods
    return {props.children};
  }}
/>
```

&nbsp;

```js
// blocks/my-block.js (storefront)

provider.render(MyContainer, {
  slots: {
    // Available Slots
    MyOpenSlot: (ctx) => {
      ctx.appendButton: (next, state) => {
        // use state to get the current state of the slot
        const loading = state.get('loading');

        return {
          text: loading ? 'Loading' : 'Click me!',
          onClick: async () => {
            // use state to update the state of the slot
            state.set('loading', true);

            await doSomething().finally(() => {
              state.set('loading', false);
            });
          },
        };
      },
    },
  },
});
```

---

# VComponent

In modern Preact-based architectures, composability and flexibility are essential for building reusable UI components. `VComponent` is a utility provided by the SDK that enables rendering of virtual nodes (`VNode`) passed as propsâ€”empowering consumers to inject arbitrary content while maintaining a clean separation of concerns.

## Why use VComponent?

By default, Preact allows children to be passed as virtual nodes, enabling dynamic rendering:

```tsx

  <h1>Hello</h1>

```
However, flexibility increases when we extend this pattern to named props like `header`, `footer`, or `image`. Instead of hardcoding internal markup, we delegate the responsibility of rendering to the consumer.

## Traditional approach (tightly coupled)

The standard approach to rendering a component is to pass values as props directly to the component.

**Implementation:**

```tsx
const Card = ({ imageProps }) => {
  return ;
};
```

**Usage:**
```tsx

```

This implementation tightly couples the component to a specific HTML element (`<img>`), which limits its flexibility and reuse.

## Composable approach with VComponent

The composable approach with `VComponent` allows consumers to pass arbitrary DOM nodes through props.

**Implementation:**

```tsx

interface Props {
  image: VNode;
}

const Card = ({ image }: Props) => {
  return ;
};
```

**Usage:**

```tsx
} />
// or with a custom slot/component
} />
```

This decouples the component from a specific element. Instead, it renders whatever VNode is passed in. Consumers now have full control over what gets displayed.

## How it works

`VComponent` is a thin wrapper around a virtual node (`VNode`). It renders the node it receives as-is, while optionally applying extra props like `className`.

This makes it ideal for rendering content passed through slots or injected from a higher-order component.

```tsx

```

## When to use it

Use `VComponent` when:

- You want to allow injected custom DOM nodes (icons, slots, rich content)
- You're designing reusable components meant to be extended or implemented by different consumers (Containers, Slots, etc.)

## Benefits

- Promotes reusability and composability
- Supports custom rendering logic with no assumptions
- Reduces internal complexity by offloading rendering decisions
- Ideal for BYO-UI and dynamic layout strategies

---

# classList

This function takes in an array of classes and returns a string of space separated entries that can be used for CSS classname assignments.

## Params

`classList`
: An array containing strings or `<string,boolean>` arrays

## Returns

Returns a string of space separated entries that can be used for CSS classname assignments.

## Examples

```ts

type ClassList = Array<string | [string, boolean] | undefined>;

const classList: ClassList = ['class-1', 'class-2', 'class-3'];

const result = classes(classList);

console.log(result); // "class-1 class-2 class-3"
```

You can use a `<string,boolean>` array to control whether a class should be included or omitted from the final classes list.

```ts

type ClassList = Array<string | [string, boolean] | undefined>;

const classList: ClassList = [
  'class-1',
  ['class-2', true],
  ['class-3', false],
  'class-4',
];

const result = classes(classList);

console.log(result); // "class-1 class-2 class-4"
```

---

# debounce

This function provides a way to delay callback execution or prevent overcalling a function until certain conditions are met.

## Params

`fn`
: The callback function to be executed

`ms`
: Time(in milliseconds) to delay callback execution

## Returns

A debounce version of the original callback function.
This function can be treated like the original callback, except when called, the delay timer resets.

## Examples

```ts

const debouncedLog = debounce(console.log, 500);

debouncedLog('Do not log this string');

// Wait 250ms

debouncedLog('Do not log this string'); // Resets delay timer

// Wait 250ms

debouncedLog('Do not log this string'); // Resets delay timer

// Wait 250ms

debouncedLog('Log this string'); // Resets delay timer

// Wait 500ms

// 'Log this string' is logged to the console and no other messages have been logged
```

---

# deepmerge

Merges the enumerable properties of two or more objects deeply.

See: https://www.npmjs.com/package/deepmerge

---

# getCookie

Takes in a cookie name and returns the value of the cookie.

## Params

Signature: `getCookie(cookieName)`

`cookieName`
: The name of the cookie to get

## Returns

Returns the value of the cookie.

## Examples

```ts

const result = getCookie('foo');

console.log(result); // "bar"
```

---

# getFormErrors

Returns every form error in an HTML form element.

## Params

`form`
: An HTMLFormElement

## Returns

A JavaScript object containing the form errors

## Examples

```html

  
  
  
  
  

```

```ts

const formElement = container.querySelector('form') as HTMLFormElement;

const errors = getFormErrors(formElement);

console.log(errors); // { bar: 'Constraints not satisfied', website: 'Constraints not satisfied', 'e-mail': 'Constraints not satisfied', }
```

---

# getFormValues

Transforms the data in an HTML form element into a JavaScript object.

## Params

`form`
: An HTMLFormElement

## Returns

A JavaScript object containing the form data

## Examples

```html

  
  

```

```ts

const formElement = container.querySelector('form') as HTMLFormElement;

const values = getFormValues(formElement);

console.log(values); // { bar: 'Bar', foo: 'Foo' }
```

---

# getPathValue

Takes in an object and a key and returns the value of the key.

## Params

Signature: `getPathValue(obj, key)`

`obj`
: The object to get the value from

`key`
: The key to get the value from (supports dot notation)

## Returns

Returns the value of the key.

## Examples

```ts

const obj = {
  foo: {
    bar: 'baz',
  },
};

const result = getPathValue(obj, 'foo.bar');

console.log(result); // "baz"
```

---

# Overview

The utilities section provides a collection of helper functions to simplify common programming tasks when working with the SDK. These utilities handle everything from DOM manipulation and event handling to data transformation and form management. Each utility is designed to be lightweight, performant, and easy to integrate into your codebase.

## Topics

- [classList](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/utilities/classlist/) - Helper for managing CSS class names
- [debounce](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/utilities/debounce/) - Limit how often a function can be called
- [deepmerge](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/utilities/deepmerge/) - Deeply merge multiple objects
- [getCookie](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/utilities/getcookie/) - Get cookie value from name
- [getFormErrors](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/utilities/getformerrors/) - Get form validation errors
- [getFormValues](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/utilities/getformvalues/) - Get form field values
- [getPathValue](https://experienceleague.adobe.com/developer/commerce/storefront/sdk/utilities/getpathvalue/) - Get value from obj key

By leveraging these utility functions, you can streamline your development workflow and reduce boilerplate code while maintaining clean, maintainable implementations. These utilities are designed to work seamlessly with the SDK's components and core functionality, helping you build robust applications more efficiently. Each utility is thoroughly tested and optimized for performance, making them reliable tools for your development needs.

---

# Enrichment

This topic introduces you to the concept of enriching product pages in your storefront. You will learn how to add content blocks above or below a commerce block (or any other block).

> **Note:** **Critical Setup Required**: Before using enrichment functionality, you must configure your `query.yaml` file to automatically generate the `enrichment.json` file. This is the most common cause of enrichment failures.

**Common mistake**: Users often manually create the `enrichment.json` file when they see it's missing, but this approach will not work reliably. The file must be generated automatically by the `query.yaml` configuration.

## Key concepts



### Enrichment

Enrichment means to add content that strengthens the user experience of the drop-in on the webpage. When viewing a product's details (via the product-details drop-in), the user experiences all the core features of the drop-in. However, all the other extra content on the page, like product recommendations, must be added in one of the ways described in this topic.

### Content blocks

Content blocks are tables in a document that contain text, images, or other media. They are used to structure and organize content on a webpage. See  for more information.

### Commerce blocks

Commerce blocks are Edge Delivery Service blocks that contain drop-in components. Commerce blocks are used to add drop-in components like the product-details block that features a specific product.


### Enrichment blocks

Enrichment blocks are specialized content blocks to dynamically display content above or below commerce blocks based on various conditions, including but not limited to product SKUs and category numbers.

### Content positioning

Content positioning is the placement of content and enrichment blocks on a webpage. It includes the arrangement of content blocks above or below a commerce blocks. Positioning content inside a drop-in component is also possible using the slot API functions. The webpage structure is within a Word or Google docs file. This file includes tables that define content blocks, commerce blocks, and other HTML elements.



## Prerequisites

Before you can use enrichment functionality, you must complete the following setup steps:



<Task>
### Configure query.yaml to generate enrichment.json

The `enrichment.json` file is automatically generated by the system when you configure your `query.yaml` file properly. You do not need to manually create this file.

Configure your `helix-query.yaml` or the `query.yaml` pushed to your Helix site config to include the enrichment index configuration.

<Code code={`version: 1
indices:
  enrichment:
    target: /enrichment/enrichment.json
    include:
      - '**/enrichment/**'
    properties:
      title:
        select: head > meta[property="og:title"]
        value: |
          attribute(el, 'content')
      products:
        select: head > meta[name="enrichment-products"]
        values: |
          match(attribute(el, 'content'), '([^,]+)')
      categories:
        select: head > meta[name="enrichment-categories"]
        values: |
          match(attribute(el, 'content'), '([^,]+)')
      positions:
        select: head > meta[name="enrichment-positions"]
        values: |
          match(attribute(el, 'content'), '([^,]+)')`} lang="yaml" title="query.yaml enrichment index configuration" />

</Task>

<Task>
### Choose the correct location for your query.yaml

You have two options for where to place your `query.yaml` configuration:

**Option 1: Site-specific configuration (Recommended for Helix 5)**
- Configure at: `https://admin.hlx.page/config/[ORG]/sites/[SITE]/content/query.yaml`
- This is the recommended approach for new Helix 5 projects
- Each site has its own independent configuration to prevent conflicts between different sites

**Option 2: GitHub-based configuration**
- Place as `helix-query.yaml` in your GitHub repository
- This configuration will be shared among all sites using the same code reference
- Suitable for multi-site deployments with shared configuration

<Aside type="tip">
For the complete `query.yaml` configuration including all required indices, refer to the [AEM boilerplate repository](https://github.com/hlxsites/aem-boilerplate-commerce/blob/main/default-query.yaml).
</Aside>

</Task>

<Task>
### Verify enrichment setup

After completing the above steps, verify that your enrichment setup is working by:

1. **Test enrichment functionality**: Create enrichment content and test it on a product page
2. **Check browser console**: Look for any JavaScript errors that might prevent enrichment from loading

<Aside type="tip">
The `/enrichment/enrichment.json` file is automatically generated by the system based on your query.yaml configuration.
</Aside>

</Task>



## Enrichment metadata structure

The enrichment system uses specific metadata tags in your enrichment content documents to determine when and where content should appear. Based on the `query.yaml` configuration, the following metadata properties are supported:



### Example enrichment content metadata

When creating enrichment content, add these metadata tags to the document's frontmatter:

```yaml
---
title: "Special Watch Promotion"
enrichment-products: "WATCH-001, WATCH-002"
enrichment-categories: "watches, accessories"
enrichment-positions: "below"
---
```

> **Note:** The enrichment system will automatically match your content to products and categories based on these metadata values. Multiple values can be specified using comma-separated lists.

## Add content blocks

The following steps show you how to enrich a commerce block by placing content blocks above or below it. The following example shows the default product-details document with a simple product recommendation block below it.


  ![Add enrichment blocks](@images/AddContent.png/)




<Task>
### Open a commerce block document

Open the document that contains the commerce block you want to enrich. In the boilerplate starter content, open the `products/default` to see an example of a product recommendation block below the product details block.

</Task>

<Task>
### Add normal content or content blocks

Add a normal headings, text, images or content blocks above or below the commerce block in the document. You can copy content blocks (tables) from the [AEM Sidekick Library](https://sidekick-library--aem-block-collection--adobe.aem.page/tools/sidekick/library.html?plugin=blocks&path=/block-collection/) and paste them into the document.

</Task>

<Task>
### Preview and publish changes

Use AEM Sidekick to preview and publish the changes to see the content above or below the commerce block.

</Task>



## Add enrichment blocks

Enrichment blocks are used to add content above or below commerce blocks based on product and category numbers. The following steps show you how to enrich a commerce block by placing an enrichment block above or below it.


  ![Add enrichment blocks](@images/AddEnrichmentBlock.png/)




<Task>
### Create enrichment content

In your content folder, add a new document to the `enrichment` folder. You can duplicate the `product-banner` document and rename it. Then add the content you want to display below the commerce block.

</Task>

<Task>
### Change the metadata values

Change the metadata values for the enrichment content to match the product SKUs or product categories for which you want your content to appear.

</Task>

<Task>
### Preview and publish changes

Use AEM Sidekick to preview and publish the changes to see the content above or below the commerce block.

</Task>



## Troubleshooting

If enrichment functionality is not working as expected, follow these troubleshooting steps:

### Common issues and solutions



**Enrichments not appearing on product pages**

- **Check browser console**: Look for JavaScript errors that might prevent enrichment from loading
- **Verify `query.yaml` configuration**: Ensure the enrichment target is properly configured in your `query.yaml` file
- **Check content structure**: Ensure enrichment content follows the correct document structure
- **Content not published**: Verify that enrichment content documents are properly published

**Enrichment content not displaying**

- **Metadata mismatch**: Ensure the `enrichment-products` and `enrichment-categories` metadata values match your actual product SKUs and category IDs
- **Missing metadata**: Verify that enrichment content documents include the required metadata tags (`enrichment-products`, `enrichment-categories`, `enrichment-positions`)
- **Content not published**: Use AEM Sidekick to preview and publish enrichment content
- **Document structure**: Verify that enrichment content follows the correct table structure
- **Query.yaml configuration**: Ensure the enrichment index is properly configured with the correct `include` pattern (`'**/enrichment/**'`)



### Debugging steps

1. **Check browser console**: Open developer tools and look for JavaScript errors
2. **Verify query.yaml configuration**: Check your site's query.yaml configuration at `https://admin.hlx.page/config/[your-site]/content/query.yaml`
3. **Confirm enrichment target**: Ensure the enrichment target is properly configured (lines 34-54 in the boilerplate example)
4. **Test with boilerplate**: Compare your setup with the [AEM boilerplate repository](https://github.com/hlxsites/aem-boilerplate-commerce)

### Getting help

If you continue to experience issues:

1. Check the [AEM boilerplate repository](https://github.com/hlxsites/aem-boilerplate-commerce) for reference implementations
2. Review the [default-query.yaml](https://github.com/hlxsites/aem-boilerplate-commerce/blob/main/default-query.yaml) configuration
3. Contact Adobe Commerce support with specific error messages from your browser console

## Summary

In this topic, you learned how to enrich drop-in components by adding Edge Delivery Services content and enrichment blocks above and below commerce blocks (powered by drop-in components). You also learned about the prerequisite setup steps and troubleshooting common issues.

---

# Experimenting with drop-in components

This topic introduces you to the concept of creating A/B experiments for drop-in components. You will learn how to create experiments, define variants, and track the performance of each variant.

## Vocabulary



### A/B experiment

A test that compares two or more pages to determine which page performs better.

### Variant

A version of a page that is different from the original version. Variants are created to test different features, designs, or content.

### UI label changes

Changes to the text or labels displayed on a page.

### Control

The original version of the drop-in component that is used as a baseline for comparison.

### Challenger

The variant of the drop-in component being tested.

### Experimentation Plugin

The Experimentation Plugin is **not pre-installed** in the Commerce Boilerplate ([hlxsites/aem-boilerplate-commerce](https://github.com/hlxsites/aem-boilerplate-commerce)). Instead, developers can optionally install it based on their experimentation needs.

To install and configure the plugin, follow the instructions in the [AEM Experimentation GitHub repository](https://github.com/adobe/aem-experimentation/).

### Placeholders file

A `placeholders` sheet in your content folder where you change and maintain your storefront's labels, which includes localization. See the [Placeholders file](https://experienceleague.adobe.com/developer/commerce/storefront/resources/placeholders/) for more information.



## About storefront A/B experiments

The Experimentation plugin provides all the features for running A/B experiments on your storefront pages. You can track conversions and experiment with different page variations quickly, using real user metrics.

The features include setting up A/B tests, serving different content to multiple audiences, and integrating marketing campaigns without collecting personal user data. Metadata markers and rules define which versions of a page visitors see. By default, tests do not require user consent and don't require cookies.

Additionally, the plugin allows A/B experiments that can be run on mobile or desktop users and success can be tracked for each variant. You can also customize sample rates, data storage, and environment detection to suit your project. And with marketing campaigns, you can tailor experiences so visitors from a particular email or social link see unique content.

This plugin integrates seamlessly with the AEM boilerplate code, allowing experiments to be loaded early and with minimal impact.

For detailed development information, see https://github.com/adobe/aem-experimentation.

## Step-by-step

Creating an A/B experiment for a Commerce storefront page includes the following tasks:


1. Create a variant page for the experiment.
1. Add the experiment to the metadata block of the original page.
1. Preview the experiment using the AEM Sidekick extension.



<Task>
### Create a variant page for the experiment

Duplicate the original page and make the changes you need to create a new page with the new content or features you want to use in the experiment. For most content changes, you can add those changes directly to the page/document. Examples include adding any of the [AEM content blocks](https://www.aem.live/developer/block-collection#boilerplate), additional commerce blocks (such as product recommendations) and more.

</Task>

<Task>
### Add the experiment to the original page

Add the experiment to the metadata block of the original page by adding the experiment name and the URL to the experiment pages. The following example shows how to add an experiment to the cart drop-in block using the `metadata` block on the cart page. The keys are:

- **Experiment**: The name of the experiment. The Experimentation plugin uses this name to track this experiment.
- **Experiment Variants**: The URLs to the variant/challenger pages in the experiment. The Experimentation plugin uses these URLs to set up the experiment.

<Diagram caption="Add experiment to metadata block">![Add experiment to metadata block](@images/MetadataExperiment.png/)</Diagram>

</Task>

<Task>
### Preview the experiment

Use the AEM Sidekick Preview button to preview the experiment and compare the original page with the variant page. Make sure that the changes are displayed correctly and that the experiment is functioning as expected. You can also share the experiment URL with stakeholders for feedback before launching it to a wider audience.

<Diagram caption="Preview the experiment">![Preview the experiment](@images/ExperimentOne.png/)</Diagram>

</Task>



---

## Experimenting with UI label changes

You can use the Experimentation plugin to test different UI label variations in your storefront. This allows you to experiment with the labels used by drop-in components to determine which versions perform best.

You can include labels in your experiment by creating a variant placeholder file, then referencing the variant placeholder in the metadata on the variant page. Any overlapping keys in the variant placeholders file will override the existing placeholders, making it ideal for experiments with different label variations. Using the Experimentation plugin, you can track the performance of each variant to identify which labels and texts are most effective.

## Step-by-step

Following the steps above, create a new experiment. Adding UI label changes to your experiment includes the following tasks:


1. Create a variant placeholders file.
1. Add the path to the variant placeholders JSON file in the metadata block of the variant page.
1. Preview the experiment using the AEM Sidekick extension.




<Task>
### Create a variant placeholders file
- Create a new variant placeholders JSON file that only contains the labels you wish to override. When this file is loaded on the storefront, any overlapping keys will replace the original placeholder keys. The variant placeholders file should include the following structure:
- **Key**: The key for the label you want to override. This key should match the key used in the original placeholders file.
- **Value**: The new value for the label you want to override. This value should be the new label text you want to use in the experiment.

<Diagram caption="Add new label values">![Add new label values](@images/PlaceholderOverrides.png/)</Diagram>
</Task>

<Task>
### Add the path to the variant placeholders JSON file in the metadata block of the variant page
Update the metadata block of the variant page by adding the URL to the variant placeholders file. The following example shows how to override labels in the cart drop-in component by updating the metadata block of a variant cart page. The key is:

- **Placeholders**: The path to the variant placeholders JSON file. This file will load on the page and any overlapping keys will override the existing placeholders. The Experimentation plugin uses this URL to configure the experiment.

<Diagram caption="Add new placeholders overrides">![Add new placeholders overrides](@images/PlaceholderExperiment.png/)</Diagram>
</Task>

<Task>
### Preview the experiment

Use the AEM Sidekick Preview button to preview the experiment and compare the original page with the variant page. Make sure that the changes are displayed correctly and that the experiment is functioning as expected. You can also share the experiment URL with stakeholders for feedback before launching it to a wider audience.

<Diagram caption="Preview the experiment">![Preview the experiment](@images/PlaceholderPreviewExperiment.png/)</Diagram>

</Task>


## Next steps

Now that you understand how to create A/B experiments for drop-in components, you can start experimenting with different variants to optimize the performance of your storefront.

---

# Overview

This section is designed to help you enrich, experiment, and manage your storefront effectively. Whether you're new to the platform or looking to optimize your store, the resources you need as a merchant will be added here, starting with the following topics.

---

# Personalization

This topic describes how to use Targeted Blocks to deliver personalized experiences.

## Vocabulary



### Targeted Block

A block that wraps the content targeted for specific customer groups, segments, or cart rules.

### Group

([Adobe Commerce Customer Group](https://experienceleague.adobe.com/en/docs/commerce-admin/customers/customer-groups)) assigned to the customer.

### Segment

([Adobe Commerce Customer Segment](https://experienceleague.adobe.com/en/docs/commerce-admin/customers/segments/customer-segments)) that applies to the customer.

### Cart Rule

([Adobe Commerce Cart Price Rule](https://experienceleague.adobe.com/en/docs/commerce-admin/marketing/promotions/cart-rules/price-rules-cart)) that applies to the customer cart.



## About Targeted Blocks

You can add Targeted Blocks to a Commerce storefront page. They accept the following parameters:



If the fragment is not used for a Targeted Block, the last merged row of the block configuration must contain the content.

## Specific customer segments

Specify the comma-separated list of customer segment IDs from Adobe Commerce to ensure that the block displays for customers matching these segments only.

The content of the Targeted Block in the following example will be displayed to the customers of the 1st and 2nd segments only:

![Targeted Block for specific customer segments](@images/dropins/personalization/targeted-block.png/)

## Load interactive content from a fragment

Instead of embedding content directly in the Targeted Block, you can specify a path to a fragment. When you use a fragment, the system loads the content from the specified document path and displays it as the Targeted Block content.

The content of the Targeted Block in the following example will be loaded from a document following the path specified in the fragment property:

![Targeted Block loading interactive content from a fragment](@images/dropins/personalization/targeted-block-fragment.png/)

## Fallback using block type

When multiple Targeted Blocks on a page share the same type, only the first matching Targeted Block displays to the customer. This fallback behavior enables you to configure a Targeted Block with default content that is visible to everyone, which specific blocks for particular groups or segments can then replace.

In this example, the first Targeted Block displays only to customers whose shopping cart meets the conditions of cart price rule ID 5. The second Targeted Block has no conditions and should display to all customers. However, because both blocks share the same "Type" value, the second block will not display when the first block is active. Blocks with the same type replace each other in the display hierarchy:

![Targeted Block fallback using block type](@images/dropins/personalization/targeted-block-type.png/)

## Next steps

Now that you understand how to create Targeted Blocks, you can start experimenting with personalized content for your customers.

---

# Product Recommendations setup

You must enable and configure the Product Recommendations feature before it becomes available on any page of your website.

Once configured, Product Recommendations will display on your page within the [`ProductList`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/recommendations/containers/product-list/) container as a specific recommendation unit.

## Enable and configure Product Recommendations

The `ProductList` container can be configured on each page through Document Authoring. Follow the step-by-step guide below to enable and configure Product Recommendations:



<Task>

### Create a recommendation unit

You must first create recommendation units in the Adobe Commerce Admin (PaaS) or Adobe Commerce Optimizer Admin (SaaS).

#### Adobe Commerce Optimizer Admin (SaaS)

The following steps apply to merchants using Adobe Commerce Optimizer or Adobe Commerce as a Cloud Service.

  <Steps>

    1. Log in to the Adobe Commerce Optimizer Admin.
    
    1. On the Admin sidebar, go to **Recommendations**.

    1. Follow the steps in the [user guide](https://experienceleague.adobe.com/en/docs/commerce/optimizer/merchandising/recommendations/create) to create a recommendation unit.

  </Steps>

   :::note
   For Adobe Commerce Admin (PaaS), follow the steps in the [user guide](https://experienceleague.adobe.com/en/docs/commerce/product-recommendations/admin/create) to create a recommendation unit.

   :::
   
   </Task>
   <Task>

### Get the recommendations unit ID

You can specify which recommendation unit to display on each page by using the recommendation unit ID.

<Steps>

1. Navigate to the Product Recommendations page in the Adobe Commerce Admin or Adobe Commerce Optimizer Admin.

1. Click the eye icon next to the recommendation unit that you'd like to display on your store.

1. Copy the **Recommendation ID** from the modal.

</Steps>

You will use this ID in the next step to configure the recommendations block.

</Task>

<Task>

### Add and configure the recommendations block

You can configure each page to display a specific recommendation unit by setting its recommendation ID.

<Steps>

1. Open the page where you want to display the recommendation unit.

1. Create a new table in your document. 

   For product detail pages, set the `recId` to match the recommendation unit ID in the previous step. For example:

   <Diagram caption="Add Product Recommendations block to the page">
   ![Add Product Recommendations block to the page](@images/PrexBlockPDP.png/)
   </Diagram>

   :::note
   PDP pages require only the `recId` to be set.

   Other pages require both the `recId` and `currentSku` to be set. For example:

   <Diagram caption="Add Product Recommendations block to the page">
   ![Add Product Recommendations block to the page](@images/PrexBlockNonPDP.png/)
   </Diagram>

   :::

</Steps>

</Task>

---

# Terms & Conditions setup

The Terms & Conditions feature must be enabled and configured to be available during the checkout process before placing an order.
The configured terms and conditions will appear in the Checkout component within the [TermsAndConditions container](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/terms-and-conditions/) as specific checkboxes. Each checkbox will display a label with text and links, directing users to the corresponding agreement pages configured at store-view level.

> **Note:** Merchants can add as many agreements as they want for a specific store-view; this allows to provide different documents for each language and other needs.

  Visit the [Multi-store setup](https://experienceleague.adobe.com/developer/commerce/storefront/merchants/multistore/) documentation for more information on how to build blocks and configure the storefront structure based on **Edge Delivery Services (EDS)**.

## How to enable and configure the Terms and Conditions

This checkout component is configurable on a per store-view basis on EDS, but a merchant can also rely on the Admin Panel's configuration. Follow the next step-by-step guide to enable and configure the Terms and Conditions:



<Task>

### Enable the component

The merchant has to enable the component in the Admin Panel as following:

<Steps>

1. Log in to the Admin Panel.

1. On the Admin sidebar, go to **Stores** > _Settings_ > **Configuration**.

1. In the left panel, expand **Sales** and choose **Checkout**.

1. Expand the **Checkout Options** section.

1. Set **Enable Terms and Conditions** to "Yes".

1. Click **Save Config**.

</Steps>

See [Terms and conditions for checkout](https://experienceleague.adobe.com/en/docs/commerce-admin/stores-sales/point-of-purchase/checkout/terms-and-conditions) documentation for more information on how to enable the terms and conditions using the Admin Panel.

</Task>

<Task>

### Create the agreement document

The agreements pages will be created **ONLY** using _document-based authoring (DBA)_ within EDS instead of using the Admin Panel, allowing the merchant to create and manage as many agreements pages and content as required for each store-view and language.

</Task>

<Task>

### Configure the agreement checkbox label

Use the **EDS placeholders** or the **Admin Panel** instructions in the following tabs to configure the agreement checkbox label.

<Tabs>
  <TabItem label="Using EDS placeholders" default>
    For each agreement, the merchant has to update the **`placeholders`** sheet with the following information:

    - An **_identifier_**:
      It's the reference that identifies the label translated
    - A **_label_**:
      It's the text to display next to the checkbox, and will be directly retrieved from the Boilerplate translations for a specific store-view and language. This data accepts HTML with links to a specific page in EDS

    Similarly, the merchant can configure the translation for the validation error that appears when the user clicks the `Place Order` button and an agreement is not checked, using the **"Checkout.TermsAndConditions.error"** identifier.

    Sample of **placeholders** sheet:
    ```txt
    "Checkout.TermsAndConditions.label", "I have read, understand, and accept the <a href='/en/privacy-policy' target='_blank'>Terms of Use, Terms of Sales, Privacy Policy, and Return Policy</a>."
    "Checkout.TermsAndConditions.terms_label", "By placing an order, you are agreeing to be bound by our <a href="/en/terms-and-conditions" target="_blank">Terms And Conditions</a>."
    "Checkout.TermsAndConditions.privacy_label", "By placing an order, you acknowledge our <a href="/en/privacy-policy" target="_blank">Privacy Policy</a>."
    "Checkout.TermsAndConditions.error", "Please accept the Terms and Conditions to continue."
    ```

    These labels will be used in order to render the `TermsAndConditions` container inside of the **commerce-checkout.js** block file.

    Visit the [TermsAndConditions container](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/terms-and-conditions/) documentation to see examples on how to use these labels.
  </TabItem>
  <TabItem label="Using the Admin Panel">
  The merchant has to configure the checkbox label for each agreement using the Admin Panel. As mentioned before, the Admin Panel allows to create configurations per store-view level as following:

  1. Log in to the Admin Panel.

  1. On the Admin sidebar, go to **Stores** > _Settings_ > **Terms and Conditions**.

  1. In the upper-right corner, click **Add New Condition** button.

  1. Enter the next **Terms and Conditions information**:
      - **`Condition Name`**
        The agreement identifier
      - **`Status`**
        Attribute to indicate if it's available or not:
        - 'Enabled'; the agreement will be retrieved by the GraphQL API query
        - 'Disabled'; the agreement won't be retrieved by the GraphQL API query
      - **`Applied`**
        Specifies the mode how the checkbox should appear:
        - 'Manually': the user is required to manually check and accept the conditions to place an order
        - 'Automatically': the checkbox will appear checked by default, conditions are automatically accepted upon checkout
      - **`Store View`**
        Defines the scope at store view level for this agreement where you want these Terms and Conditions to be used
      - **`Checkbox Text`**
        It contains directly the text to show; it accepts HTML with links to a specific page in EDS

      <Aside type="note" title="Some attributes are not used">
        Although the following attributes are provided by the Admin Panel, they are not going to be utilized in the current solution because they will be handled in EDS. Merchants are able to work on their own solution if they want to use them:
        - **`Content`**
          As described above, the content for the agreements pages will be created **ONLY** using EDS
        - **`Show Content as`** (Text, HTML)
          Not really needed because EDS pages accepts HTML code
        - **`Content Height (css)`**
      </Aside>

  1. Click **Save Condition**.

      These entries will be used in order to render the `TermsAndConditions` container inside of the **commerce-checkout.js** block file.

    Visit the [TermsAndConditions container](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/terms-and-conditions/) documentation to see examples of this feature.

    See the [Terms and conditions for checkout](https://experienceleague.adobe.com/en/docs/commerce-admin/stores-sales/point-of-purchase/checkout/terms-and-conditions) documentation to learn how to configure the terms and conditions using the Admin Panel.
  </TabItem>
</Tabs>

:::note
Because the agreements pages will be created using DBA within EDS, the agreements checkbox label should provide links to the relevant agreements pages for each store-view.
:::

</Task>

---

# Localization

This guide will walk you through the process of localizing the content of your storefront using Document Authoring (da.live).

## Prerequisites

- You have a storefront project in the Document Authoring app () of the Commerce Storefront powered by Edge Delivery.
- You know the basics of using the Document Authoring tool as described in the documentation here: ().

:::note
To achieve full localizationâ€”including storefront setup (currency, translations, localized storefront links) and enabling the store switcherâ€”the developers for your storefront site need to follow the steps outlined in [multistore setup](https://experienceleague.adobe.com/developer/commerce/storefront/merchants/multistore/).
:::

## Additional resources

- 
- 

## Big picture

The following diagram provides the basic workflow for translating the Edge Delivery content of your storefront into multiple languages using the Document Authoring apps .


  ![Workflow for localizing your storefront](https://experienceleague.adobe.com/developer/commerce/storefront/images/localization-steps.png/)


## Step-by-step

These steps provide the details for the translation workflow shown in the diagram. The steps describe how to translate the default English store to another language. In this example, we will translate the default English store to French (`fr`).



<Task>
### Navigate to your storefront's apps page

<Steps>
1. Open your storefront project in the Document Authoring tool ().
1. Select Apps from the left sidebar.

</Steps>

</Task>

<Task>
### Use the Traverse app to get a list of site URLs

<Steps>
1. Open the **Traverse** app by selecting its *Go* button.
1. On the Crawl Tree page, enter your storefront's organization name and site name. Example: `/acme/storefront`. Ensure that you enter a forward slash (`/`) at the beginning of the string or it will not work. 
1. Select the **Crawl** button to start the crawl.
1. Select the **Copy list** button after the site's URLs have been traversed. This puts all the URLs in your clipboard.
1. Return to the Apps page.

</Steps>

</Task>

<Task>

### Use the Translation app to translate your storefront

<Steps>
1. Open the **Translate** app by selecting its *Go* button.
1. On the Localization page, enter the Title of the translation project: `acme-storefront-fr`.
1. Paste the list of URLs from the **Traverse** app into the **URLs** field.
   :::note
   We recommend excluding certain filesâ€”such as `metadata.json`, `redirects.json`, and `sitemap.json`â€”from the translation process. Adding these files to the translation process shouldn't cause any technical issues with translation, but translating them is not necessary.
   :::
1. Select the **Next** button.
1. View the validated URLs to ensure that they are all correct.
1. Select the **Next** button.
1. Select one or more languages you want to translate to. In this example, we will translate to French (`fr`).
1. For the French language, select **Translate** from the selector, then select the **Create project** button.
1. From the project page, select the **Send all for translation** button.

</Steps>

<Aside type="note">

By default, the Translation app will use the Google Translate service to translate the content of the storefront into the selected language. Your organization can also connect other translation services for a more robust translation experience. For more information on translation services and configuration, see [Translation and Localization](https://www.aem.live/docs/translation-and-localization).

</Aside>

</Task>

<Task>

### View the translated site

<Steps>
1. Navigate back to the main (root) folder for you English storefront.
1. Scroll the site files and folders to find the `fr` folder and open it.
1. Select a document to view the translated content. For example, select the `index` document to view the translated home page.
</Steps>

</Task>

---

# Multistore setup

## What is multistore?

**Multistore** refers to the ability to run multiple storefronts from a single codebase and content repository. This is useful for:

- **Localization**: Serving different languages and currencies (e.g., English/US, French/Canada) from the same site, with localized content and commerce data.
- **Multiple Brands or Regions**: Operating several brands or regional storefronts, each with their own configuration, but sharing core code and content.

There are two main approaches to multistore:

1. **Multiple Domains**: Each domain points to a different commerce backend or configuration, but shares the same code and content.
2. **Subfolders (Root Folders)**: A single domain with subfolders (e.g., `/en/`, `/fr/`) for each locale or store. Each subfolder can have its own localized content and commerce configuration.

**Key features:**
- **Editorial and Commerce Localization**: Editorial content (pages, blocks) and commerce data (products, prices, currencies) are both localized.
- **Automated Translation Tools**: Tools are provided to automate translation of content and manage updates across languages.
- **Configurable Headers**: Storefronts can send different headers to the commerce backend to select the correct store, language, and currency.

---

## How does multistore configuration work?

- **Config Files**: Each store or locale is defined in configuration files, specifying which headers to send to the commerce backend, which content folders to use, etc.
- **Store Switcher**: Out-of-the-box, a store switcher UI is provided so users can switch between stores/locales on the frontend.
- **Automatic Link Management**: Links are automatically updated to point to the correct localized version as users navigate the site.

---

Adobe Commerce uses a [hierarchical structure](https://experienceleague.adobe.com/en/docs/commerce-admin/start/setup/websites-stores-views) to manage multiple stores within a single instance. This structure consists of three levels: websites, stores, and store views. Localization is managed at the store view level, allowing merchants to present the store in different languages and apply the proper currency.

To maintain storefronts that implement Edge Delivery Services, you must be familiar with its building blocks. The following topics describe the EDS features.

* [Authoring and Publishing Content](https://experienceleague.adobe.com/en/docs/experience-manager-cloud-service/content/edge-delivery/document-authoring/authoring)
* [Placeholders files](https://experienceleague.adobe.com/developer/commerce/storefront/resources/placeholders/)
* [Adobe Commerce Configuration Scope](https://experienceleague.adobe.com/en/docs/commerce-admin/config/scope-change)
* [Storefront Configuration](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/commerce-configuration/)
* [Folder Mapping](https://www.aem.live/developer/folder-mapping)

## Big picture

Multistore refers to a streamlined architecture that enables managing multiple stores with unique catalogs and localization while leveraging a shared code base and unified content delivery. The content hierarchy follows [Edge Delivery Services](https://experienceleague.adobe.com/en/docs/experience-manager-cloud-service/content/edge-delivery/overview) best practices, emphasizing a single-tier structure.

Content is organized primarily by language. US English files should be placed in the `en` directory of the project root. All other language- and region-specific files should be placed in a directory that is named in the format `*region-code_language-code*`. For example, the `/en/` directory contains data for the US market, while the  `/en_ca/` directory contains data for Canada. French content should be placed in directories with names like `fr_fr` for France and `fr_ca` for Canada.

The Document Authoring Content file structure of a multistore is shown below.


- **/en/** _-- English store (Default root language)_
  - placeholders/** _-- Stores JSON files for text and UI components for the English US store._
  - index _-- The home page of the English US store._
  - store-switcher _-- Manages the list of stores and their URL for the English US store._
- **/en_ca/** _-- English Canadian Store_
  - placeholders/** _-- Defines JSON files for text and UI components for the Canadian store._
  - index _-- The home page of the English Canadian store._
  - store-switcher _-- Manages the list of stores and their URL for the Canadian store._


Default files are provided in the sample content. These files can be customized to suit your needs.


## Store-specific files

The content, placeholders, and store switcher files help define the experience in each store view as described here.

### Store switcher

Each store view has its own `store-switcher` document file called a fragment. This fragment provides the list of stores to select from by language. The store-switcher component renders a button in the footer that opens a modal containing the stores listed in this document.

Start by creating a `store-switcher` file containing a bulleted list inside each store view root folder. Each line must define the display name of your store with an active link to the store, as shown below:

```text
**Select a store:**

- United States (USD)
  - [United States (USD)](https://main--aem-boilerplate-commerce--hlxsites.aem.page/en/#nolocal)
- Canada (CAD)
  - [Canada (EN)](https://main--aem-boilerplate-commerce--hlxsites.aem.page/en_ca/#nolocal)
```

**Important:** The storefront will automatically update links relative to the storefront's root path. For links you don't want to be localized (such as a store switcher links), add the hash `#nolocal` to ensure these remain absolute to the site. This is particularly useful for store switchers as you want to navigate to different store paths within the same site.

### Content files

The content files provide the structure of the pages served to your shoppers. They are located in the store view directories and contain the content for each store view. These files are documents hosted on `https://da.live` (Document Author environment), SharePoint `.docx`, or Google that are used to generate the store view pages. These files should be localized for the desired region and language.


### Placeholders

In the placeholders directory, you will find JSON files that define reusable variables for text and UI components. Each drop-in component has its own placeholders fileâ€” `cart.json`, `checkout.json`, `pdp.json`. These files replace variables in your content files with text values.

## Storefront configuration

### Folder mapping

Product Detail Pages (PDP) are mapped to a single document at `products/default`.
When adding a new store view, you'll need to add a corresponding folder mapping for the new URLs.

#### fstab.yaml

If your project uses a `fstab.yaml` file, add the new store view mapping under the `folders:` section, like this:

```yaml
mountpoints:
  /: https://example.mountpoint.com/:f:/r/sites/myproject

folders:
  /en/products/: /en/products/default
  /en_ca/products/: /en_ca/products/default
```

#### Configuration Service

If your project uses the Configuration Service, you must update the configuration to add the new store view mapping under the `folders:` section, like this:

```json
{
  "folders": {
    "/en/products/": "/en/products/default",
    "/en_ca/products/": "/en_ca/products/default"
  }
}
```

To learn more about the Config Service, please see [aem.live's documentation](https://www.aem.live/docs/config-service-setup) or read the [api documentation](https://www.aem.live/docs/admin.html#tag/siteConfig/operation/updateConfigSite) to learn how to publish your updates to the Config Service for your site.

### Site configuration

You must update your [storefront config](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/commerce-configuration/) to include configuration overrides for the new store view. In this file, you'll define store-view specific settings, such as service headers and analytics values. The `key` of each overridden object must match the root folder path of the corresponding store view. These values will be merged into the default configuration.

The `analytics` section contains the Adobe Commerce environment variables for the store view. These variables are used by the Analytics API. For more details, see [Analytics](https://experienceleague.adobe.com/developer/commerce/storefront/setup/analytics/instrumentation/).

```json
{
  "public": {
    "default": {
      // default configuration
    },
    "/en/": {}, // inherits the default
    "/en_ca/": {
      "headers": {
        // overrides values from the default headers
      },
      "analytics": {
        // overrides values from the default analytics configuration
      }
    }
  }
}
```

## Step-by-step

These steps show you how to add a new English Canadian store view (`en_ca`) similar to the default English store (`en`).



<Task>
### Add a new store

Create an `en_ca` store view in the Commerce Admin and perform the following steps in your project.

<Steps>
1. Create the `/en_ca/` folder under the project root in your content folder. You can name this folder anything you want, as long as it's unique and can be used in a web address. For example, instead of `Canada (English)`, you can use `ca_en`.

1. Copy the store switcher, placeholders directory, and document files from the `/en/` directory to the `/en_ca/` directory.
</Steps>

</Task>

<Task>
### Update Content Files

Next, localize or translate the files in your project.

<Steps>
1. Translate or localize content files in the `/en_ca/` folders.

1. Make sure labels in the placeholder JSON files are correctly translated. Update each component's placeholders file as neededâ€”`cart.json`, `checkout.json`, `pdp.json`.
</Steps>
</Task>

<Task>
### Update Storefront configuration

:::note[Code Change Required]
This step requires updating configuration files in your project to support the new store view.
:::

<Steps>
1. Update the `fstab.yaml` file â€” or the `fstab` section of your [site config](https://www.aem.live/docs/admin.html#tag/siteConfig) â€” to include the new folder mapping for the `/en_ca/` store view. This should map to the appropriate content path. For example, `/en_ca/products/` should map to `/en_ca/products/default`.

1. Update the `config.json` file - or the `public` section of your [site config](https://www.aem.live/docs/admin.html#tag/siteConfig) - to include a new entry under in the `public` object for `/en_ca/`. Use this section to define store-specific values such as headers, analytics, and more, if they differ from the default. Make sure the `key` matches the folder path of your store view.  For example,  the `/en_ca/` key for your Canadian store). Values in this object will override those in the default configuration.


1. If you are using the Config Service, read the [api documentation](https://www.aem.live/docs/admin.html#tag/siteConfig/operation/updateConfigSite) to learn how to publish your updates to the Config Service for your site.

</Steps>
</Task>

<Task>
### Preview and validate

Finally, preview and publish the new store view.

<Steps>
1. Preview all files in the updated folder `/en_ca/` with [AEM Sidekick](https://experienceleague.adobe.com/en/docs/experience-manager-cloud-service/content/edge-delivery/resources/sidekick/sidekick).

1. Validate the storefront experience by accessing the new language/region and testing the rendering, navigation, and data accuracy.

1. Publish the updated folder using the AEM Sidekick folder when ready.

1. Update the `store-switcher` content document to include a link to the new store view.
</Steps>

</Task>

---

# Overview

Commerce Blocks are pre-built components that provide essential storefront functionality, allowing you to quickly build and customize your e-commerce experience.

---

# Using Content and Commerce blocks

**Content and Commerce blocks** are foundational, pre-built UI components that serve as the building blocks of your storefront. They are defined using tables in the content and decorated by your custom code during page rendering. Drop-ins are dynamic, commerce-specific front-end components that can be integrated within a Block.

These blocks provide a modular approach to building storefronts, allowing you to quickly assemble pages using proven components while maintaining the flexibility to customize their appearance and behavior. As key components of the Commerce Storefront ecosystem, they work seamlessly with Edge Delivery Services for optimal performance and can be easily managed through the Document Authoring tool.

## What are Content and Commerce blocks?

Blocks are a foundational concept for adding form and function to page sections within the Commerce Storefront.

:::note
You can add commerce features to any content block by including drop-ins in the block. Commerce blocks themselves are simply content blocks that use drop-ins to add commerce functionality.
:::

### Content Blocks

Content Blocks are pre-built content components used to build the static storefront content. These components help you create engaging, structured content for your pages without requiring custom development for common UI patterns. Content blocks include:
- Buttons and call-to-action elements
- Images and media galleries
- Lists and navigation elements
- Links and social media components
- Text formatting and layout components
- And many more foundational content elements

### Commerce Blocks

Commerce Blocks are pre-built commerce components used to build the storefront's dynamic commerce-related pages. These components handle the interactive, transaction-focused elements of your storefront that connect directly with your commerce backend. Commerce blocks include:
- Product details pages (PDP)
- Shopping cart functionality
- Checkout processes
- Product listing pages (PLP)
- Search and filtering components
- User account management
- And other commerce-specific features

### Drop-ins Integration

Drop-ins are dynamic, commerce-specific front-end components that can be integrated within a Block. They provide the interactive functionality that powers your commerce experience, working seamlessly with both Content and Commerce blocks to deliver a cohesive storefront experience.

## How to use Content and Commerce blocks

Content and Commerce blocks are designed to be intuitive and developer-friendly. You can implement them using simple table structures in your content, which are then enhanced with interactive functionality through drop-ins and custom styling.

The blocks integrate naturally with the broader Commerce Storefront ecosystem:
- **Document Authoring (DA.live)**: Create and manage block content through the CMS interface
- **Visual Editor**: Edit blocks in real-time with immediate live preview
- **Edge Delivery Services**: Ensure fast, reliable delivery of block content globally
- **Product Visuals**: Access and manage media assets used within blocks

Information about the blocks and how to implement them is well-documented in the following resources and within the Block Collection documentation. Links to both are provided below.

- [Block Collection documentation](https://www.aem.live/developer/block-collection)
- [Drop-ins documentation](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/introduction/)
- [Content blocks tutorial](https://www.aem.live/docs/authoring)

---

# Create your content

**Commerce Storefront** is included with Adobe Commerce as a Cloud Service and Adobe Commerce Optimizer. It is designed to streamline both the technical and editorial workflows for creating and maintaining the content for your commerce storefronts. 

## What is the Commerce Storefront?

The **Commerce Storefront** is a collection of tools and technologies from Adobe designed to make it easy to create, manage, and customize modern, high-performance storefronts. It brings together the following toolsâ€”the building blocks of a commerce storefront:


  ![What is the Commerce Storefront?](images/storefront-builder.png/)




1. **Document Authoring (DA.live)**: The content management app (CMS) where your storefront's pages, blocks, and assets are authored and managed.

1. **Visual Editor**: A subset of features from the AEM Universal Editor that provides business users and content authors a WYSIWYG editor for updating content directly on the rendered page of the storefront.

1. **Digital Assets Management**: Tools for storing and managing images and other media used on your storefront.

1. **Content Blocks**: Pre-built content components used to build the static storefront content, such as buttons, images, lists, links, and more.

1. **Commerce Blocks**: Pre-built commerce components that use drop-ins to add commerce features to your storefront, such as product details, cart, checkout, product lists, and more.

1. **Edge Delivery Services**: A fast, scalable delivery platform for your storefront and its assets.



### DA.live (Document Authoring)

DA.live (Document Authoring) is the content management system (CMS) you use to build you storefront site. It is where you create and manage your storefront's pages, blocks, and assets. DA.live provides a collaborative environment for content teams to create and structure site content, manage translations, and control publishing workflows. It integrates with Visual Editor for in-context editing and with Edge Delivery Services for fast, reliable content delivery. DA.live supports versioning, localization, and the features required to manage multiple commerce storefronts.

Learn more about DA.live in the [DA.live tutorial](https://www.aem.live/developer/da-tutorial).

### Visual Editor

The Visual Editor is a powerful visual editing tool that enables business users and content authors to edit website content in real-time with immediate live previews and publishing. This in-context editing experience eliminates the need to switch between different tools or wait for publishing cycles to see changes.

Learn how to use the Visual Editor in the [Using the Visual Editor](https://experienceleague.adobe.com/developer/commerce/storefront/merchants/storefront-builder/visual-editor/) topic.

For more information about the Universal Editor, see [Universal Editor authoring](https://experienceleague.adobe.com/en/docs/experience-manager-cloud-service/content/sites/authoring/universal-editor/authoring).

### Digital Assets Management

The digital assets management (DAM) tool, powered by Adobe Experience Manager Assets, provides access to editorial assets like images, videos, and other media used on content pages and product enrichments. The DAM tools integrate with DA.live and Visual Editor for seamless media content management and asset selection. It works with Edge Delivery Services to deliver optimized assets globally.

For more information about AEM Assets, see [Publishing pages with AEM Assets](https://www.aem.live/docs/universal-editor-assets) and [AEM Assets overview](https://experienceleague.adobe.com/en/docs/experience-manager-assets/content/home.html).

### Content and Commerce blocks

Blocks are a foundational concept for adding form and function to page sections. They are defined using tables in the content and rendered on-screen using content properties and style-sheets. Commerce blocks are content blocks that use drop-ins to add commerce features to your storefront, such as product details, cart, checkout, product lists, and more.

Learn how to use the Content and Commerce blocks in the [Content and Commerce blocks](https://experienceleague.adobe.com/developer/commerce/storefront/merchants/storefront-builder/content-commerce-blocks/) topic.

For more information about content blocks, see the [Block Collection](https://www.aem.live/developer/block-collection) topic.

### Edge Delivery Services

Edge Delivery Services is a fast, scalable platform for delivering your storefront's content and assets to customers. It leverages a global content delivery network (CDN) to ensure that pages, images, and other resources load quickly, no matter where your customers are located. By serving content from the edge (geographically distributed servers closer to your customers), we reduce latency and improve site performance, which is critical for both user experience and SEO. Edge Delivery Services is tightly integrated with the Commerce Storefront ecosystem, ensuring seamless deployment and updates to your customer's storefront experience.

Learn more about Edge Delivery Services in the [Edge Delivery Services Overview](https://experienceleague.adobe.com/en/docs/experience-manager-cloud-service/content/edge-delivery/overview) topic.

## Summary

The Commerce Storefront is Adobe's comprehensive solution for creating and managing modern, high-performance storefronts. It combines six essential tools into a unified ecosystem:

- **DA.live** serves as your content management system for authoring and organizing storefront content
- **Visual Editor** provides real-time, in-context editing capabilities for business users and content authors
- **Product Visuals** offers digital asset management for storing and optimizing editorial media
- **Content Blocks** and **Commerce Blocks** provide pre-built components for both static content and dynamic commerce functionality
- **Edge Delivery Services** ensures fast, global content delivery through a scalable CDN platform

Together, these tools streamline both technical and editorial workflows, enabling teams to efficiently create, customize, and maintain commerce storefronts that deliver exceptional user experiences and optimal performance.

---

# Using the Document Authoring tool

The Document Authoring tool is the content management system (CMS) at the heart of the Commerce Storefront. It is where your storefront's pages, blocks, and assets are authored, organized, and managed. 

DA.live provides a collaborative environment for content teams to create and structure site content, manage translations, and control publishing workflows. It integrates with Visual Editor for in-context editing and with Edge Delivery Services for fast, reliable content delivery. DA.live supports versioning, localization, and multistore management, making it a powerful tool for complex commerce operations.

## How to use the Document Authoring tool

Information about the tool and how to use it is well-documented in the following tutorial and within the Document Authoring application itself. Links to both are provided below.

- [DA.live tutorial](https://www.aem.live/developer/da-tutorial)
- [DA.live documentation](https://da.live/docs)

---

# Overview

Quick Start provides everything you need to begin creating content for your Commerce Storefront, from understanding the tools and technologies to authoring content with document authoring and visual editing capabilities.

---

# Using the Visual Editor

The **Visual Editor** is a powerful visual editing tool that enables business users and content authors to edit website content in real-time with immediate live preview. This in-context editing experience eliminates the need to switch between different tools or wait for publishing cycles to see changes.

Visual Editor provides a WYSIWYG (What You See Is What You Get) experience while updating content directly on the rendered page of your storefront. It offers an intuitive interface for updating text, images, blocks, and drop-ins without requiring technical knowledge or switching between different tools.

With Visual Editor, you can make immediate changes to your storefront content and see the results instantly, eliminating the need for separate preview environments or publishing cycles. This tool is particularly valuable for marketing teams, content creators, and business users who need to quickly update product descriptions, promotional content, or page layouts to respond to market demands or campaign requirements.

## What is the Visual Editor?

Visual Editor is a subset of features from the AEM Universal Editor that provides business users and content authors with an intuitive, visual interface for content management. As a key component of the Commerce Storefront ecosystem, it bridges the gap between technical implementation and content authoring.

### Key Features

The Visual Editor offers several powerful capabilities:

- **Real-time editing**: Make changes and see them immediately on the live page
- **In-context editing**: Edit content directly where it appears on the storefront
- **WYSIWYG interface**: See exactly how your content will look to customers
- **Block and drop-in management**: Easily update both content and commerce components
- **No technical knowledge required**: Business users can make changes without developer assistance
- **Seamless workflow**: Eliminate the need to switch between different editing tools

### Integration with Commerce Storefront

Visual Editor works seamlessly with other Commerce Storefront components:

- **Document Authoring (DA.live)**: Edit content that's managed and organized in the CMS
- **Content and Commerce Blocks**: Visually modify both static content blocks and dynamic commerce blocks
- **Edge Delivery Services**: Changes are delivered through the fast, global CDN
- **Product Visuals**: Access and update media assets directly within the editing interface

### Benefits for Business Users

Visual Editor is specifically designed to empower non-technical users:

- **Faster content updates**: No need to wait for development cycles or technical assistance
- **Immediate feedback**: See changes instantly without publishing delays
- **Reduced errors**: Visual editing reduces the risk of formatting or layout issues
- **Enhanced productivity**: Streamlined workflow for content teams and marketers
- **Campaign agility**: Quickly respond to market changes or promotional opportunities

## How to use the Visual Editor

Visual Editor provides an intuitive, point-and-click interface that makes content editing accessible to business users. The tool integrates directly with your storefront pages, allowing you to edit content in the context where it will be displayed to customers.

Information about the Visual Editor and how to use share many of the same features as the Universal Editor. A link to the Universal Editor documentation is provided here:

- [Universal Editor authoring](https://experienceleague.adobe.com/en/docs/experience-manager-cloud-service/content/sites/authoring/universal-editor/authoring)
- [Block Collection documentation](https://www.aem.live/developer/block-collection)
- [Drop-ins documentation](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/introduction/)

---

# Customize the cart drop-in component

In this video you will learn how to customize the cart drop-in component.

---

# Customize the checkout drop-in component

In this video you will learn how to customize the checkout drop-in component.

---

# Customize the PDP drop-in component

In this video, you will learn how to customize the PDP drop-in.


  <Aside type="tip" title="Roadmap">
    This is the first video in a series that will teach you how to customize the 
    commerce boilerplate drop-in components to create a polished, production-ready storefront. 
    Check back later for updates!
  </Aside>

---

# Add custom product lines to the cart summary

What you'll learn

  
    In this video, you will learn how to customize and extend the cart drop-in component to achieve
    the following:
  

  
    <li>Display delivery timelines for back-ordered products</li>
    <li>Show returnable and final sale notices</li>
    <li>Apply a 25% discount to carts with a subtotal of $75 or more</li>
  

  
    By leveraging product attributes and slots, these features enhance the overall shopping cart
    experience.
  

  Who is this video for?

  This video is beneficial for:

  
    <li>
      <strong>E-commerce businesses</strong> looking to enhance the shopping cart with delivery timelines,
      sale information, and discounts.
    </li>
    <li><strong>Developers</strong> who need to implement these customizations for cart items.</li>
    <li>
      <strong>Merchandisers</strong> who want to understand the available native features to enhance
      the customer experience.
    </li>
  

  Video content

  
    <li>
      Customizing product details and displaying delivery timelines for back-ordered products in the
      shopping cart.
    </li>
    <li>
      Using out-of-the-box functionality to show returnable and final sale information for cart
      items.
    </li>
    <li>
      Applying coupon discounts using cart rules and footer slots to display discount details
      effectively.
    </li>
    <li>
      Extending and customizing shopping cart functionality using product attributes and slots to
      meet project requirements.
    </li>
  

  
    <iframe
      width="760"
      height="430"
      src="https://video.tv.adobe.com/v/3441114?learn=on"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen></iframe>
  

  
    <Aside type="note" title="Looking for the documentation?">
      See the <a
        href="https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/tutorials/add-product-lines-to-cart-summary/"> text-based</a> version of this video tutorial for step-by-step instructions and code samples.
    </Aside>

---

# Buy online, pickup in store

What you'll learn

  Learn how to implement a Buy Online, Pick Up In Store (BOPIS) checkout flow.

  Who is this video for?

  
    <li>
      <strong>E-commerce businesses</strong> looking to enhance the shopping cart with BOPIS functionality.
    </li>
    <li><strong>Developers</strong> who need to learn how to implement BOPIS.</li>
  

  Video content

  
    <li>Updating content fragments.</li>
    <li>Adding UI elements for delivery and in-store pickup.</li>
    <li>Toggling between delivery and in-store pickup.</li>
    <li>Fetching pickup locations.</li>
  

  
    <iframe
      width="760"
      height="430"
      src="https://video.tv.adobe.com/v/3441699?learn=on"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen></iframe>
  

  
    <Aside type="note" title="Looking for the documentation?">
      See the <a
        href="https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/tutorials/buy-online-pickup-in-store/"> text-based</a> version of this video tutorial for step-by-step instructions and code samples.
    </Aside>

---

# Customize address form layout and address lookup

What you'll learn

  In this video, you will learn how to:

  
    <li>
      Customize the address form layout at checkout to ensure that all fields are 50% width, except
      for the text area.
    </li>
    <li>
      Integrate a third-party API to enable auto address lookup and validation in the address form.
    </li>
    <li>
      Add a new sidebar menu item to the user account dashboard, linking to a custom page for a
      store locator.
    </li>
  

  Who is this video for?

  This video is beneficial for:

  
    <li>
      <strong>E-commerce managers</strong> looking to understand how the checkout process and user account
      dashboard can be improved to enhance the customer experience.
    </li>
    <li>
      <strong>Front-end developers</strong> who need insights into practical implementations of CSS adjustments,
      third-party API integrations, and UI component customizations.
    </li>
    <li>
      <strong>UX/UI designers</strong> interested in how design changes are implemented and validated
      to ensure a consistent, user-friendly interface.
    </li>
    <li>
      <strong>Project managers</strong> who need to track development progress and understand the technical
      steps involved in achieving project goals.
    </li>
    <li>
      <strong>Technical leads</strong> overseeing development and ensuring best practices are followed
      in code implementation and integration.
    </li>
  

  Video content

  
    <li>Customizing field widths in checkout forms to ensure a consistent layout.</li>
    <li>
      Integrating the Google Address API to enable auto address lookup and completion, reducing user
      input errors and streamlining the checkout process.
    </li>
    <li>
      Implementing validation and error handling for address input fields to provide immediate
      feedback on incorrect or incomplete entries, enhancing the user experience.
    </li>
    <li>
      Extending the user account dashboard by adding a new sidebar menu item that links to a store
      locator page.
    </li>
  

  
    <iframe
      width="760"
      height="430"
      src="https://video.tv.adobe.com/v/3442787?learn=on"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen></iframe>
  

  
    <Aside type="note" title="Looking for the documentation?">
      See the text-based versions of this video tutorial for step-by-step instructions and code
      samples.

      <ul>
        <li>
          <a
            href="https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/tutorials/address-integration/"
            >Address verification</a>
        </li>
        <li>
          <a
            href="https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/tutorials/"
            >Customize the address form layout</a>
        </li>
        <li>
          <a
            href="https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/sidebar/"
            >User account sidebar</a>
        </li>
      </ul>
    </Aside>

---

# Customize cart summary

What you'll learn

  
    In this video, you will learn how to adjust the transactional flow for checkout using the cart
    drop-in component.
  

  Who is this video for?

  
    <li>
      <strong>Developers and store owners</strong> looking to modify cart drop-in elements while working
      with Edge Delivery Services.
    </li>
    <li>
      <strong>Marketers and business professionals</strong> interested in using Document Authoring to manage
      features and conduct A/B testing.
    </li>
  

  Video content

  
    <li>
      <strong>Quantity Selector Update:</strong> Change the product quantity selector from an incrementor
      to a dropdown, displaying values from 1 to 20.
    </li>
    <li>
      <strong>Discount Display:</strong> Implement features that show both discount percentages and dollar
      amount discounts for sale items in the cart.
    </li>
    <li>
      <strong>A/B Testing Flexibility:</strong> Enable configurations through Document Authoring, allowing marketers
      to control and test features easily.
    </li>
    <li>
      <strong>Enhanced Marketing Control:</strong> Improve user experience and marketing effectiveness
      by managing and testing configurations efficiently.
    </li>
  

  
    <iframe
      width="760"
      height="430"
      src="https://video.tv.adobe.com/v/3442351?learn=on"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen></iframe>
  

  
    <Aside type="note" title="Looking for the documentation?">
      See the <a
        href="https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/tutorials/configure-cart-summary/"> text-base
        </a>version of this video tutorial for step-by-step instructions and code samples.
    </Aside>

---

# Customize order summary lines

What you'll learn

  
    In this video, you will learn how to customize the cart drop-in component and adjust the cart
    experience. There are several ways to enhance the cart by making minor changes or updates to the
    code.
  

  Who is this video for?

  
    <li><strong>Developers</strong> who need to implement customizations for the order summary.</li>
    <li>
      <strong>Merchandisers</strong> looking to explore native features that enhance the customer experience
      around the order summary.
    </li>
  

  Video content

  
    <li>Display an estimated shipping cost.</li>
    <li>Include the total amount saved in the cart summary.</li>
    <li>Merge lines in the cart summary into a single collapsible section.</li>
  

  
    <iframe
      width="760"
      height="430"
      src="https://video.tv.adobe.com/v/3441185?learn=on"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen></iframe>
  

  
    <Aside type="note" title="Looking for the documentation?">
      See the <a
        href="https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/tutorials/order-summary-lines/">
        text-based
        </a> version of this video tutorial for step-by-step instructions and code samples.
    </Aside>

---

# Storefront Videos

Welcome to the home of our Commerce Training Videos! These videos will teach you how to transform the boilerplate template into a polished, production-ready storefront.

---

# Multi-step checkout

What you'll learn

  
    In this video, you will learn how to customize the checkout experience using the checkout
    drop-in component. This includes modifying shipping options and implementing a multi-step
    checkout process for guest shoppers.
  

  Who is this video for?

  
    This video is for developers and technical professionals working with Adobe Commerce and Edge
    Delivery Services who are using the checkout drop-in component.
  

  Video content

  
    <li>Customizing the checkout experience.</li>
    <li>Implementing a multi-step checkout.</li>
    <li>Reusing existing code and following best practices.</li>
  

  
    <iframe
      width="760"
      height="430"
      src="https://video.tv.adobe.com/v/3442650?learn=on"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen></iframe>
  

  
    <Aside type="note" title="Looking for the documentation?">
      See the <a
        href="https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/tutorials/multi-step/">text-based</a> version of this video tutorial for step-by-step instructions and code samples.
    </Aside>

---

# Shopper experience

What you'll learn

  
    In this video, you will learn how drop-in components support the shopper experience on your storefront.
  

  Who is this video for?

  
    This video is for ecommerce professionals working with Adobe Commerce and the Commerce Storefront powered by Edge
    Delivery Services.
  

  Video content

  
    <li>Add and managing products in the cart.</li>
    <li>View catalog rules and savings applied to products in the cart.</li>
    <li>Apply coupon codes.</li>
    <li>Log in to a customer account during checkout.</li>
    <li>Place an order.</li>
    <li>Guest order lookup.</li>
    <li>Cancel pending orders.</li>
    <li>View order history in a customer account.</li>
    <li>Submit and manage returns.</li>
  

  
    <iframe
      width="760"
      height="430"
      src="https://video.tv.adobe.com/v/3446762?learn=on"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen></iframe>

---

# Commerce Optimizer API Playground

Our Commerce Optimizer API playground provides a hands-on experience to learn more about our Merchandising services powered by Channels and Policies. You can select the query buttons to run predefined queries, then customize them to explore our APIs in greater detail.

---

# Commerce API Playground

Our Commerce API playground provides a hands-on experience to learn more about our Commerce services. You can select the query buttons to run predefined queries, then customize them to explore our APIs in greater detail.

---

# Storefront Playgrounds

Welcome to the Commerce Playgrounds, where you can get hands-on experience with Commerce services, storefronts, and drop-in components. Select a playground to get started.

---

# Changelog

<div class="changelog-entries">

{/************* 
**Boilerplate** 
***************/}

    <ChangelogEntry
      date="2025-10-14"
      title="Boilerplate Updates"
      components={['Boilerplate']}
    >

    <Aside type="note" title="Internal Links">
      Most PR links in the October 2025 suite resolve to private repos. These links will not work if you don't have access to the private repos (mostly drop-in repos).
    </Aside>

      The Commerce boilerplate has been updated with the following changes:

      - **AEM Assets compatibility** - Decimal dimensions now render properly, supporting image rendering with decimal width/height values ([#767](https://github.com/hlxsites/aem-boilerplate-commerce/pull/767)).
      - **Commerce Block documentation** - Commerce blocks now include comprehensive README files for better developer onboarding and implementation guidance ([#728](https://github.com/hlxsites/aem-boilerplate-commerce/pull/728))
      - **Configuration error handling** - Missing or invalid site configurations now show a helpful 418 error page that provides clear guidance to developers ([#714](https://github.com/hlxsites/aem-boilerplate-commerce/pull/714))
      - **Configuration fallback enhancement** - Single-endpoint setups now automatically fall back to "commerce-endpoint", simplifying configuration ([#700](https://github.com/hlxsites/aem-boilerplate-commerce/pull/700))
      - **Metadata and schema improvements** - **Breaking change**: Product URLs now enforce lowercase SKUs. Sites with uppercase SKUs must ensure proper metadata mapping to prevent broken links ([#406](https://github.com/hlxsites/aem-boilerplate-commerce/pull/406)). Metadata handling now works properly for multistore configurations with JSON-LD path resolution ([#686](https://github.com/hlxsites/aem-boilerplate-commerce/pull/686))
      - **Mini-PDP component reorganization** - The mini-pdp component now lives in the components folder for better code organization and reusability ([#722](https://github.com/hlxsites/aem-boilerplate-commerce/pull/722))
      - **PDP state management** - Multiple PDPs on the same page no longer overwrite each other's state, ensuring proper product data isolation ([#696](https://github.com/hlxsites/aem-boilerplate-commerce/pull/696))
      - **Placeholder data preservation** - Placeholder data no longer gets lost, preventing content display issues ([#689](https://github.com/hlxsites/aem-boilerplate-commerce/pull/689))
      - **Search functionality improvements** - Search functionality now handles results better with improved styling ([#776](https://github.com/hlxsites/aem-boilerplate-commerce/pull/776))
      - **UI accessibility improvements** - Non-interactive elements no longer show pointer cursors, improving accessibility compliance ([#681](https://github.com/hlxsites/aem-boilerplate-commerce/pull/681))

      For complete details, see the [Boilerplate Updates changelog entry](https://github.com/hlxsites/aem-boilerplate-commerce/releases/tag/october-2025).

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-08-12"
      title="Boilerplate Updates"
      components={['Boilerplate']}
    >
      The Commerce boilerplate has been updated with the following changes:

      - **Account drop-in fixes** - Resolved various account drop-in functionality issues
      - **Added carousel and cards-list components** - Integrated carousel and cards-list components for enhanced product display capabilities
      - **Architecture cleanup** - Removed deprecated widgets and custom PLP components
      - **Checkout compatibility** - Fixed shipping methods infinite loop and iOS compatibility
      - **Checkout update** - Updated checkout drop-in to version 2.0.0-beta6
      - **Commerce Storefront compatibility improvements** - Enhanced compatibility with storefront-builder for improved UE integration
      - **Documentation enhancement** - Added comprehensive JSDocs comments to commerce.js
      - **Global placeholders** - Implemented global placeholders system
      - **Header optimization** - Optimized header's mini-cart and search loading performance
      - **Initialization optimization** - Reordered main initialization in scripts.js for improved loading sequence
      - **Modal localization** - Fixed modal localized text display
      - **PDP image zoom fix** - Fixed image zoom icon display issues
      - **Product discovery search fix** - Fixed search item link functionality
      - **reCAPTCHA enhancement** - Enhanced reCAPTCHA initialization in initializeDropins function
      - **Recommendations drop-in events** - Recommendations drop-in now sends Adobe Client Data Layer events
      - **Recommendations update** - Updated @storefront-recommendations to v1.0.0
      - **Removed default content from product-details block** - Cleaned up default content from product-details block for cleaner implementation
      - **Scripts refactoring** - Major refactoring of scripts.js for improved maintainability
      - **Wishlist improvements** - Enhanced wishlist mobile alerts and cart integration

      For complete details, see the [Boilerplate Updates changelog entry](https://github.com/hlxsites/aem-boilerplate-commerce/releases/tag/august-2025).

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-06-24"
      title="Boilerplate Refactoring"
      components={['Boilerplate']}
    >
      The `scripts.js` file has been refactored to align with the upstream AEM Boilerplate while extracting all commerce-specific functionality into `scripts/commerce.js`. This refactoring provides better separation of concerns and improved maintainability.

      **Key Changes:**
      - **`scripts.js`** now contains only core AEM functionality (aligned with upstream AEM Boilerplate)
      - **`commerce.js`** now contains all commerce-specific functionality including:
        - GraphQL queries and commerce backend connections
        - Template handling and application
        - Commerce page type detection
        - Adobe Data Layer initialization
        - Commerce utilities (`rootLink`, `fetchPlaceholders`, etc.)
        - Modal auto-linking functionality
        - Commerce-specific preloading logic

      **Import Updates Required:**
      Developers need to update import statements from `scripts/scripts.js` to `scripts/commerce.js` for commerce-specific functions:
      ```javascript
      // Before
      import { rootLink } from '../../scripts/scripts.js';
      import { fetchPlaceholders } from '../../scripts/scripts.js';
      
      // After
      import { rootLink } from '../../scripts/commerce.js';
      import { fetchPlaceholders } from '../../scripts/commerce.js';
      ```

      See the [Architecture Overview](https://experienceleague.adobe.com/developer/commerce/storefront/setup/discovery/architecture/) for more details about the refactoring and its benefits.

    </ChangelogEntry>

{/****** 
**Cart** 
********/}

    <ChangelogEntry
      date="2025-10-14"
      title="Cart v1.5.1"
      components={['Cart']}
    >
      The Cart drop-in component has been updated to include the following changes:

      - **Tiered pricing now available**: The cart automatically applies quantity-based discounts to eligible items. This feature integrates with GraphQL to fetch price tier data, matches the best discount for the current quantity, and calculates savings percentages. Both simple and configurable products display their applicable tiers clearly in the cart UI ([#70](https://github.com/adobe-commerce/storefront-cart/pull/70)).
      - **Smarter configurable product handling**: When you modify a configurable product's options, the cart now intelligently merges it with existing items that have matching configurations. This consolidates quantities and removes duplicates for a cleaner experience. We also fixed an issue where updating items with identical options would incorrectly increase quantity instead of maintaining the current amount ([#69](https://github.com/adobe-commerce/storefront-cart/pull/69)).
      - **B2B company context support**: The cart automatically refreshes when company context changes, keeping contents and pricing synchronized with your current B2B company for multi-company scenarios ([#65](https://github.com/adobe-commerce/storefront-cart/pull/65)).
      - **Cross-tab logout sync**: Cart state now stays consistent across browser tabs after user logout, ensuring the same cart behavior in all active sessions ([#62](https://github.com/adobe-commerce/storefront-cart/pull/62)).
      - **Clearer tax information**: Virtual carts without applied taxes now show "TBD" until checkout begins, then display the actual tax values. This provides clearer tax information throughout the checkout flow ([#72](https://github.com/adobe-commerce/storefront-cart/pull/72)).
      - **Better quantity validation**: Quantity field validation now properly handles maximum values, ensuring accurate input constraints ([#68](https://github.com/adobe-commerce/storefront-cart/pull/68)).
      - **Accessibility improvements**: Lighthouse accessibility scores are now higher thanks to proper aria-labels for quantity inputs and improved keyboard navigation for screen readers ([#67](https://github.com/adobe-commerce/storefront-cart/pull/67)).

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-08-12"
      title="Cart v1.5.0"
      components={['Cart']}
    >
      The Cart drop-in component has been updated to include the following changes:

      - **Extended Add/Update Cart API**: Added support for custom fields in the `addToCart()` and `updateProductsFromCart()` API functions, enabling developers to set and update custom cart item fields such as `standard_height` and `custom_height` during cart operations.
      - **Fixed missing Channel Field**: Fixed an issue where the `channel` attribute was missing from all Adobe Experience Platform (AEP) events on the Product Details Page. The channel field is now properly populated as part of the global storefront context for all PDP events, ensuring complete event data collection.
      - **Added undo remove cart items**: Introduced configurable functionality to allow users to undo item removals from the cart. When enabled, removed items display an undo banner in their original position while cart totals reflect the removal, with the ability to reinstate items with their original quantity and options. The feature works with both built-in remove buttons and the `updateProductsInCart` API, with customizable undo banner styling.
      - **Enhanced mini cart flexibility**: Redesigned the mini cart layout with reduced container nesting and improved slot architecture, allowing developers to easily wrap individual elements (price, product title, quantity), customize action button placement and styling, add quantity stepper labels, and include specific product attributes with comprehensive documentation.

    </ChangelogEntry>

   <ChangelogEntry
      date="2025-06-25"
      title="Cart v1.4.0"
      components={['Cart']}
    >
      - Fixed the alignment of the **Apply** button text in the gift wrapping customization, ensuring it now matches the intended design.{/*USF-2438*/}
      - Resolved an edge case where updating a cart item with the same options and quantity could unexpectedly remove the item from the cart. {/*USF-2213*/}
      - The cart open AEP event now correctly includes `productListItems`, providing more accurate event data.{/*USF-1833*/}
      - The cart view AEP event now includes selected product options and discount information in `productListItems`.{/*USF-1834*/}
      - The add to cart AEP event now populates selected options for complex and bundled products, improving event tracking accuracy.{/*USF-1835*/}
      - The start checkout AEP event now includes available product discount information in productListItems.{/*USF-1836*/}
      - The cart summary list can now be rendered in a customizable column layout, allowing brands to better match their design guidelines.{/*USF-2090*/}

    </ChangelogEntry>

{/**********
**Checkout** 
************/}

    <ChangelogEntry
      date="2025-10-14"
      title="Checkout v2.1.0"
      components={['Checkout']}
    >
      The Checkout drop-in has been updated to include the following changes:

      - **New utility library**: The checkout now includes reusable utilities for address transformation, form validation, cart state management, and shipping cost estimation. This improves code reusability across different checkout implementations ([#88](https://github.com/adobe-commerce/storefront-checkout/pull/88), [#146](https://github.com/adobe-commerce/storefront-checkout/pull/146)).
      - **Free orders now supported**: Zero-cost checkouts (when coupons or promotions cover the full total) now have dedicated payment method display and handling ([#170](https://github.com/adobe-commerce/storefront-checkout/pull/170)).

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-08-12"
      title="Checkout v2.0.1"
      components={['Checkout']}
    >
      The checkout drop-in component has been updated to include the following changes:

      - Miscellaneous bug fixes and enhancements.

      The **[`Multi-step checkout`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/tutorials/multi-step/) tutorial has been updated** providing a customizable example to implement a comprehensive multi-step checkout based on a modular architecture (event-driven step coordination) that supports the following scenarios:
      
      - Guest users
      - Logged-in customers
      - Virtual products
      - Mixed carts (physical + virtual product combinations)

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-06-25"
      title="Checkout v2.0.0"
      components={['Checkout']}
    >
      The **[`checkout drop-in component GraphQL API`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/extending/) has been extended** exposing new fragments:

      - **`BILLING_CART_ADDRESS_FRAGMENT`**
      - **`SHIPPING_CART_ADDRESS_FRAGMENT`**
      - **`AVAILABLE_PAYMENT_METHOD_FRAGMENT`**
      - **`SELECTED_PAYMENT_METHOD_FRAGMENT`**

      The **[`Error Handling`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/error-handling/) has been implemented** in some containers (still work in progress):

      - **`BillToShippingAddress`**
      - **`LoginForm`**
      - **`PaymentMethods`**
      - **`ShippingMethods`**

      The **[`Event Handling`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/) has been documented** within the list of events emitted and subscribed by the checkout drop-in component containers.

      A new **[`Active`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/#active-property) property has been added** for all containers: This property activates/deactivates the container.

      A new **[`AutoSync`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/#autosync-property) property has been added** for some containers: This property allows the container automatically synchronizing its state changes with the backend.

      A new **[`TitleProps`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/#title-and-heading-customization) interface has been created** to customize the title and header of some containers.

      The **[`BillToShippingAddress`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/bill-to-shipping-address/) container configuration structure has been modified.** A new property has been added to the `BillToShippingAddressProps` interface:

      - **`BillToShippingAddressProps.onCartSyncError` property added**: This property allows performing some actions in case of an error is thrown when the bill to shipping checkbox is checked.

      Implemented an **error handling mechanism** for the `BillToShippingAddress` container based on the _"Optimistic" UI updates with rollback pattern_ consisting on the following:

        - It provides a callback function **`onCartSyncError()`** to be used in the integration layer in case the merchant wanted to perform some actions like showing an error message etc.

        - It performs a rollback reverting to the previous valid checkbox state.

        - In case the callback is not implemented, a fallback will be used, which consists of displaying an inline alert message.

      The **[`LoginForm`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/login-form/) container configuration structure has been modified.** New properties have been added to the `LoginFormProps` interface:

      - **`LoginFormProps.displayHeadingContent` property added**: This property allows displaying the container heading content.

      - **`LoginFormProps.slots.Heading` property added**: This property allows customizing the container heading content based on the user authentication status.

      ... and the following properties have been added extending from `TitleProps` interface:

      - **`LoginFormProps.displayTitle` property inherited**: This property allows displaying the container title.

      - **`LoginFormProps.slots.Title` property inherited**: This property allows customizing the container title.

      The **[`PaymentMethods`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/payment-methods/) container configuration structure has been modified.** Deprecated properties have been removed from the `PaymentMethodsProps` interface:

      - **`PaymentMethodsProps.setOnChange` _deprecated_ property removed**.

      - **`PaymentMethodsProps.slots.Handlers` _deprecated_ property removed**.

      ... the following property has been renamed:

      - **`PaymentMethodsProps.slots.Methods[code].setOnChange` property renamed** to **`PaymentMethodsProps.slots.Methods[code].autoSync`**.

      ... the following properties have been added:

      - **`PaymentMethodsProps.onSelectionChange` property added**: This property allows performing some actions when a payment method is selected.

      - **`PaymentMethodsProps.onCartSyncError` property added**: This property allows performing some actions in case of an error is thrown during the payment method selection.

      - **`PaymentMethodsProps.UIComponentType` property added**: This property allows using a different UI component type as a selector for each payment method. UI components available are: 'ToggleButton' and 'RadioButton'.

      ... and the following properties have been added extending from `TitleProps` interface:

      - **`PaymentMethodsProps.displayTitle` property inherited**: This property allows displaying the container title.

      - **`PaymentMethodsProps.slots.Title` property inherited**: This property allows customizing the container title.

      Implemented an **error handling mechanism** for the `PaymentMethods` container based on the _"Optimistic" UI updates with rollback pattern_ consisting on the following:

        - It provides a callback function **`onCartSyncError()`** to be used in the integration layer in case the merchant wanted to perform some actions like showing an error message etc.

        - It performs a rollback reverting to the previous valid payment method selected.

        - In case the callback is not implemented, a fallback will be used, which consists of displaying an inline alert message.

      The **[`ShippingMethods`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/shipping-methods/) container configuration structure has been modified.** A property has been removed from the `ShippingMethodsProps` interface:

      - **`ShippingMethodsProps.preSelectedMethod` property removed**: This was an obsolete and unused property without business logic behind.

      ... the following property has been renamed:

      - **`ShippingMethodsProps.onShippingMethodSelect` property renamed** to **`ShippingMethodsProps.onSelectionChange`**.

      ... the following properties have been added:

      - **`ShippingMethodsProps.onCartSyncError` property added**: This property allows performing some actions in case of an error is thrown during the shipping method selection.

      - **`ShippingMethodsProps.UIComponentType` property added**: This property allows using a different UI component type as a selector for each shipping method. The available UI components are: `ToggleButton` and `RadioButton`.

      ... and the following properties have been added extending from `TitleProps` interface:

      - **`ShippingMethodsProps.displayTitle` property inherited**: This property allows displaying the container title.

      - **`ShippingMethodsProps.slots.Title` property inherited**: This property allows customizing the container title.

      Implemented an **error handling mechanism** for the `ShippingMethods` container based on the _"Optimistic" UI updates with rollback pattern_ consisting on the following:

        - It provides a callback function **`onCartSyncError()`** to be used in the integration layer in case the merchant wanted to perform some actions like showing an error message etc.

        - It performs a rollback reverting to the previous valid shipping method selected.

        - In case the callback is not implemented, a fallback will be used, which consists of displaying an inline alert message.

      The **[`TermsAndConditions`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/terms-and-conditions/) container is now visible** for both the anonymous and authenticated checkout processes.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-03-06"
      title="Checkout v1.3.0"
      components={['Checkout']}
    >
      A new **[`TermsAndConditions`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/terms-and-conditions/) container has been added.**

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-02-11"
      title="Checkout v1.2.0"
      components={['Checkout']}
    >
      The **[`PlaceOrder`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/place-order/) container configuration structure has been modified.** A new property has been added to the `PlaceOrderProps` interface:

      - **`PlaceOrderProps.slots.Content` property added**: This property allows setting the container content based on the selected payment method. This solves the way how to set the container content dynamically based on the selected payment method, instead of having to modify the text of the container manipulating directly the DOM and detecting payment method selection by handling the PaymentMethods slot, which is not ideal for maintainability.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-02-03"
      title="Checkout v1.1.0"
      components={['Checkout']}
    >
      The **[`PaymentMethods`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/containers/payment-methods/) container configuration structure has been modified.** The `PaymentMethodsProps` interface has been changed and some properties have been _deprecated_ and replaced:

      - **`PaymentMethodsProps.setOnChange` property _@deprecated_**: This property is _deprecated_ and will be removed in future versions. It has been replaced by the following: `PaymentMethodsProps.slots.Methods.<payment-method-code>.setOnChange`.
      - **`PaymentMethodsProps.slots.Handlers` property _@deprecated_**: This property is _deprecated_ and will be removed in future versions. It has been replaced by the following one: `PaymentMethodsProps.slots.Methods.<payment-method-code>.render`.
      - **`PaymentMethodsProps.slots.Methods` property added**: This property is an object that consists of a list of payment method codes that provide a set of configurations to customize each payment method individually.

        Configurations accepted by payment methods:

          - The `displayLabel` configuration hides the payment method label (for example, if you only want to display the icon).
          - The `enabled` configuration allows merchants to individually hide payment methods filtering them from the available payment methods list (for example, it is useful when a payment provider has enabled a payment method in the backend, which is configured with more than one payment option and you don't want to display one of them).
          - The `icon` configuration specifies the name of the icon to be shown beside of the label. The icon name must exist within the list of available icons defined in the drop-ins SDK.
          - The `setOnChange` configuration sets the payment method automatically when it is selected. Only if a payment method is specifically set to _false_, the container will not automatically set the payment method to the cart when selected (for example, if a payment method needs to obtain more information during the place order action).
         - The `render` configuration is a handler used to render and configure the payment method.

    </ChangelogEntry>

{/********************************** 
**Storefront Compatibility Package** 
************************************/}

      <ChangelogEntry
          date="2025-10-20"
          title="Storefront Compatibility Package v4.8.9"
          components={['Storefront Compatibility Package']}
      >
          The Storefront Compatibility Package has been updated to include the following changes:

          - **Add to Cart**: Resolved an issue where adding the same configurable product with identical options created separate entries instead of updating the existing itemâ€™s quantity.
      </ChangelogEntry>

      <ChangelogEntry
          date="2025-10-08"
          title="Storefront Compatibility Package v4.8.8"
          components={['Storefront Compatibility Package']}
      >
          The Storefront Compatibility Package has been updated to include the following changes:

          - **Customer ID**: Removed the deprecation notice for the GraphQL `Customer.id` field. This field returns the correct value that can be reused for B2B company management mutations/queries.
          - **Negotiable Quote Address**: Aligned multiple address input types to support customer address UIDs, deprecating customer address IDs. Introduced the `deleteCustomerAddressV2` and `updateCustomerAddressV2` mutations and deprecated the previous versions.
      </ChangelogEntry>

     <ChangelogEntry
          date="2025-09-08"
          title="Storefront Compatibility Package v4.8.7, v4.7.10"
          components={['Storefront Compatibility Package']}
      >
         The Storefront Compatibility Package has been updated to include the following changes:

         - **Historical Orders Fixes**: Ensured stability in order flows by returning null for missing purchased products, avoiding exceptions in order history and recent orders.
     </ChangelogEntry>

    <ChangelogEntry
      date="2025-08-12"
      title="Storefront Compatibility Package v4.8.6, v4.7.9"
      components={['Storefront Compatibility Package']}
    >
      The Storefront Compatibility Package has been updated to include the following changes:

      - **Fixed Cart API availability check**: Resolved an issue where the Cart API incorrectly returned `is_available: false` for products that had sufficient inventory across Multiple Source Inventory (MSI) sources.
      - **Added uid field to Customer Address GraphQL query**: Exposed the `uid` field in the Customer Address GraphQL query to enable setting shipping and billing addresses in negotiable quotes.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-07-14"
      title="Storefront Compatibility Package v4.8.5, v4.7.8"
      components={['Storefront Compatibility Package']}
    >
      The Storefront Compatibility Package has been updated to include the following changes:

      - Miscellaneous bug fixes and enhancements related to cart item and order queries.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-06-25"
      title="Storefront Compatibility Package v4.8.4, v4.7.6"
      components={['Storefront Compatibility Package']}
    >
      The Storefront Compatibility Package has been updated to include the following changes:

      - Added the **Merge Cart Preference** field to the **Store** > **Sales** > **Checkout** > **Shopping Cart** configuration panel in the Admin. It controls cart merge behavior when a GraphQL mutation merges guest or logged-in customer carts. 
      - Added the `OrderTotal.grand_total_excl_tax` field to the GraphQL order response to retrieve the grand total excluding tax.
      - Introduced a new error code REQUIRED_PARAMETER_MISSING to handle missing configurable product options during the add-to-cart process via GraphQL.
      - Added a new REST endpoint `POST /V1/customers/:customerId/token` to facilitate the social login feature through App Builder.
      - (v4.7.6 only) Fixed an issue where plugins for `GiftCardAccountManagementInterface` methods were not working for webhooks.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-05-29"
      title="Storefront Compatibility Package v4.8.3"
      components={['Storefront Compatibility Package']}
    >
      The Storefront Compatibility Package has been updated to include the following changes:

      - Added the `exchangeExternalCustomerToken`mutation to facilitate social login feature through app builder.
      - Fixed issue where plugins for GiftCardAccountManagementInterface methods were not working for webhooks.
      - Fixed order search issue for guest shoppers in EDS.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-05-26"
      title="Storefront Compatibility Package v4.8.2"
      components={['Storefront Compatibility Package']}
    >
      The Storefront Compatibility Package has been updated to include the following changes:

      - Added the `customerSegments`, `customerGroup` query.
      - Exposed customer segment, customer group, cart rule related encoded information with customer and cart Query.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-05-14"
      title="Storefront Compatibility Package v4.8.1"
      components={['Storefront Compatibility Package']}
    >
      The Storefront Compatibility Package has been updated to include the following changes:

      - Fixed issue where tax amounts were not updated when gift wrapping was removed from the cart using GraphQL.
    </ChangelogEntry>

    <ChangelogEntry
      date="2025-05-27"
      title="Storefront Compatibility Package v4.8.0"
      components={['Storefront Compatibility Package']}
    >
      The Storefront Compatibility Package has been updated to include the following changes:

      - Added the `clearWishlist` mutation.
      - Added enhanced support gift options to the `cart`, `orders`, and `products` queries.
      - Miscellaneous bug fixes and enhancements.
    </ChangelogEntry>

    <ChangelogEntry
      date="2025-07-03"
      title="Storefront Compatibility Package v4.7.7"
      components={['Storefront Compatibility Package']}
    >
      The Storefront Compatibility Package has been updated to include the following changes:

      - Miscellaneous bug fixes and enhancements.
    </ChangelogEntry>

    <ChangelogEntry
       date="2025-06-02"
       title="Storefront Compatibility Package v4.7.5"
       components={['Storefront Compatibility Package']}
    >
       The Storefront Compatibility Package has been updated to include the following changes:

       - Added the `exchangeExternalCustomerToken`mutation to facilitate social login feature through app builder.
    </ChangelogEntry>

    <ChangelogEntry
      date="2025-05-26"
      title="Storefront Compatibility Package v4.7.4"
      components={['Storefront Compatibility Package']}
    >
      The Storefront Compatibility Package has been updated to include the following changes:

      - Added the `customerSegments`, and `customerGroup` queries.
      - Exposed customer segment, customer group, cart rule related encoded information with customer and cart queries.
      - Miscellaneous bug fixes and enhancements have been added for gift wrapping and related features.
    </ChangelogEntry>

    <ChangelogEntry
      date="2025-04-28"
      title="Storefront Compatibility Package v4.7.3"
      components={['Storefront Compatibility Package']}
    >
      The Storefront Compatibility Package has been updated to include the following changes:

      - Removed exposure of customer group, customer segment, and cart price rule information through GraphQL.
      - Fixed an Internal Server Error that occurred when selecting the second shipping method with a US address during checkout.
    </ChangelogEntry>

    <ChangelogEntry
      date="2025-04-11"
      title="Storefront Compatibility Package v4.7.2"
      components={['Storefront Compatibility Package']}
    >
      The Storefront Compatibility Package has been updated to include the following changes:

      - Resolved a GraphQL issue where the `quantity` field in `ProductInterface` was not returning the saleable quantity.
      - Fixed an issue where customer segment-based cart price rules didn't apply immediately.
    </ChangelogEntry>

    <ChangelogEntry
      date="2025-04-08"
      title="Storefront Compatibility Package v4.7.1"
      components={['Storefront Compatibility Package']}
    >
      The Storefront Compatibility Package has been updated to include the following changes:

      - Added the `clearWishlist` mutation.
      - Added the `customerGroup` query.
      - Added enhanced support gift options to the `cart`, `orders`, and `products` queries.
      - Added fields to the `storeConfig` query to support checkout options, customer groups, catalog rules, and cart rules.
      - Miscellaneous bugfixes and enhancements.
    </ChangelogEntry>

{/*******
**Order** 
*********/}

    <ChangelogEntry
      date="2025-10-14"
      title="Order v1.4.0"
      components={['Order']}
    >
      The Order drop-in has been updated to include the following changes:

      - **Better order placement consistency**: PlaceOrderFragment now uses a shared GUEST_ORDER_FRAGMENT pattern, making order placement operations more consistent with standardized error handling ([#43](https://github.com/adobe-commerce/storefront-order/pull/43)).
      - **Personal email in analytics events**: Adobe Client Data Layer integration now includes personal email context in place order events for complete customer identification ([#45](https://github.com/adobe-commerce/storefront-order/pull/45)).
      - **More detailed order tracking**: OrderContext now includes paymentAmount and priceTotal fields, plus discountAmount in cart item tracking for better financial reporting ([#45](https://github.com/adobe-commerce/storefront-order/pull/45)).
      - **Smarter returns pagination**: Returns list pagination only scrolls when you're not already at the top of the page, improving the user experience ([#44](https://github.com/adobe-commerce/storefront-order/pull/44)).

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-08-12"
      title="Order v1.3.0"
      components={['Order']}
    >
      The Order drop-in has been updated to include the following changes:

      - **Fixed cancelled product display**: Corrected the CartSummaryItem user experience to properly handle cancelled products by removing the strikethrough text and "out of stock" message that were incorrectly appearing for cancelled orders.
      - **Fixed missing Channel Field**: Added the `channel` attribute to all Adobe Experience Platform (AEP) events in the Order drop-in, ensuring complete event data collection as part of the global storefront context.
      - **Fixed reCAPTCHA v3 integration**: Resolved issues where reCAPTCHA v3 was preventing order placement and blocking user authentication functions (login, account creation, password reset), with solution provided to the ACS team.
      - **Fixed cancelled product messaging**: Resolved an issue where cancelled products incorrectly displayed strikethrough text and "out of stock" messages in the CartSummaryItem component, ensuring proper visual representation of cancelled order items.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-06-25"
      title="Order v1.2.0"
      components={['Order']}
    >
      - Added a new `setPaymentMethodAndPlaceOrderMutation` API for the Order Drop-in, enabling atomic payment and order placement` to better support providers like Adyen.{/*USF-2435*/}
      - Added missing `listImage` slot props to the `ReturnsList` container.{/*USF-2272*/}
      - You can now customize the translation for the order gift wrapping title on the checkout success page, allowing for proper localization.{/*USF-2392*/}
      - Fixed an issue where the `CartSummaryItemImage` slot was not triggered on the return items page, ensuring custom images now display correctly during returns.{/*USF-2303*/}

    </ChangelogEntry>

{/****************** 
**Payment Services** 
********************/}

    <ChangelogEntry
      date="2025-10-14"
      title="Payment Services v1.0.2"
      components={['Payment Services']}
    >
      - **PayPal Fastlane code**: Added `FASTLANE` payment method code to `PaymentMethodCode` enum.

    </ChangelogEntry>

   {/* <ChangelogEntry
      date="2025-06-25"
      title="Payment Services v1.0.1"
      components={['Payment Services']}
    >
      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.

    </ChangelogEntry> */}

{/***************** 
**Personalization** 
*******************/}

    <ChangelogEntry
      date="2025-08-12"
      title="Personalization v1.0.1"
      components={['Personalization']}
    >
      The Personalization drop-in has been updated to include the following changes:

      - **Fixed personalization data update**: Resolved an issue where personalization data was not being updated after an order was placed, ensuring accurate customer segmentation and targeting post-purchase.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-06-25"
      title="Personalization v1.0.0"
      components={['Personalization']}
    >
      Initial release of the personalization drop-in component, including accompanying [developer](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/personalization/) and [merchant](https://experienceleague.adobe.com/developer/commerce/storefront/merchants/get-started/personalization/) documentation.

      This component provides a set of tools and containers designed to display content conditionally, based on Adobe Commerce customer groups, segments, and cart price rules.

    </ChangelogEntry>

{/**********************
**Product details page** 
************************/}

    <ChangelogEntry
      date="2025-10-14"
      title="Product details page v1.3.5"
      components={['Product details page']}
    >
      The Product Details Page drop-in has been updated to include the following changes:

      - **Gift card products now supported**: You can now sell gift cards with full functionality including sender/recipient information, custom messages, preset or custom amounts, and validation rules. All form fields and error messages support internationalization ([#28](https://github.com/adobe-commerce/storefront-pdp/pull/28), [#36](https://github.com/adobe-commerce/storefront-pdp/pull/36), [#40](https://github.com/adobe-commerce/storefront-pdp/pull/40), [#41](https://github.com/adobe-commerce/storefront-pdp/pull/41)).
      - **Global locale support**: The initialize function now accepts a globalLocale option for consistent multi-language support across product attributes, pricing, dates, and currency formatting ([#38](https://github.com/adobe-commerce/storefront-pdp/pull/38)).
      - **Better swatch accessibility**: Swatch and picker components now use unique IDs that combine attribute and option identifiers. This prevents duplicate name attributes and includes enhanced aria-label support for screen readers.
      - **Bundle pricing fixes**: Bundle products now display accurate price calculations when selecting different options, working correctly for both fixed and dynamic bundle types.
      - **GraphQL updates**: Upgraded to @adobe-commerce/fetch-graphql v1.2.0 and added the getFetchGraphQlHeader method for better header management and inspection ([#39](https://github.com/adobe-commerce/storefront-pdp/pull/39)).
      - **Smarter attribute handling**: Special attributes like ac_giftcard now parse JSON properly, transform snake_case to camelCase for validation rules, and handle malformed data gracefully ([#28](https://github.com/adobe-commerce/storefront-pdp/pull/28)).
      - **Carousel keyboard navigation**: Arrow key handlers in the Carousel component no longer prevent default behavior, improving accessibility and native keyboard navigation ([#28](https://github.com/adobe-commerce/storefront-pdp/pull/28)).
      - **Better test coverage**: Added comprehensive end-to-end tests for gift card and configurable products using both standalone and container-based approaches ([#43](https://github.com/adobe-commerce/storefront-pdp/pull/43)).

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-06-25"
      title="Product details page v1.2.0"
      components={['Product details page']}
    >
      - You can now fully replace rendered images in the PDP drop-in component, enabling integration with custom asset sources like AEM Assets.{/* USF-2126 */}
      - Added support for updating product options and quantities directly from the cart, streamlining the editing process for configurable products.{/* USF-2008 */}
      - Resolved an issue where overriding the `Attributes` slot did not render custom content as expected.{/* DATA-6524 */}
      - Fixed a CSS issue where the image zoom close icon appeared too large on product detail pages.{/* USF-2436 */}
      - Fixed an issue where the close button was not being displayed correctly.

    </ChangelogEntry>

{/******************* 
**Product discovery** 
*********************/}

    <ChangelogEntry
      date="2025-10-14"
      title="Product Discovery v2.1.0"
      components={['Product Discovery']}
    >
      The Product Discovery drop-in has been updated to include the following changes:

      - **Header inspection now available**: The getFetchGraphQlHeader method lets developers retrieve individual GraphQL request headers for debugging and inspection ([#66](https://github.com/adobe-commerce/storefront-search-dropin/pull/66)).
      - **More search filter options**: The SearchFilter model now supports additional operators including contains, startsWith, and eq for more flexible product search and filtering ([#71](https://github.com/adobe-commerce/storefront-search-dropin/pull/71)).
      - **Better facet accessibility**: Checkbox naming now uses unique IDs that combine attribute and bucket title, preventing duplicate name attributes and ensuring proper form behavior and accessibility compliance ([#68](https://github.com/adobe-commerce/storefront-search-dropin/pull/68)).

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-08-18"
      title="Product Discovery v2.0.0"
      components={['Product Discovery']}
    >
      **Major Version Release**: Product Discovery has been completely redesigned with a new event-driven architecture and breaking changes that require implementation updates.

      - **Event-driven architecture**: Complete redesign featuring a modern event-driven architecture that provides enhanced performance and improved container interfaces for better responsiveness and maintainability.
      - **Breaking changes**: This major version includes breaking changes to the API structure, event handling, and component interfaces. Existing implementations will need to be updated to use the new architecture and updated container interfaces.
      - **Enhanced documentation**: Updated documentation with comprehensive new diagrams including PopOver and Search flow diagrams (SVG format) to better illustrate the new architecture and user interaction patterns.
      - **Updated containers**: Facets.
      - **New containers**: SortBy, Pagination, SearchResults.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-08-12"
      title="Product Discovery v1.1.0"
      components={['Product Discovery']}
    >
      The Product Discovery drop-in has been updated to include the following changes:

      - **Added custom transformer support**: Introduced custom transformer functionality for `ProductSearchResult` in the API configuration, allowing developers to merge default and custom transformations with comprehensive unit test coverage for validation.
      - **Enhanced Facets with new slots**: Added `FacetBucketLabel` slot to the Facets component with improved context handling and updated the label display to include count information for better user experience.
      - **Added data model extensibility**: Enhanced the Product Discovery drop-in with improved data model extensibility, including custom transformer support for the `transformProduct` function, updated `ProductActions` component integration, and comprehensive unit test coverage.
      - **Fixed missing Channel Field**: Added the `channel` attribute to all Adobe Experience Platform (AEP) events including `searchResponseReceived`, ensuring complete event data collection as part of the global storefront context with updated unit test coverage.
      - **Fixed invalid currency handling**: Resolved currency-related issues and updated package versions to use the latest released library versions for improved stability.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-06-25"
      title="Product Discovery v1.1.0"
      components={['Product Discovery']}
    >
      Initial release of the Product Discovery drop-in component, including accompanying [developer](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/) documentation.

      This component provides a variety of fully-customizable controls to showcase your products (according to your brand's aesthetics) and build interactive experiences that engage customers.

    </ChangelogEntry>

{/************************* 
**Product recommendations** 
***************************/}

    <ChangelogEntry
      date="2025-10-14"
      title="Product Recommendations v1.1.1"
      components={['Product Recommendations']}
    >
      The Product Recommendations drop-in has been updated to include the following changes:

      - **Complex products show price ranges**: The ProductList container now properly displays price ranges for configurable, grouped, and bundled products using the PriceRange component, while simple products continue showing standard pricing. This includes proper type checking and comprehensive test coverage ([#29](https://github.com/adobe-commerce/storefront-recommendations/pull/29)).
      - **Mobile experience improvements**: Mobile view now has better carousel scrolling, proper viewport-based card sizing (80vw with 300px max-width), and automatic left margin adjustment for edge-to-edge scrolling on smaller screens ([#20](https://github.com/adobe-commerce/storefront-recommendations/pull/20)).
      - **CSS conflict resolution**: Global CSS selector conflicts are now resolved by renaming `.recommendations-product-list__content` to `.recommendations-carousel__content`, preventing unintended style leakage and ensuring proper component encapsulation ([#32](https://github.com/adobe-commerce/storefront-recommendations/pull/32)).

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-08-12"
      title="Product Recommendations v1.1.0"
      components={['Product Recommendations']}
    >
      The Product Recommendations drop-in has been updated to include the following changes:

      - **Added recommendation API events**: Introduced new events `recs-api-request-sent` and `recs-api-response-received` to provide better tracking and monitoring of recommendation API interactions.
      - **Added recommendation add-to-cart event**: Implemented `recs-add-to-cart-click` event that triggers when shoppers click the "Add to cart" button on simple products within recommendation containers, including `productId` and `unitId` in the event payload.
      - **Enhanced screen reader accessibility**: Improved Product Recommendations accessibility by adding `<section>` tags with `aria-label="product recommendations"` for carousel boundaries and `role="group"` with numbered `aria-label` attributes (e.g., "product 1 of 8") for individual product slides, enabling better navigation for screen reader users.
      - **Added GraphQL extensibility**: Enhanced the Recommendations drop-in with extensible GraphQL fragments and data module transformers, enabling developers to customize and extend API responses according to their specific requirements.
      - **Fixed recommendation click tracking**: Resolved an issue where the `rec-click` event was not triggering when clicking products in recommendation units.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-06-25"
      title="Product Recommendations v1.0.0"
      components={['Product Recommendations']}
    >
      Initial release of the Product Recommendations drop-in component, including accompanying [developer](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/recommendations/) and [merchant](https://experienceleague.adobe.com/developer/commerce/storefront/merchants/get-started/product-recommendations/) documentation.

    </ChangelogEntry>

{/************** 
**User account** 
****************/}

    <ChangelogEntry
      date="2025-10-14"
      title="User account v1.2.0"
      components={['User account']}
    >
      The User Account drop-in has been updated to include the following changes:

      - **Flexible address identification**: Address data models and GraphQL queries now support uid fields, so you can select and identify addresses using either numeric IDs or string UIDs ([#20](https://github.com/adobe-commerce/storefront-account/pull/20)).

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-08-12"
      title="User account v1.0.9"
      components={['User account']}
    >
      The User Account drop-in has been updated to include the following changes:

      - **Fixed empty order list**: Resolved an issue where the entire order list would appear empty when a customer had an order containing out-of-stock products, even if other valid orders existed.
      - **Added grandTotalExclTax field support**: Added support for the `grandTotalExclTax` field and updated the Order confirmation to use it instead of computing `order?.grandTotal?.value - order?.totalTax?.value` in the frontend. When the order total is FREE, the "Total excluding taxes" line is now omitted, preventing negative excluding-tax totals on zero-total orders.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-06-25"
      title="User account v1.0.7"
      components={['User account']}
    >

      **Fix for empty radio button**

      {/* USF-2322 */}

      We fixed an issue that was causing an empty radio button in the checkout shipping section when customers had no saved addresses. Now, the radio button only displays if the customer is logged in and has at least one saved address, ensuring a cleaner and more intuitive checkout experience.

    </ChangelogEntry>

{/********************* 
**User authentication** 
***********************/}

    <ChangelogEntry
      date="2025-10-14"
      title="User authentication v2.1.1"
      components={['User authentication']}
    >
      The User Authentication drop-in has been updated to include the following changes:

      - **Cookies now use Secure flag**: Authentication cookies (`auth_dropin_firstname` and `auth_dropin_user_token`) now include the Secure flag, ensuring they're only transmitted over HTTPS connections for improved security and protection against man-in-the-middle attacks. Note that this requires your application to run over HTTPS in production environments ([#20](https://github.com/adobe-commerce/storefront-auth/pull/20)).

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-08-12"
      title="User authentication v2.1.0"
      components={['User authentication']}
    >
      The User Authentication drop-in has been updated to include the following changes:

      - **Fixed missing Channel Field**: Added the `channel` attribute to all Adobe Experience Platform (AEP) events as part of the global storefront context, ensuring complete event data collection and proper event categorization.
      - **Fixed invalid email validation**: Prevented GraphQL requests from being sent when an invalid email is entered in the Reset Password form, eliminating unnecessary API calls and error responses for malformed email addresses.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-06-25"
      title="User authentication v2.0.3"
      components={['User authentication']}
    >
      **Callback for successful password reset**

      {/* USF-2338 */}

      You can now customize the user experience after a successful password reset request. A new `onSuccessCallback` method is available in the [`UpdatePassword`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/containers/update-password/) container, allowing developers to override the default notification banner. Use this callback to redirect users, display a custom modal, or implement any other custom behavior upon a successful password reset request.

    </ChangelogEntry>

{/********** 
**Wishlist** 
************/}

    <ChangelogEntry
      date="2025-10-14"
      title="Wishlist v2.0.1"
      components={['Wishlist']}
    >
      The Wishlist drop-in has been updated to include the following changes:

      - **No more visual flickering**: Wishlist content no longer flickers when opening thanks to consistent minimum height constraints across all responsive breakpoints, ensuring smooth visual transitions ([#57](https://github.com/adobe-commerce/storefront-wishlist/pull/57)).
      - **Bundle products now supported**: Wishlists now handle bundle products comprehensively, including proper `bundle_options` and `bundleOptionsUIDs` handling for adding, displaying, and managing bundle products with their selected options ([#59](https://github.com/adobe-commerce/storefront-wishlist/pull/59)).
      - **Cleaner getWishlistById API**: The `getWishlistById` function is now simpler with unused `currentPage` and `pageSize` parameters removed. The API now only requires the `wishlistId` parameter, improving code maintainability ([#58](https://github.com/adobe-commerce/storefront-wishlist/pull/58)).

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-08-12"
      title="Wishlist v2.0.0"
      components={['Wishlist']}
    >
      The Wishlist drop-in has been updated to include the following changes:

      - **Fixed accessibility for Wishlist toggle**: Added proper `aria-label` attributes to WishlistToggle button elements in Product Discovery, resolving critical AXE accessibility issues related to discernible button text and accessible names.
      - **Fixed Wishlist alert messaging**: Corrected WishlistAlert to display appropriate success or error messages based on the actual operation status when adding or removing items, instead of always showing success messages even when operations failed.
      - **Added image slots to Wishlist**: Implemented image slots throughout the Wishlist drop-in to allow customization and replacement of default image rendering, providing extensibility for all images within the component.
      - **Enhanced Wishlist functionality**: Released an improved iteration of the Wishlist drop-in with better support for Adobe Commerce Cloud Service (ACCS) and enhanced move-to-cart flows for complex products, addressing feature gaps from the initial June release.

    </ChangelogEntry>

    <ChangelogEntry
      date="2025-06-25"
      title="Wishlist v1.0.0"
      components={['Wishlist']}
    >
      Initial release of the Wishlist drop-in component, including accompanying [developer](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/wishlist/) documentation.

    </ChangelogEntry>

  
</div>

---

# Release information

Adobe organizes storefront application releases into logical suite versions and follows a regular release schedule (approximately every other month). Adobe may release updates more frequently to deliver new features or address critical issues. 

## Release suites

The following sections provide high-level summaries of each release suite and details about the compatibility between storefront components. To see more details about each drop-in component by version, go to the [changelog](https://experienceleague.adobe.com/developer/commerce/storefront/releases/changelog/).

## October 2025 suite 

This suite release delivers significant enhancements to existing drop-in components, providing improved functionality and better user experiences for your storefront. The following table lists notable highlights. To see more details about each drop-in component by version, go to the [changelog](https://experienceleague.adobe.com/developer/commerce/storefront/releases/changelog/).

> **Note:** This release introduces the following breaking changes:

- **Product URL SKU enforcement**: The application now generates product URLs with lowercase SKUs only. If your products have uppercase SKUs but your metadata mapping doesn't properly handle the case conversion, the generated lowercase links may not resolve to your actual products. Before upgrading:
  - **Verify your metadata mapping** can handle SKU case conversions from uppercase to lowercase in your storefront configuration.
  - **Test product links with uppercase SKUs** after upgrading to ensure they still resolve to the correct product pages.
  - **Note**: While you can disable lowercase SKU enforcement, this is **not recommended** as it goes against URL consistency standards.

### Highlights

This release introduces several significant enhancements across the Commerce Storefront ecosystem:

- **Gift card product support**: You can now sell gift cards with full functionality including sender/recipient information, custom messages, preset and custom amounts, plus validation rules with complete internationalization support.
- **Tiered pricing with quantity discounts**: The Cart drop-in automatically applies tiered pricing, showing quantity-based discount percentages and encouraging bulk purchases with clear savings visibility.
- **Better search and filtering**: Product Discovery now supports new filter operators (contains, startsWith, eq) for more flexible product filtering and precise search results.
- **Smoother checkout experience**: The Checkout drop-in includes reusable utility libraries, better handling of fully discounted orders, and AEM Assets integration for gift options with visual swatch support.
- **Bundle products everywhere**: Both Wishlist and Product Details Page drop-ins now handle bundle products, letting customers save and manage complex bundle configurations with full option preservation.
- **Address validation available**: The User Account drop-in can now validate and suggest corrections for shipping/billing addresses, improving delivery accuracy and reducing failed deliveries.
- **Cookie security upgrade**: Authentication cookies now use the Secure flag, ensuring they're only transmitted over HTTPS connections for better security and protection against man-in-the-middle attacks.


### Updated boilerplate

The Commerce boilerplate has been enhanced with important bug fixes and improvements:

- **AEM Assets compatibility**: Decimal dimensions now render properly, supporting image rendering with decimal width/height values ([#767](https://github.com/hlxsites/aem-boilerplate-commerce/pull/767)).
- **Commerce Block documentation**: Commerce blocks now include comprehensive README files for better developer onboarding and implementation guidance ([#728](https://github.com/hlxsites/aem-boilerplate-commerce/pull/728)).
- **Configuration error handling**: Missing or invalid site configurations now show a helpful 418 error page that provides clear guidance to developers ([#714](https://github.com/hlxsites/aem-boilerplate-commerce/pull/714)).
- **Configuration fallback enhancement**: Single-endpoint setups now automatically fall back to "commerce-endpoint", simplifying configuration ([#700](https://github.com/hlxsites/aem-boilerplate-commerce/pull/700)).
- **Metadata and schema improvements**: Lowercase product SKUs now work in URLs, and metadata handling works properly for multistore configurations with JSON-LD path resolution ([#406](https://github.com/hlxsites/aem-boilerplate-commerce/pull/406), [#686](https://github.com/hlxsites/aem-boilerplate-commerce/pull/686)).
- **Mini-PDP component reorganization**: The mini-pdp component now lives in the components folder for better code organization and reusability ([#722](https://github.com/hlxsites/aem-boilerplate-commerce/pull/722)).
- **PDP state management**: Multiple PDPs on the same page no longer overwrite each other's state, ensuring proper product data isolation ([#696](https://github.com/hlxsites/aem-boilerplate-commerce/pull/696)).
- **Placeholder data preservation**: Placeholder data no longer gets lost, preventing content display issues ([#689](https://github.com/hlxsites/aem-boilerplate-commerce/pull/689)).
- **Search functionality improvements**: Search functionality now handles results better with improved styling ([#776](https://github.com/hlxsites/aem-boilerplate-commerce/pull/776)).
- **UI accessibility improvements**: Non-interactive elements no longer show pointer cursors, improving accessibility compliance ([#681](https://github.com/hlxsites/aem-boilerplate-commerce/pull/681)).

For complete details, see the [Boilerplate Updates changelog entry](https://github.com/hlxsites/aem-boilerplate-commerce/releases/tag/october-2025).

### Updated Drop-in SDK

> **Note:** The links to the StorefrontSDK repository will not resolve unless you have access to this repository.

The Drop-in SDK has been updated to include several new features and improvements:

- **New Table component**: The new Table component includes sortable columns, mobile-responsive layouts (stacked/scrollable), expandable row details, loading states with skeleton UI, and flexible column configuration with accessibility support ([#116](https://github.com/adobe-commerce/StorefrontSDK/pull/116), [#128](https://github.com/adobe-commerce/StorefrontSDK/pull/128)).
- **New MultiSelect component**: The new multi-select dropdown includes search/filter functionality, keyboard navigation (arrow keys, Enter, Escape), select/deselect all controls, customizable theming, floating label support, and comprehensive accessibility (ARIA labels, screen reader announcements) ([#126](https://github.com/adobe-commerce/StorefrontSDK/pull/126)).
- **New InputFile component**: The new file upload component includes custom styling, icon support, accept attribute for file type restrictions, and multiple file selection support ([#92](https://github.com/adobe-commerce/StorefrontSDK/pull/92)).
- **Button component enhancements**: Button components now support href and type properties (submit/reset/button), enabling better link functionality and form integration with proper semantic HTML output ([#121](https://github.com/adobe-commerce/StorefrontSDK/pull/121)).
- **ToggleButton improvements**: ToggleButton components now support disabled states with proper styling and improved accessibility attributes ([#120](https://github.com/adobe-commerce/StorefrontSDK/pull/120)).
- **Incrementer component enhancements**: Incrementer components now support a showButtons prop to conditionally hide increase/decrease buttons while maintaining input functionality and keyboard accessibility ([#112](https://github.com/adobe-commerce/StorefrontSDK/pull/112)).
- **GraphQL validation tools**: The GraphQL validation CLI now supports excluded paths option (-x flag) for more flexible development workflows ([#96](https://github.com/adobe-commerce/StorefrontSDK/pull/96)).
- **API method additions**: The fetch-graphql package now includes the getFetchGraphQlHeader method for header inspection, and the AEM Configs API now supports a match function option for improved configuration flexibility ([#113](https://github.com/adobe-commerce/StorefrontSDK/pull/113), [#105](https://github.com/adobe-commerce/StorefrontSDK/pull/105)).
- **Slot API enhancements**: The Slot API now includes a remove method for slot element removal, providing developers with granular control over slot lifecycle management ([#88](https://github.com/adobe-commerce/StorefrontSDK/pull/88)).
- **Lazy slots functionality**: Slot components now support a lazy prop for performance optimizations by deferring slot rendering until needed and reducing initial page load times ([#107](https://github.com/adobe-commerce/StorefrontSDK/pull/107)).
- **Image loading optimization**: Slot initialization now prevents intelligent image loading, stopping premature network requests and improving performance ([#123](https://github.com/adobe-commerce/StorefrontSDK/pull/123)).
- **Cross-platform compatibility**: Compilation now works properly on Windows systems, ensuring consistent development experience across all operating systems ([#108](https://github.com/adobe-commerce/StorefrontSDK/pull/108)).

### Updated drop-in components

| Component | Improvements |
|-----------|--------------|
| [**Cart**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/) v1.5.1 | â€¢ Tiered pricing now applies quantity-based discounts automaticallyâ€¢ Configurable product merging logic now creates cleaner cart experiencesâ€¢ Company context synchronization works for B2B scenariosâ€¢ Cross-tab logout synchronization now works properlyâ€¢ Checkout tax display shows "TBD" until taxes are calculatedâ€¢ Quantity input validation now handles maximum values correctlyâ€¢ Accessibility and Lighthouse scores are now higher |
| [**Checkout**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/) v2.1.0 | â€¢ Checkout architecture now includes reusable utilities and fragment-based layoutsâ€¢ Zero payment methods now work properly for fully discounted ordersâ€¢ Gift options now integrate with AEM Assets image support |
| [**Order**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/order/) v1.4.0 | â€¢ Order placement response structure now uses shared fragment patternâ€¢ Personal email context now appears in ACDL eventsâ€¢ ACDL order context now includes payment and discount trackingâ€¢ Returns list pagination now has smarter scroll behaviorâ€¢ GraphQL schema configuration now supports multi-store setups |
| [**Payment services**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/payment-services/) v1.0.2 | â€¢ Added `FASTLANE` payment method code to `PaymentMethodCode` enum |
| [**Product details page**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/) v1.3.5 | â€¢ Gift card products now work with sender/recipient information, custom messages, amount selection, and validation rulesâ€¢ Global locale integration now supports multi-language setupsâ€¢ Swatch accessibility now uses unique IDs and aria-labelsâ€¢ Dynamic bundle pricing calculations now work correctlyâ€¢ GraphQL integration upgraded to v1.2.0 with better header managementâ€¢ Carousel keyboard navigation now respects native browser behavior |
| [**Product discovery**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/) v2.1.0 | â€¢ getFetchGraphQlHeader method now available for header inspectionâ€¢ Search filters now support contains, startsWith, and eq operatorsâ€¢ Facet checkboxes now use unique IDs for better accessibility |
| [**Product recommendations**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/recommendations/) v1.1.1 | â€¢ ProductList now shows price ranges for complex productsâ€¢ Mobile view now has better carousel scrolling and responsive layoutsâ€¢ Global CSS styling conflicts are now resolved to prevent style leakage |
| [**User account**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/) v1.2.0 | â€¢ Address validation now available with new component and containerâ€¢ Form submission control now includes onSubmit callback propâ€¢ UID support now works for address selection and identificationâ€¢ Order history data structure now includes sku and urlKey fieldsâ€¢ Example implementations now show address validation patterns |
| [**User authentication**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/) v2.1.1 | â€¢ Cookie security now uses Secure flag for HTTPS-only transmission |
| [**Wishlist**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/wishlist/) v2.0.1 | â€¢ Visual flickering when opening wishlist is now resolvedâ€¢ Bundle product support is now availableâ€¢ API is now cleaner with unused pagination parameters removed |

> **Note:** To see details for each drop-in component by version, go to the [changelog](https://experienceleague.adobe.com/developer/commerce/storefront/releases/changelog/).

### Known issues

There are no known issues for this release suite.

### Component compatibility

This section provides details about the compatibility between Commerce Storefront components for this release suite. Adobe has tested and verified that each component version works together.

**Commerce Foundation:**

| Adobe Commerce | Storefront Compatibility Package |
|----------------|----------------------------------|
| `2.4.7`        | `4.7.11`                         |
| `2.4.8`        | `4.8.9`                          |

**Drop-in SDK package updates:**

- `@dropins/tools@~1.5.0`
- `@dropins/build-tools@~1.0.1`

**Drop-in package updates:**

- `@dropins/storefront-account@~1.2.0`
- `@dropins/storefront-auth@~2.1.1`
- `@dropins/storefront-cart@~1.5.1`
- `@dropins/storefront-checkout@~2.1.0`
- `@dropins/storefront-order@~1.4.0`
- `@dropins/storefront-payment-services@~1.0.2`
- `@dropins/storefront-pdp@~1.3.5`
- `@dropins/storefront-recommendations@~1.1.1`
- `@dropins/storefront-wishlist@~2.0.1`
- `@dropins/storefront-personalization@~1.0.1`
- `@dropins/storefront-product-discovery@~2.1.0`

## August 2025 suite

This suite release delivers significant enhancements to existing drop-in components, providing improved functionality and better user experiences for your storefront. The following table lists notable highlights. To see more details about each drop-in component by version, go to the [changelog](https://experienceleague.adobe.com/developer/commerce/storefront/releases/changelog/).

### Breaking changes

> **Note:** This release introduces the following breaking changes:

- **Product Discovery 2.0**: The Product Discovery drop-in has been upgraded to version 2.0.0 with a new event-driven architecture. This major version includes breaking changes to the API structure, event handling, and component interfaces. Existing implementations will need to be updated to use the new architecture and updated container interfaces.

### Highlights

This release introduces several significant enhancements across the Commerce Storefront ecosystem:

- **Cart undo functionality**: Added the ability for customers to undo product removals from their cart, providing a safety net for accidental deletions and improving the overall shopping experience.
- **Multi-step checkout template**: Introduced a comprehensive multi-step checkout template that provides a structured, user-friendly checkout flow with improved navigation and form organization.
- **Configurable product editing in cart**: Enhanced the cart experience by allowing customers to modify configurable product options directly from the cart without needing to return to the product page.
- **Product Listing Page error handling**: Resolved critical error display issues in Adobe Commerce Cloud Service (ACCS) Product Listing Pages, ensuring smooth browsing experiences.
- **Global locale support for Price component**: Enhanced the Price component to respect developer-supplied locale props, enabling consistent currency formatting across different regions.
- **Product Discovery 2.0**: Major version upgrade featuring a completely redesigned event-driven architecture with enhanced performance, improved documentation with new diagrams, and refactored styling system for better customization capabilities.

### Updated boilerplate

The Commerce boilerplate has been significantly enhanced with comprehensive improvements across multiple areas:

- **New components**: Added carousel and cards-list components for enhanced product display capabilities
- **Commerce Storefront compatibility**: Improved integration and compatibility with storefront-builder tools
- **Architecture improvements**: Comprehensive refactoring for better code organization and maintainability
- **Scripts.js refactoring**: Major restructuring for improved maintainability and performance
- **Enhanced drop-in functionality**: Improvements across Cart, Checkout, and Wishlist components
- **Header optimization**: Optimized header performance for faster loading
- **Accessibility enhancements**: Improved accessibility with global placeholders and modal localization
- **reCAPTCHA enhancements**: Enhanced reCAPTCHA integration and functionality
- **Product Discovery fixes**: Resolved search functionality issues
- **Documentation improvements**: Comprehensive updates to code documentation
- **Architecture cleanup**: Removed deprecated widgets for cleaner implementation

For complete details, see the [Boilerplate Updates changelog entry](https://github.com/hlxsites/aem-boilerplate-commerce/releases/tag/august-2025).

### Updated Drop-in SDK

The Drop-in SDK has been updated to include several new features and improvements:

- **Global locale support for Price component**: Enhanced the Price component to respect developer-supplied locale props, enabling consistent currency formatting across different regions.
- **Improved ProductItemCard skeleton styling**: Refactored ProductItemCard styles and skeleton component for better visual consistency. Updated skeleton image height, standardized SkeletonRow element sizing, and enhanced visual separation with improved border styling for a cleaner loading experience.
- **Enhanced Event Bus functionality**: Expanded Event Bus with comprehensive documentation, scoped events for namespaced event handling, and eager loading for immediate payload retrieval. Added support for optional scope parameters in event emission and subscription methods, with comprehensive test coverage for improved event-driven architecture flexibility.
- **Icon component URL support**: Extended the Icon component to load custom SVG icons from URLs, enabling merchants to use custom payment method icons and other branded elements. The component now supports lazy loading of external SVGs with proper validation, accessibility enhancements, dynamic sizing, and error handling for failed URL requests.


### Updated drop-in components

| Component | Improvements |
|-----------|--------------|
| [**Cart**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/) v1.5.0 | â€¢ Extended Add/Update Cart API with custom fields supportâ€¢ Added undo functionality for removed cart itemsâ€¢ Enhanced mini cart flexibility with improved slot architectureâ€¢ Fixed missing Channel Field in AEP events |
| [**Checkout**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/) v2.0.1 | â€¢ Updated multi-step checkout tutorial with comprehensive examplesâ€¢ Enhanced modular architecture with event-driven step coordinationâ€¢ Improved support for guest users, logged-in customers, and mixed cart scenariosâ€¢ Miscellaneous bug fixes and enhancements |
| [**Order**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/order/) v1.3.0 | â€¢ Fixed cancelled product display and messaging issuesâ€¢ Added Channel Field to all AEP events for complete data collectionâ€¢ Resolved reCAPTCHA v3 integration blocking order placementâ€¢ Enhanced CartSummaryItem user experience for cancelled orders |
| [**Personalization**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/personalization/) v1.0.1 | â€¢ Fixed personalization data update after order placementâ€¢ Ensured accurate customer segmentation and targeting post-purchase |
| [**Product details page**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-details/) v1.3.0 | â€¢ Fixed AEM Assets image zoom functionalityâ€¢ Enhanced Product Gallery with video media supportâ€¢ Fixed missing price handling to prevent page crashesâ€¢ Resolved carousel loopable configuration display issues |
| [**Product discovery**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/) v2.0.0 | â€¢ **Major version upgrade** with completely redesigned event-driven architectureâ€¢ Enhanced performance and improved container interfacesâ€¢ Updated documentation with comprehensive new diagramsâ€¢ Refactored styling system with new CSS files for better customizationâ€¢ Breaking changes require updates to existing implementations |
| [**Product recommendations**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/recommendations/) v1.1.0 | â€¢ Added recommendation API events for better tracking and monitoringâ€¢ Enhanced screen reader accessibility with improved ARIA labelsâ€¢ Added GraphQL extensibility with customizable fragments and transformersâ€¢ Fixed recommendation click tracking and added add-to-cart event support |
| [**User account**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-account/) v1.0.9 | â€¢ Fixed empty order list issue when orders contain out-of-stock productsâ€¢ Added grandTotalExclTax field support for accurate tax calculationsâ€¢ Enhanced Order confirmation to prevent negative tax totals on zero-total ordersâ€¢ Improved frontend calculation accuracy by using backend-provided tax data |
| [**User authentication**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/user-auth/) v2.1.0 | â€¢ Fixed missing Channel Field in all AEP events for complete data collectionâ€¢ Enhanced Reset Password form with proper email validationâ€¢ Prevented unnecessary GraphQL requests for invalid email addressesâ€¢ Improved event categorization with proper global storefront context |
| [**Wishlist**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/wishlist/) | â€¢ Fixed accessibility issues with proper aria-label attributesâ€¢ Enhanced Wishlist functionality with better support for Adobe Commerce as a Cloud Service and move-to-cart flowsâ€¢ Added image slots for customizable image renderingâ€¢ Fixed alert messaging to show accurate success/error status |

> **Note:** To see details for each drop-in component by version, go to the [changelog](https://experienceleague.adobe.com/developer/commerce/storefront/releases/changelog/).

### Known issues

The known issues for this release suite are:

- **Product Recommendations**: Configurable products in the Product Recommendations container display $0.00 instead of the expected "As low as $X.XX" minimum price format, even though the GraphQL API returns the correct pricing data.
- **Product Recommendations**: The `rec-click` event incorrectly triggers when shoppers click on the wishlist symbol within recommendation product item cards, when it should only generate for actual product clicks.


### Component compatibility

This section provides details about the compatibility between Commerce Storefront components for this release suite. Adobe has tested and verified that each component version works together.

**Commerce Foundation:**

| Adobe Commerce | Storefront Compatibility Package |
|----------------|----------------------------------|
| `2.4.7`        | `4.7.11`                         |
| `2.4.8`        | `4.8.8`                          |

**Drop-in SDK package updates:**

- `@dropins/tools@~1.4.0`
- `@dropins/build-tools@~1.0.1`

**Drop-in package updates:**

- `@dropins/storefront-account@~1.0.9`
- `@dropins/storefront-auth@~2.1.0`
- `@dropins/storefront-cart@~1.5.0`
- `@dropins/storefront-checkout@~2.0.1`
- `@dropins/storefront-order@~1.3.0`
- `@dropins/storefront-payment-services@~1.0.1`
- `@dropins/storefront-pdp@~1.3.0`
- `@dropins/storefront-recommendations@~1.1.0`
- `@dropins/storefront-wishlist@~2.0.0`
- `@dropins/storefront-personalization@~1.0.1`
- `@dropins/storefront-product-discovery@~2.0.0`

## June 2025 suite


<summary><strong>Click to view details</strong></summary>

<div style="margin-top: 1rem;">

This release suite introduces four new drop-in components (Product Discovery, Product Recommendations, Wishlist, and Personalization) along with major improvements to existing components including enhanced cart functionality, multi-step checkout, and upgraded infrastructure with Helix 5.

### New drop-in components

This suite release includes several new drop-in components to help you build a more personalized and engaging storefront.

- [**Product Discovery**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/product-discovery/): Provides a variety of fully-customizable controls to showcase your products (according to your brand's aesthetics) and build interactive experiences that engage customers.
- [**Product Recommendations**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/recommendations/): Provides a powerful way to suggest products to customers based on their browsing patterns and behaviors
- [**Wishlist**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/wishlist/): Provides both guests and registered customers with a mechanism to store products they are interested in purchasing later.
- [**Personalization**](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/personalization/): Provides a set of tools and containers designed to display content conditionally, based on Adobe Commerce customer groups, segments, and cart price rules.

### Additional improvements

This suite release delivers significant enhancements to existing drop-in components, providing improved functionality and better user experiences for your storefront. The following table lists notable highlights. To see more details about each drop-in component by version, go to the [changelog](https://experienceleague.adobe.com/developer/commerce/storefront/releases/changelog/).

| Component | Improvements |
|-----------|--------------|
| AEM Assets | Integrated across the suite of drop-in components |
| Cart | â€¢ Improved extensibility for mini cart including additional [layout options](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/containers/cart-summary-table/)â€¢ Introduced the ability to [edit product options](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/tutorials/enable-product-variation-updates-in-cart/) directly from the cartâ€¢ Mini cart [shows a message](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/tutorials/add-messages-to-mini-cart/) upon adding products to the cart |
| Checkout | â€¢ [Configure terms and conditions](https://experienceleague.adobe.com/developer/commerce/storefront/merchants/get-started/terms-and-conditions/)â€¢ [Improved error handling](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/checkout/error-handling/)â€¢ [Improved event handling](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/events/) |
| PDP | â€¢ Supports updating cart items by URL (`itemUid`) |
| Storefront Compatibility Package (SCP) | â€¢ Secure [personalization](https://experienceleague.adobe.com/developer/commerce/storefront/merchants/get-started/personalization/) featuresâ€¢ Social login integration APIs |
| Boilerplate | â€¢ Upgraded boilerplate to Helix 5â€¢ Improvements to scaffolding toolâ€¢ Centralized configuration through NPMâ€¢ Updated the [localization approach](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/labeling/) across the boilerplateâ€¢ Eliminated the need to manage or modify configuration logic manually. Updates can now be delivered through standard package upgrades. |

<Aside type="note">
To see details for each drop-in component by version, go to the [changelog](https://experienceleague.adobe.com/developer/commerce/storefront/releases/changelog/).
</Aside>

### Component compatibility

This section provides details about the compatibility between Commerce Storefront components for this release suite. Adobe has tested and verified that each component version works together.

**Commerce Foundation:**

| Adobe Commerce | Storefront Compatibility Package |
|----------------|----------------------------------|
| `2.4.7`        | `4.7.9`                          |
| `2.4.8`        | `4.8.6`                          |

**Drop-in SDK:**

- `@dropins/tools@1.3.0`
- `@dropins/build-tools@1.0.1`

**Drop-in components:**

- `@dropins/storefront-account@~1.0.7`
- `@dropins/storefront-auth@~2.0.3`
- `@dropins/storefront-cart@1.4.0`
- `@dropins/storefront-checkout@~2.0.0`
- `@dropins/storefront-order@~1.2.0`
- `@dropins/storefront-payment-services@~1.0.1`
- `@dropins/storefront-pdp@1.2.0`
- `@dropins/storefront-recommendations@^1.0.0`
- `@dropins/storefront-wishlist@^1.0.0`
- `@dropins/storefront-personalization@~1.0.0`
- `@dropins/storefront-product-discovery@^1.0.1`

</div>


## April 2025 suite


<summary><strong>Click to view details</strong></summary>

<div style="margin-top: 1rem;">

**Commerce Foundation:**
- **Adobe Commerce:** `2.4.7`
- **Storefront Compatibility Package:** `4.7.1`

**Drop-in SDK:**
- `@dropins/tools@0.42.0`
- `@dropins/build-tools@0.2.0`

**Drop-in components:**
- `@dropins/storefront-cart@1.2.2`
- `@dropins/storefront-checkout@1.3.0`
- `@dropins/storefront-order@1.0.5`
- `@dropins/storefront-payment-services@1.0.1`
- `@dropins/storefront-pdp@1.0.0`
- `@dropins/storefront-user-account@1.0.4`
- `@dropins/storefront-user-auth@1.0.6`

</div>


## December 2024 suite


<summary><strong>Click to view details</strong></summary>

<div style="margin-top: 1rem;">

**Commerce Foundation:**
- **Adobe Commerce:** `2.4.7`
- **Storefront Compatibility Package:** `4.7.0`

**Drop-in SDK:**
- `@dropins/tools@0.38.0`
- `@dropins/build-tools@0.1.1`

**Drop-in components:**
- `@dropins/storefront-cart@1.0.1`
- `@dropins/storefront-checkout@1.0.0`
- `@dropins/storefront-order@1.0.0`
- `@dropins/storefront-payment-services@1.0.1`
- `@dropins/storefront-pdp@1.0.0`
- `@dropins/storefront-user-account@1.0.0`
- `@dropins/storefront-user-auth@1.0.0`

</div>


## Code changes

Every release includes changes to one or more codebases described in the compatibility section of each release suite. The scope of the change determines whether the MAJOR, MINOR, or PATCH number increases in the application's version according to [semantic versioning](https://semver.org/):

> Given a version number MAJOR.MINOR.PATCH, increment the:
> 
> MAJOR version when you make incompatible API changes  
> MINOR version when you add functionality in a backward-compatible manner  
> PATCH version when you make backward-compatible bug fixes  

### Public API

To determine when we increment the MAJOR version we must define a public API. The public API for drop-in components includes the following:

#### Integration APIs

Integration APIs are functions that are exposed to the storefront application to integrate the drop-in components. These functions are defined in the drop-in SDK and are used by the drop-in components.

| File | Function Signatures |
|---|---|
| `@dropins/tools/fetch-graphql.js` | `setEndpoint``setFetchGraphQlHeader``removeFetchGraphQlHeader``setFetchGraphQlHeaders``fetchGraphQl``getConfig` |
| `@dropins/tools/event-bus.js` | `on``emit``lastPayload` |
| `@dropins/tools/initializer.js` | `mountImmediately` |
| `@dropins/tools/lib.js` | `debounce``getFormValues``getFormErrors``classes``deepmerge``merge``generateSrcset` |

#### Slots

Slots are built-in extension points in the drop-in components to add your own UI components and functions. The following table lists the default properties and individual drop-in slots that are available:

| Type | Description |
|---|---|
| Default properties available to all slots: | Function signatures of the following functions:`prependSibling``prependChild``replaceWith``appendChild``appendSibling``getSlotElement``onChange` |
| | Structure of the [`dictionary`](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/labeling/) object |
| Individual drop-in slots | Function signatures as defined elsewhere on this site (for example, [cart slots](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/cart/slots/)) |

#### Drop-in design tokens

Drop-in [design tokens](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/branding/#design-tokens) are defined in the drop-in SDK and are used by the drop-in components to style the storefront application.

---

# Frequently Asked Questions (FAQ)

## Where can I find technical documentation?

- [Storefront drop-in components](https://experienceleague.adobe.com/developer/commerce/storefront/dropins/all/introduction/)
- [Catalog Service](https://experienceleague.adobe.com/en/docs/commerce/catalog-service/guide-overview)
- [Live Search](https://experienceleague.adobe.com/en/docs/commerce/live-search/overview)
- [[AEM Gems] Building Storefronts on Edge Delivery Services with Adobe Commerce](https://experienceleaguecommunities.adobe.com/t5/adobe-experience-manager/aem-gems-building-storefronts-on-edge-delivery-services-with/m-p/652692)
- [[AdaptTo] Build Super Fast Storefront Experiences with Edge Delivery Services and Adobe Commerce](https://adapt.to/2023/schedule/build-super-fast-storefront-experiences-with-edge-delivery-services-and-adobe-commerce)
- [[Summit 2024] Commerce Lab Workbook](https://bit.ly/L445-workbook)

## What should I do if my Catalog Service/Live Search data is missing or corrupted?

Submit a request to Adobe Commerce Support to clear your data space. This deletes all data within Catalog Service/Live Search for a specific environment ID. Be careful not to clear any data space required for production.

After Adobe Commerce Support clears your data space, you can re-synchronize it using the following commands:

```bash
bin/magento saas:resync --feed scopesCustomerGroup --cleanup-feed
bin/magento saas:resync --feed scopesWebsite --cleanup-feed
bin/magento saas:resync --feed productattributes --cleanup-feed
bin/magento saas:resync --feed variants --cleanup-feed
bin/magento saas:resync --feed products --cleanup-feed
bin/magento saas:resync --feed productoverrides --cleanup-feed
bin/magento saas:resync --feed prices --cleanup-feed
bin/magento saas:resync --feed categories --cleanup-feed
bin/magento saas:resync --feed categoryPermissions --cleanup-feed
```

See the [_SaaS Data Export Guide_](https://experienceleague.adobe.com/en/docs/commerce/saas-data-export/overview) for more information.

## How can I improve the performance of my catalog pages?

### Images

- Product images should be delivered in the appropriate size and should not be delivered larger than their rendered size. Use Fastly Image Optimizer where possible to deliver images in modern `.webp` format.
- Use `loading="eager"` on largest contentful paint (LCP) relevant images and `loading="lazy"` on images with lower priority. Be aware that these attributes are a hint only for the browser.

### API

- Blocks that load data from APIs must have proper sizing in their loading state to prevent layout shift when they start to render content.
- API endpoints should be proxied through a content delivery network (CDN) to prevent overhead of cross-origin resource sharing (CORS) (`OPTIONS` calls) and TLS handshakes.
- Start GraphQL queries early (for example, in eager phase)

### Preloading

- Frequently used `commerce.js` and `configs.js` files can be loaded early by adding them to the `head.html` file.
- Remove waterfall loading of files. If you know in advance which files are required, load them early or combine them to load fewer files.
- You can preload resources/queries in the eager phase of the `scripts.js` file if they are very heavy. You can use global promises or a link tag with preload attribute in the head to prevent downloading the same resource multiple times.

### Loading order

- Everything that is not relevant for LCP can be loaded progressively (dynamic imports) or delayed (`delayed.js`).
- LCP relevant blocks (for example, product details, product list page) must be loaded in the eager phase. This means that they need to be the first block on the page and added to the `LCP_BLOCKS` array.
- Only load elements that are required. Elements that are not immediately required should be separated and loaded when needed.
  - **Example 1:** Logic for newsletter sign-up can be loaded when the user clicks on the subscribe button.
  - **Example 2:** Minicart block is loaded on every page but only loads lightweight code to display button and a number. The full minicart block is loaded only upon a click of the button.

### Libraries

Use Preact/HTM or other libraries only when necessary.

### Thid-party integrations

- Prefer APIs over embedding third-party scripts.
- If you must embed third-party scripts, try using placeholders to prevent cumulative layout shift (CLS). Load them delayed or when they appear in the viewport (`IntersectionObserver`).
- Be careful with how you add fonts to the project. Ideally, you should avoid using fonts hosted by third parties.

## How do I deploy custom VCLs to Fastly?

See [Getting started with custom VCL](https://experienceleague.adobe.com/en/docs/commerce-cloud-service/user-guide/cdn/custom-vcl-snippets/fastly-vcl-custom-snippets) in the _Commerce on Cloud Infrastucture Guide_.

## What should I do if my email template links are broken after migrating to Edge Delivery Services or Helix?

By default, Adobe Commerce [email templates](https://experienceleague.adobe.com/en/docs/commerce-admin/systems/communications/email-templates) (such as "Forgot Password" and "Create Password") use camelCase in their route URLs (for example, `/customer/account/forgotPassword`). However, Helix 5 and Edge Delivery Services only support lowercase routes (for example, `/customer/account/forgotpassword`). This incompatibility means that links in default email templates will not work correctly on Commerce Storefronts powered by Edge Delivery Services.

> **Note:** For full Edge Delivery Services migrations, all template paths must be lowercase. In Luma Bridge scenarios, camelCase can be used only if those routes are served from Luma; otherwise, they must be converted to lowercase.

To fix this issue, you can [customize email](https://experienceleague.adobe.com/en/docs/commerce-admin/systems/communications/email-template-custom) templates to use the following workaround:



<Task>

### Create a custom email template for the "Forgot Password" and "Create Password" pages

<Steps>
1. Log in to the Commerce Admin.
1. On the Admin sidebar, go to **Marketing** > _Communications_ > **Email Templates**.
1. Click **Add New Template**.
1. In the **Load default template** section, click the **Template** selector and choose `Magento_Customer > Forgot Password`.
1. Click **Load Template**.

   The HTML code and variables from the template appear in the form.

1. Enter the **Template Name**. For example, "Forgot Passsword - Edge Delivery Services".
1. In the **Template Content** field, change any camelCase or capitalized route URLs to all lowercase. See the following screenshot for an example.

   ![Forgot Password template](@images/troubleshoot/forgot-password-template.png/)

1. Click **Save Template**.

</Steps>

</Task>

<Task>

### Update the configuration

<Steps>

1. On the Admin sidebar, go to **Stores** > _Settings_ > **Configuration**.
1. Click **Customers** > **Customer Configuration**.
1. Expand the **Password Options** section.
1. Set **Forgot Email Template** to the custom template that you created in Step 1. See the following screenshot for an example.

   ![Forgot Password template](@images/troubleshoot/forgot-password-template-config.png/)

1. Click **Save Config**.

</Steps>

</Task>



## Why don't I see my configuration changes in the browser?

The [storefront configuration](https://experienceleague.adobe.com/developer/commerce/storefront/setup/configuration/commerce-configuration/#configuration-caching) is cached by the Edge CDN with a `max-age=7200` (2 hours) cache control header.

When the storefront configuration is loaded in the browser, it is stored in [session storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage). This means that the configuration persists until the browser session is cleared, or the page is refreshed after the expiration of the CDN cache. You can verify the current configuration by accessing `<site.com>/config.json` directly in your browser. This will show you the current configuration being served by the CDN.

**For developers:** If your configuration changes are not reflected in the browser, check for CDN cache expiration by accessing `<site.com>/config.json` directly in your browser. If the updated configuration is available on the CDN, manually clear the session storage:
1. Open the browser developer tools.
1. Select the **Application** tab, then select **Storage**.
1. Clear the session storage for your domain.
1. Refresh the page.

**For end users:** Clear the browser session by closing and reopening the browser, or clear the browsing data to see configuration changes.

---

# PageSpeed Insights issues

Common issues for PageSpeed Insights errors and how to resolve them.

## Status code 404


  ![Diagram for how to brand drop-in components](@images/troubleshoot/pagespeed-404.webp/)


### If This

You view lots ofâ—ï¸red exclamation points and a status code of 404 for your preview (`.page`) or production (`.live`) storefront URLs.

### Check This

Red dots indicate that the page has not been published or previewed since last edited. The 404 error only happens if you've never published or previewed the page you enter into the PageSpeed Insights text field (which includes your `index` page when you only enter your site's URL). So because you never published the page (using Sidekick), Edge Delivery has not yet added the page to the preview or production CDNs, where PageSpeed Insights (and everyone else on the internet) looks for it. The result is a 404 error.

### Do This



1. **Publish** or **Preview** the page using the Sidekick buttons.
1. Clear your browser cache.
1. Wait a minute or two for the page to be added to the preview CDN (**Preview** button) or production CDN (**Publish** button).

---

# Overview



---

# Placeholders files

The `placeholders` files are the source for storefront labels across drop-in components. The `placeholders` files have two columns: **Key** and **Value**. The Key column contains the text variables that are replaced at runtime. The Value column contains the text values that replace the variables. These files provide a quick and easy way for content creators and merchants to make changes to the site's labels without developer involvement.

## Placeholders default values

The initial values in the `placeholder` file within the boilerplate's starter content provides the default out-of-the-box labels for the drop-in components.

You can view the current placeholder values for each drop-in component in the following JSON files:

- [Global placeholders](https://main--boilerplate--adobe-commerce.aem.page/placeholders/global.json)
- [Account placeholders](https://main--boilerplate--adobe-commerce.aem.page/placeholders/account.json)
- [Auth placeholders](https://main--boilerplate--adobe-commerce.aem.page/placeholders/auth.json)
- [Cart placeholders](https://main--boilerplate--adobe-commerce.aem.page/placeholders/cart.json)
- [Checkout placeholders](https://main--boilerplate--adobe-commerce.aem.page/placeholders/checkout.json)
- [Order placeholders](https://main--boilerplate--adobe-commerce.aem.page/placeholders/order.json)
- [Product Details Page placeholders](https://main--boilerplate--adobe-commerce.aem.page/placeholders/pdp.json)
- [Search placeholders](https://main--boilerplate--adobe-commerce.aem.page/placeholders/search.json)
- [Wishlist placeholders](https://main--boilerplate--adobe-commerce.aem.page/placeholders/wishlist.json)
- [Recommendations placeholders](https://main--boilerplate--adobe-commerce.aem.page/placeholders/recommendations.json)

These JSON files contain all the current placeholder keys and their corresponding values. The `global.json` file contains placeholders that apply to the entire storefront, while the other JSON files contain placeholders specific to their respective drop-in components. You can reference these files to see the exact structure and values used in the boilerplate.

---

# Adobe Commerce Storefront

